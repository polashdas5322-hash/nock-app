# VIVE PROJECT - COMBINED SOURCE CODE
# Generated: 01/25/2026 19:00:46
# Total Files: Dart + Kotlin + Swift




========================================

FILE #1: E:\Vive\lib\main.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'core/theme/app_theme.dart';
import 'core/theme/app_colors.dart';
import 'core/router/app_router.dart';
import 'core/services/widget_update_service.dart';
import 'core/services/cache_cleanup_service.dart';
import 'core/services/deep_link_service.dart';
import 'core/services/fcm_token_service.dart';
import 'core/services/audio_service.dart';
import 'core/services/subscription_service.dart';

/// Main entry point for the Nock app
void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Set preferred orientations
  await SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  // Set system UI overlay style for immersive experience
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
      systemNavigationBarColor: Color(0xFF121212),
      systemNavigationBarIconBrightness: Brightness.light,
    ),
  );

  // Initialize Firebase
  await Firebase.initializeApp();

  // ðŸ“¶ OFFLINE CONTINUITY: Ensure dashboard is "Instant-On" even without network.
  // We explicitly enable persistence but use default cache size (40MB) for security.
  FirebaseFirestore.instance.settings = const Settings(
    persistenceEnabled: true,
  );

  // Register FCM background message handler for widget updates
  // This MUST be done before runApp() and handler MUST be top-level
  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  // STARTUP FIX: Don't request notification permissions here!
  // It blocks app launch and users deny without context.
  // Instead, ask AFTER first vibe is sent (contextual permission priming)
  // See: preview_screen.dart _askForNotificationsContextually()

  
  // REMOVED: _syncPendingReadReceipts() - Race Condition Fix
  // The sync is now handled reactively in HomeScreen via ref.listen on currentUserProvider.
  // This fixes the race condition where authStateChanges().first could timeout on slow devices.
  // See: lib/features/home/presentation/home_screen.dart - build() method

  // Run the app
  runApp(
    const ProviderScope(
      child: NockApp(),
    ),
  );
}


// REMOVED: _syncPendingReadReceipts() function
// The blocking auth check with timeout was causing silent failures on slow devices.
// This logic is now in HomeScreen.build() using ref.listen for reactive sync.
// Benefits:
// 1. Zero-Blocking Launch: App starts instantly
// 2. Guaranteed Auth: Sync only happens when user is confirmed authenticated
// 3. Self-Healing: Re-syncs on re-login or account switch

// REMOVED: _requestNotificationPermissions
// This is now handled contextually in preview_screen.dart

/// Root application widget
class NockApp extends ConsumerStatefulWidget {
  const NockApp({super.key});

  @override
  ConsumerState<NockApp> createState() => _NockAppState();
}

class _NockAppState extends ConsumerState<NockApp> {
  // Track initialization state
  bool _isInitialized = false;

  @override
  void initState() {
    super.initState();
    // Start initialization immediately (not in addPostFrameCallback)
    _initApp();
  }
  
  Future<void> _initApp() async {
    try {
      final router = ref.read(routerProvider);
      
      // Initialize deep link handling
      final deepLinkService = ref.read(deepLinkServiceProvider);
      await deepLinkService.initialize(router);
      
      // Initialize FCM with router
      final fcmService = ref.read(fcmTokenServiceProvider);
      await fcmService.initialize(router: router);

      // Initialize Cache & Subscription services
      final cacheService = ref.read(cacheCleanupServiceProvider);
      await cacheService.initialize();
      
      final subscriptionService = ref.read(subscriptionServiceProvider);
      await subscriptionService.initialize();

      // Audio Focus & Session (Best Practice)
      await AudioService.initSession();

      // Sync theme colors to native widgets
      await AppColors.syncThemeWithWidgets();

    } catch (e) {
      debugPrint('Service initialization error: $e');
    } finally {
      // Mark as initialized regardless of success/failure to unblock app
      if (mounted) {
        setState(() {
          _isInitialized = true;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    // 1. BLOCK the app until services are ready
    if (!_isInitialized) {
      // Return a simple loading screen
      // This prevents the Router from even existing yet
      return MaterialApp(
        debugShowCheckedModeBanner: false,
        theme: ThemeData(
          scaffoldBackgroundColor: AppColors.background,
        ),
        home: const Scaffold(
          body: Center(
            child: CircularProgressIndicator(
              color: AppColors.primaryAction,
              strokeWidth: 3,
            ),
          ),
        ),
      );
    }

    // 2. Services are ready: Render the real app with Router
    final router = ref.watch(routerProvider);

    return MaterialApp.router(
      title: 'Nock',
      debugShowCheckedModeBanner: false,
      theme: AppTheme.darkTheme,
      routerConfig: router,
      builder: (context, child) {
        // ACCESSIBILITY FIX: Allow text scaling but cap it to prevent layout breaks
        final textScaler = MediaQuery.textScalerOf(context);
        return AudioLifecycleManager(
          child: MediaQuery(
            data: MediaQuery.of(context).copyWith(
              textScaler: textScaler.clamp(maxScaleFactor: 1.3),
            ),
            child: child ?? const SizedBox(),
          ),
        );
      },
    );
  }
}




========================================

FILE #2: E:\Vive\lib\core\constants\app_constants.dart

========================================


/// App-wide constants for Vibe
class AppConstants {
  AppConstants._();

  // App Info
  static const String appName = 'Nock';
  static const String appVersion = '1.0.0';

  // Firebase Collections
  static const String usersCollection = 'users';
  static const String squadsCollection = 'squads';
  static const String messagesCollection = 'messages';
  static const String vibesCollection = 'vibes';
  static const String friendshipsCollection = 'friendships';

  // Storage Paths
  static const String audioStoragePath = 'audio';
  static const String imagesStoragePath = 'images';
  static const String videosStoragePath = 'videos';
  static const String avatarsStoragePath = 'avatars';

  // Limits
  static const int maxVoiceNoteDuration = 15; // seconds
  static const int maxSquadMembers = 20;
  static const int freeHistoryHours = 24;
  static const int maxFriendsCount = 20;
  static const int reverseTrialDays = 7;

  // Audio Settings
  static const int audioSampleRate = 44100;
  static const int audioBitRate = 128000;

  // Widget
  static const String widgetId = 'vibe_widget';
  static const String iosAppGroupId = 'group.com.vibe.app';

  // Subscription Tiers
  static const String subscriptionMonthlyId = 'vibe_plus_monthly';
  static const String subscriptionWeeklyId = 'vibe_plus_weekly';
  static const String subscriptionAnnualId = 'vibe_plus_annual';
  
  static const String premiumEntitlementId = 'premium_entitlement';
  
  static const double priceMonthly = 4.99;
  static const double priceWeekly = 0.99;
  static const double priceAnnual = 29.99;

  // RevenueCat Keys (Provide via --dart-define or secure config)
  static const String rcAppleApiKey = String.fromEnvironment('RC_APPLE_API_KEY', defaultValue: '');
  static const String rcGoogleApiKey = String.fromEnvironment('RC_GOOGLE_API_KEY', defaultValue: '');

  // AI Keys (Provide via --dart-define or secure config)
  static const String openAiApiKey = String.fromEnvironment('OPENAI_API_KEY', defaultValue: '');

  // Time Values
  static const int widgetUpdateIntervalMinutes = 15;
  
  /// ðŸŒ± Friendship Garden: Days until garden goes dormant (paused, not dead)
  /// After this many days, the garden merely "rests" - one vibe revives it!
  static const int gardenDormantDays = 3;

  // Animation Durations
  static const Duration animFast = Duration(milliseconds: 150);
  static const Duration animNormal = Duration(milliseconds: 300);
  static const Duration animSlow = Duration(milliseconds: 500);
  static const Duration animVerySlow = Duration(milliseconds: 800);

  // UI Values
  static const double borderRadiusSmall = 8.0;
  static const double borderRadiusMedium = 12.0;
  static const double borderRadiusLarge = 16.0;
  static const double borderRadiusXLarge = 24.0;
  static const double borderRadiusCircle = 100.0;

  // Glassmorphism
  static const double glassBlurAmount = 5.0;
  static const double glassOpacity = 0.1;
}



========================================

FILE #3: E:\Vive\lib\core\constants\app_routes.dart

========================================


/// Route names for navigation
class AppRoutes {
  AppRoutes._();

  // Auth Routes
  static const String splash = '/';
  static const String onboarding = '/onboarding';
  static const String welcome = '/welcome';
  static const String phoneAuth = '/phone-auth';
  static const String verifyOtp = '/verify-otp';

  // Permission Routes
  static const String permissionMic = '/permission/microphone';
  static const String permissionNotification = '/permission/notification';
  static const String permissionContacts = '/permission/contacts';
  static const String permissionCamera = '/permission/camera';
  static const String widgetSetup = '/widget-setup';

  // Main Routes
  static const String home = '/home';
  static const String camera = '/camera';
  static const String squadManager = '/home/squad';
  static const String vault = '/home/vault';
  static const String settings = '/settings';

  // Feature Routes
  static const String player = '/home/player'; // Base path for player
  static const String gallery = '/gallery';
  static const String profile = '/profile';
  static const String addFriend = '/add-friend';
  static const String addFriends = '/home/add-friends';
  static const String subscription = '/home/subscription';
  static const String widgetConfig = '/widget-config';
}



========================================

FILE #4: E:\Vive\lib\core\models\squad_model.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';
import 'vibe_model.dart';

/// Squad model - represents a group of close friends
class SquadModel {
  final String id;
  final String name;
  final String? iconUrl;
  final String creatorId;
  final List<String> memberIds;
  final DateTime createdAt;
  final DateTime updatedAt;
  final SquadLastMessage? lastMessage;

  SquadModel({
    required this.id,
    required this.name,
    this.iconUrl,
    required this.creatorId,
    required this.memberIds,
    required this.createdAt,
    required this.updatedAt,
    this.lastMessage,
  });

  factory SquadModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return SquadModel(
      id: doc.id,
      name: data['name'] ?? '',
      iconUrl: data['iconUrl'],
      creatorId: data['creatorId'] ?? '',
      memberIds: List<String>.from(data['memberIds'] ?? []),
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (data['updatedAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastMessage: data['lastMessage'] != null
          ? SquadLastMessage.fromMap(data['lastMessage'])
          : null,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'name': name,
      'iconUrl': iconUrl,
      'creatorId': creatorId,
      'memberIds': memberIds,
      'createdAt': Timestamp.fromDate(createdAt),
      'updatedAt': Timestamp.fromDate(updatedAt),
      'lastMessage': lastMessage?.toMap(),
    };
  }

  SquadModel copyWith({
    String? id,
    String? name,
    String? iconUrl,
    String? creatorId,
    List<String>? memberIds,
    DateTime? createdAt,
    DateTime? updatedAt,
    SquadLastMessage? lastMessage,
  }) {
    return SquadModel(
      id: id ?? this.id,
      name: name ?? this.name,
      iconUrl: iconUrl ?? this.iconUrl,
      creatorId: creatorId ?? this.creatorId,
      memberIds: memberIds ?? this.memberIds,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      lastMessage: lastMessage ?? this.lastMessage,
    );
  }
}

/// Denormalized last message for quick squad list rendering
class SquadLastMessage {
  final String senderId;
  final String senderName;
  final int audioDuration;
  final DateTime sentAt;
  final bool hasImage;

  SquadLastMessage({
    required this.senderId,
    required this.senderName,
    required this.audioDuration,
    required this.sentAt,
    this.hasImage = false,
  });

  factory SquadLastMessage.fromMap(Map<String, dynamic> map) {
    return SquadLastMessage(
      senderId: map['senderId'] ?? '',
      senderName: map['senderName'] ?? '',
      audioDuration: map['audioDuration'] ?? 0,
      sentAt: map['sentAt'] != null
          ? (map['sentAt'] as Timestamp).toDate()
          : DateTime.now(),
      hasImage: map['hasImage'] ?? false,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'senderId': senderId,
      'senderName': senderName,
      'audioDuration': audioDuration,
      'sentAt': Timestamp.fromDate(sentAt),
      'hasImage': hasImage,
    };
  }
}

/// Friendship model for tracking connections between users
/// Uses "Friendship Garden" model - relationships grow, never die
class FriendshipModel {
  final String id;
  final String userId;
  final String friendId;
  final FriendshipStatus status;
  final DateTime createdAt;
  final DateTime? lastVibeAt;
  
  /// Total memories shared (ACCUMULATES, never resets)
  /// This is the "Garden" model - your friendship grows over time
  final int memoriesShared;
  
  /// Vibe Level - positive framing (bloom/steady/chill)
  /// Unlike "streaks", chill connections don't die - they just wait
  final VibeLevel vibeLevel;

  FriendshipModel({
    required this.id,
    required this.userId,
    required this.friendId,
    this.status = FriendshipStatus.pending,
    required this.createdAt,
    this.lastVibeAt,
    this.memoriesShared = 0,
    this.vibeLevel = VibeLevel.bloom,
  });

  factory FriendshipModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return FriendshipModel(
      id: doc.id,
      userId: data['userId'] ?? '',
      friendId: data['friendId'] ?? '',
      status: FriendshipStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => FriendshipStatus.pending,
      ),
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastVibeAt: data['lastVibeAt'] != null
          ? (data['lastVibeAt'] as Timestamp).toDate()
          : null,
      // Support legacy 'vibeStreak' field for migration
      memoriesShared: data['memoriesShared'] ?? data['vibeStreak'] ?? 0,
      vibeLevel: VibeLevel.values.firstWhere(
        (e) => e.name == data['vibeLevel'] || e.name == data['health'],
        orElse: () => VibeLevel.bloom,
      ),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'userId': userId,
      'friendId': friendId,
      'status': status.name,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastVibeAt': lastVibeAt != null ? Timestamp.fromDate(lastVibeAt!) : null,
      'memoriesShared': memoriesShared,
      'vibeLevel': vibeLevel.name,
    };
  }
  /// ðŸŒ» Friendship Garden Visual State
  /// Maps raw stats to a biological metaphor
  GardenStatus get gardenStatus {
    if (memoriesShared < 10) return GardenStatus.seedling;
    if (memoriesShared < 50) return GardenStatus.budding;
    return GardenStatus.blooming;
  }
}

/// ðŸŒ» Garden Status - The visual metaphor for friendship depth
enum GardenStatus {
  /// ðŸŒ± Just planted, needs care (0-10 vibes)
  seedling,
  
  /// ðŸŒ¿ Growing strong, showing potential (10-50 vibes)
  budding,
  
  /// ðŸŒ¸ Fully in bloom, thriving connection (50+ vibes)
  blooming,
}

enum FriendshipStatus {
  pending,
  accepted,
  blocked,
}

/// âš¡ Vibe Level (Friendship History Model)
/// 
/// POSITIVE REINFORCEMENT MODEL:
/// - Levels grow with interaction
/// - Levels stay steady or go "Chill" when inactive, but NEVER disappear
/// - No anxiety, no "streak" pressure, no punishment
enum VibeLevel {
  /// ðŸŒ¸ Bloom - Active connection, exchanged vibes recently
  bloom,
  
  /// âš¡ Steady - Consistent history, building momentum
  steady,
  
  /// ðŸŒ«ï¸ Chill - Low-key, resting but NOT dead. 
  /// This is the key difference from "decay" - chill = resting, not dying
  chill,
}



========================================

FILE #5: E:\Vive\lib\core\models\user_model.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';
import '../constants/app_constants.dart';

/// User model for Vibe app
/// Contains user profile, squad membership, and widget state
class UserModel {
  final String id;
  final String phoneNumber;
  final String? email;  // For Google/Apple auth
  final String displayName;
  final String searchName;  // Lowercase displayName for case-insensitive search
  final String? username;  // Unique handle for invite links (e.g., @john_doe)
  final String? avatarUrl;
  final List<String> squadIds;
  final List<String> friendIds;
  final String? fcmToken;
  final DateTime createdAt;
  final DateTime lastActive;
  final bool isPremium;
  final WidgetState? widgetState;
  final UserStatus status;
  final String authProvider;  // 'phone', 'google', 'apple', 'guest'
  final bool isGuest;  // True if using guest mode (limited features)
  final List<String> blockedUserIds; // Safety: Blocked users will be filtered from feed

  UserModel({
    required this.id,
    required this.phoneNumber,
    this.email,
    required this.displayName,
    String? searchName,
    this.username,
    this.avatarUrl,
    this.squadIds = const [],
    this.friendIds = const [],
    this.fcmToken,
    required this.createdAt,
    required this.lastActive,
    this.isPremium = false,
    this.widgetState,
    this.status = UserStatus.offline,
    this.authProvider = 'phone',
    this.isGuest = false,
    this.blockedUserIds = const [],
  }) : searchName = searchName ?? displayName.toLowerCase();

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserModel(
      id: doc.id,
      phoneNumber: data['phoneNumber'] ?? '',
      email: data['email'],
      displayName: data['displayName'] ?? '',
      searchName: data['searchName'] ?? (data['displayName'] ?? '').toString().toLowerCase(),
      username: data['username'],  // Unique invite handle
      avatarUrl: data['avatarUrl'],
      squadIds: List<String>.from(data['squadIds'] ?? []),
      friendIds: List<String>.from(data['friendIds'] ?? []),
      fcmToken: data['fcmToken'],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      lastActive: (data['lastActive'] as Timestamp?)?.toDate() ?? DateTime.now(),
      isPremium: data['isPremium'] ?? false,
      widgetState: data['widgetState'] != null
          ? WidgetState.fromMap(data['widgetState'])
          : null,
      status: UserStatus.values.firstWhere(
        (e) => e.name == data['status'],
        orElse: () => UserStatus.offline,
      ),
      authProvider: data['authProvider'] ?? 'phone',
      isGuest: data['isGuest'] ?? false,
      blockedUserIds: List<String>.from(data['blockedUserIds'] ?? []),
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'phoneNumber': phoneNumber,
      'email': email,
      'displayName': displayName,
      'searchName': searchName,
      'username': username,
      'avatarUrl': avatarUrl,
      'squadIds': squadIds,
      'friendIds': friendIds,
      'fcmToken': fcmToken,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastActive': Timestamp.fromDate(lastActive),
      'isPremium': isPremium,
      'widgetState': widgetState?.toMap(),
      'status': status.name,
      'authProvider': authProvider,
      'isGuest': isGuest,
      'blockedUserIds': blockedUserIds,
    };
  }

  /// Check if user has premium access (either paid or within trial period)
  bool get hasPremiumAccess {
    if (isPremium) return true;
    
    // Reverse Trial: Grant premium to new users for trial period
    // uses createdAt timestamp from user registration
    final trialExpiry = createdAt.add(Duration(days: AppConstants.reverseTrialDays));
    return DateTime.now().isBefore(trialExpiry);
  }

  UserModel copyWith({
    String? id,
    String? phoneNumber,
    String? email,
    String? displayName,
    String? searchName,
    String? username,
    String? avatarUrl,
    List<String>? squadIds,
    List<String>? friendIds,
    String? fcmToken,
    DateTime? createdAt,
    DateTime? lastActive,
    bool? isPremium,
    WidgetState? widgetState,
    UserStatus? status,
    String? authProvider,
    bool? isGuest,
    List<String>? blockedUserIds,
  }) {
    return UserModel(
      id: id ?? this.id,
      phoneNumber: phoneNumber ?? this.phoneNumber,
      email: email ?? this.email,
      displayName: displayName ?? this.displayName,
      searchName: searchName ?? this.searchName,
      username: username ?? this.username,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      squadIds: squadIds ?? this.squadIds,
      friendIds: friendIds ?? this.friendIds,
      fcmToken: fcmToken ?? this.fcmToken,
      createdAt: createdAt ?? this.createdAt,
      lastActive: lastActive ?? this.lastActive,
      isPremium: isPremium ?? this.isPremium,
      widgetState: widgetState ?? this.widgetState,
      status: status ?? this.status,
      authProvider: authProvider ?? this.authProvider,
      isGuest: isGuest ?? this.isGuest,
      blockedUserIds: blockedUserIds ?? this.blockedUserIds,
    );
  }
}

/// User status states
enum UserStatus {
  online,
  offline,
  recording,
  listening,
}

/// Widget state for the home screen widget
/// Denormalized data for efficient widget reads
class WidgetState {
  final String? latestVibeId;
  final String? latestAudioUrl;
  final String? latestImageUrl;
  final String? senderName;
  final String? senderAvatar;
  final int? audioDuration;
  final List<double>? waveformData;
  final DateTime? timestamp;
  final bool isPlayed;
  
  /// ðŸ“ Transcription-First: First 50 chars of voice message
  /// Enables "glanceability" - users can read in meetings/class
  final String? transcriptionPreview;
  
  /// ðŸŽ¬ 4-State Widget Protocol: Content type flags
  /// Enables widgets to show different UI for video/audio-only/photo+audio
  final bool isVideo;       // True = Video vibe (show play overlay)
  final bool isAudioOnly;   // True = Voice note only (show mic icon)
  final String? videoUrl;   // For video deep linking

  WidgetState({
    this.latestVibeId,
    this.latestAudioUrl,
    this.latestImageUrl,
    this.senderName,
    this.senderAvatar,
    this.audioDuration,
    this.waveformData,
    this.timestamp,
    this.isPlayed = false,
    this.transcriptionPreview,
    this.isVideo = false,
    this.isAudioOnly = false,
    this.videoUrl,
  });

  factory WidgetState.fromMap(Map<String, dynamic> map) {
    return WidgetState(
      latestVibeId: map['latestVibeId'],
      latestAudioUrl: map['latestAudioUrl'],
      latestImageUrl: map['latestImageUrl'],
      senderName: map['senderName'],
      senderAvatar: map['senderAvatar'],
      audioDuration: map['audioDuration'],
      waveformData: map['waveformData'] != null
          ? List<double>.from(map['waveformData'])
          : null,
      timestamp: map['timestamp'] != null
          ? (map['timestamp'] as Timestamp).toDate()
          : null,
      isPlayed: map['isPlayed'] ?? false,
      transcriptionPreview: map['transcriptionPreview'],
      // ðŸŽ¬ 4-State Widget Protocol
      isVideo: map['isVideo'] ?? false,
      isAudioOnly: map['isAudioOnly'] ?? false,
      videoUrl: map['videoUrl'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'latestVibeId': latestVibeId,
      'latestAudioUrl': latestAudioUrl,
      'latestImageUrl': latestImageUrl,
      'senderName': senderName,
      'senderAvatar': senderAvatar,
      'audioDuration': audioDuration,
      'waveformData': waveformData,
      'timestamp': timestamp != null ? Timestamp.fromDate(timestamp!) : null,
      'isPlayed': isPlayed,
      'transcriptionPreview': transcriptionPreview,
      // ðŸŽ¬ 4-State Widget Protocol
      'isVideo': isVideo,
      'isAudioOnly': isAudioOnly,
      'videoUrl': videoUrl,
    };
  }

  WidgetState copyWith({
    String? latestVibeId,
    String? latestAudioUrl,
    String? latestImageUrl,
    String? senderName,
    String? senderAvatar,
    int? audioDuration,
    List<double>? waveformData,
    DateTime? timestamp,
    bool? isPlayed,
    String? transcriptionPreview,
    bool? isVideo,
    bool? isAudioOnly,
    String? videoUrl,
  }) {
    return WidgetState(
      latestVibeId: latestVibeId ?? this.latestVibeId,
      latestAudioUrl: latestAudioUrl ?? this.latestAudioUrl,
      latestImageUrl: latestImageUrl ?? this.latestImageUrl,
      senderName: senderName ?? this.senderName,
      senderAvatar: senderAvatar ?? this.senderAvatar,
      audioDuration: audioDuration ?? this.audioDuration,
      waveformData: waveformData ?? this.waveformData,
      timestamp: timestamp ?? this.timestamp,
      isPlayed: isPlayed ?? this.isPlayed,
      transcriptionPreview: transcriptionPreview ?? this.transcriptionPreview,
      isVideo: isVideo ?? this.isVideo,
      isAudioOnly: isAudioOnly ?? this.isAudioOnly,
      videoUrl: videoUrl ?? this.videoUrl,
    );
  }
}



========================================

FILE #6: E:\Vive\lib\core\models\vibe_model.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';

/// Vibe model - represents a voice+photo message
/// The core unit of communication in the app
class VibeModel {
  final String id;
  final String senderId;
  final String senderName;
  final String? senderAvatar;
  final String receiverId;
  final String audioUrl;
  final String? imageUrl;
  final String? videoUrl;  // For video vibes
  final bool isVideo;  // True if this is a video vibe
  final bool isAudioOnly;  // True if audio-only (uses blurred profile as background)
  final int audioDuration; // in seconds
  final List<double> waveformData;
  final DateTime createdAt;
  final bool isFromGallery;
  final DateTime? originalPhotoDate; // For "Time Travel" feature
  final bool isPlayed;
  final DateTime? playedAt;
  final String? replyVibeId; // If this is a reply to another vibe
  final List<VibeReaction> reactions;
  final String? transcription; // AI generated transcription for "Read-First"
  final String? widgetHook; // ðŸª AI-generated 3-word hook for widget engagement
  final List<TextReply> textReplies; // "Visual Whispers" text messages
  
  // GDPR Compliance: Deletion metadata
  final bool isDeleted; // True if sender deleted this vibe
  final DateTime? deletedAt; // When the vibe was deleted
  final String? deletedBy; // User ID who deleted (should be sender)

  VibeModel({
    required this.id,
    required this.senderId,
    required this.senderName,
    this.senderAvatar,
    required this.receiverId,
    required this.audioUrl,
    this.imageUrl,
    this.videoUrl,
    this.isVideo = false,
    this.isAudioOnly = false,
    required this.audioDuration,
    this.waveformData = const [],
    required this.createdAt,
    this.isFromGallery = false,
    this.originalPhotoDate,
    this.isPlayed = false,
    this.playedAt,
    this.replyVibeId,
    this.reactions = const [],
    this.transcription,
    this.widgetHook,
    this.textReplies = const [],
    this.isDeleted = false,
    this.deletedAt,
    this.deletedBy,
  });

  factory VibeModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return VibeModel(
      id: doc.id,
      senderId: data['senderId'] ?? '',
      senderName: data['senderName'] ?? '',
      senderAvatar: data['senderAvatar'],
      receiverId: data['receiverId'] ?? '',
      audioUrl: data['audioUrl'] ?? '',
      imageUrl: data['imageUrl'],
      videoUrl: data['videoUrl'],
      isVideo: data['isVideo'] ?? false,
      isAudioOnly: data['isAudioOnly'] ?? false,
      audioDuration: data['audioDuration'] ?? 0,
      waveformData: data['waveformData'] != null
          ? List<double>.from(data['waveformData'])
          : [],
      createdAt: (data['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      isFromGallery: data['isFromGallery'] ?? false,
      originalPhotoDate: data['originalPhotoDate'] != null
          ? (data['originalPhotoDate'] as Timestamp).toDate()
          : null,
      isPlayed: data['isPlayed'] ?? false,
      playedAt: data['playedAt'] != null
          ? (data['playedAt'] as Timestamp).toDate()
          : null,
      replyVibeId: data['replyVibeId'],
      reactions: data['reactions'] != null
          ? (data['reactions'] as List)
              .map((r) => VibeReaction.fromMap(r))
              .toList()
          : [],
      transcription: data['transcription'],
      widgetHook: data['widgetHook'],
      textReplies: data['textReplies'] != null
          ? (data['textReplies'] as List)
              .map((t) => TextReply.fromMap(t))
              .toList()
          : [],
      isDeleted: data['isDeleted'] ?? false,
      deletedAt: data['deletedAt'] != null
          ? (data['deletedAt'] as Timestamp).toDate()
          : null,
      deletedBy: data['deletedBy'],
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'senderId': senderId,
      'senderName': senderName,
      'senderAvatar': senderAvatar,
      'receiverId': receiverId,
      'audioUrl': audioUrl,
      'imageUrl': imageUrl,
      'videoUrl': videoUrl,
      'isVideo': isVideo,
      'isAudioOnly': isAudioOnly,
      'audioDuration': audioDuration,
      'waveformData': waveformData,
      'createdAt': Timestamp.fromDate(createdAt),
      'isFromGallery': isFromGallery,
      'originalPhotoDate': originalPhotoDate != null
          ? Timestamp.fromDate(originalPhotoDate!)
          : null,
      'isPlayed': isPlayed,
      'playedAt': playedAt != null ? Timestamp.fromDate(playedAt!) : null,
      'replyVibeId': replyVibeId,
      'reactions': reactions.map((r) => r.toMap()).toList(),
      'transcription': transcription,
      'widgetHook': widgetHook,
      'textReplies': textReplies.map((t) => t.toMap()).toList(),
      'isDeleted': isDeleted,
      'deletedAt': deletedAt != null ? Timestamp.fromDate(deletedAt!) : null,
      'deletedBy': deletedBy,
    };
  }

  VibeModel copyWith({
    String? id,
    String? senderId,
    String? senderName,
    String? senderAvatar,
    String? receiverId,
    String? audioUrl,
    String? imageUrl,
    bool? isVideo,
    bool? isAudioOnly,
    int? audioDuration,
    List<double>? waveformData,
    DateTime? createdAt,
    bool? isFromGallery,
    DateTime? originalPhotoDate,
    bool? isPlayed,
    DateTime? playedAt,
    String? replyVibeId,
    List<VibeReaction>? reactions,
    String? transcription,
    String? widgetHook,
    List<TextReply>? textReplies,
    bool? isDeleted,
    DateTime? deletedAt,
    String? deletedBy,
  }) {
    return VibeModel(
      id: id ?? this.id,
      senderId: senderId ?? this.senderId,
      senderName: senderName ?? this.senderName,
      senderAvatar: senderAvatar ?? this.senderAvatar,
      receiverId: receiverId ?? this.receiverId,
      audioUrl: audioUrl ?? this.audioUrl,
      imageUrl: imageUrl ?? this.imageUrl,
      isVideo: isVideo ?? this.isVideo,
      isAudioOnly: isAudioOnly ?? this.isAudioOnly,
      audioDuration: audioDuration ?? this.audioDuration,
      waveformData: waveformData ?? this.waveformData,
      createdAt: createdAt ?? this.createdAt,
      isFromGallery: isFromGallery ?? this.isFromGallery,
      originalPhotoDate: originalPhotoDate ?? this.originalPhotoDate,
      isPlayed: isPlayed ?? this.isPlayed,
      playedAt: playedAt ?? this.playedAt,
      replyVibeId: replyVibeId ?? this.replyVibeId,
      reactions: reactions ?? this.reactions,
      transcription: transcription ?? this.transcription,
      widgetHook: widgetHook ?? this.widgetHook,
      textReplies: textReplies ?? this.textReplies,
      isDeleted: isDeleted ?? this.isDeleted,
      deletedAt: deletedAt ?? this.deletedAt,
      deletedBy: deletedBy ?? this.deletedBy,
    );
  }

  /// Check if this is a "Time Travel" upload (from gallery)
  /// Only true if the photo is older than 24 hours - prevents tagging
  /// recently taken photos as "nostalgia" content
  /// 
  /// FIX: Uses createdAt (upload time) instead of DateTime.now() for deterministic logic
  bool get isTimeTravel {
    if (!isFromGallery || originalPhotoDate == null) return false;
    
    // Photo must be at least 24 hours old AT UPLOAD TIME to be "Time Travel"
    // This is immutable - doesn't change as time passes
    final photoAge = createdAt.difference(originalPhotoDate!);
    return photoAge > const Duration(hours: 24);
  }

  /// Get the retro tag string (e.g., "OCT 24")
  String? get retroTag {
    if (!isTimeTravel || originalPhotoDate == null) return null;
    final months = [
      'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'
    ];
    return 'RETRO ${months[originalPhotoDate!.month - 1]} \'${originalPhotoDate!.year.toString().substring(2)}';
  }

  /// ðŸ•°ï¸ Gradient Decay Indicator (Time Travel)
  /// Provides nuanced temporal context: "LIVE", "TODAY", or "RETRO [MONTH] [YEAR]"
  String get temporalTag {
    final now = DateTime.now();
    final age = now.difference(createdAt);
    
    if (age.inMinutes < 15) return 'LIVE';
    if (age.inHours < 24) return 'TODAY';
    
    if (isTimeTravel && originalPhotoDate != null) {
      final months = [
        'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
        'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'
      ];
      final monthStr = months[originalPhotoDate!.month - 1];
      final yearStr = originalPhotoDate!.year.toString().substring(2);
      return 'RETRO $monthStr \'$yearStr';
    }
    
    return 'PAST';
  }
}

/// Reaction to a vibe
class VibeReaction {
  final String userId;
  final String emoji;
  final DateTime createdAt;

  VibeReaction({
    required this.userId,
    required this.emoji,
    required this.createdAt,
  });

  factory VibeReaction.fromMap(Map<String, dynamic> map) {
    return VibeReaction(
      userId: map['userId'] ?? '',
      emoji: map['emoji'] ?? 'â¤ï¸',
      createdAt: map['createdAt'] != null
          ? (map['createdAt'] as Timestamp).toDate()
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'userId': userId,
      'emoji': emoji,
      'createdAt': Timestamp.fromDate(createdAt),
    };
  }
}

/// Text reply (Visual Whispers)
class TextReply {
  final String senderId;
  final String senderName;
  final String text;
  final DateTime createdAt;

  TextReply({
    required this.senderId,
    required this.senderName,
    required this.text,
    required this.createdAt,
  });

  factory TextReply.fromMap(Map<String, dynamic> map) {
    return TextReply(
      senderId: map['senderId'] ?? '',
      senderName: map['senderName'] ?? '',
      text: map['text'] ?? '',
      createdAt: map['createdAt'] != null
          ? (map['createdAt'] as Timestamp).toDate()
          : DateTime.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'senderId': senderId,
      'senderName': senderName,
      'text': text,
      'createdAt': Timestamp.fromDate(createdAt),
    };
  }
}



========================================

FILE #7: E:\Vive\lib\core\providers\deep_link_provider.dart

========================================


import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Deep Link Context Provider
/// 
/// Preserves deep link data (like invite codes) across the auth flow.
/// When a user clicks an invite link but isn't logged in, the inviterId
/// is stored here and retrieved after authentication completes.

const String _pendingInviteKey = 'pending_invite_id';

/// Provider to track pending invite from deep link
final pendingInviteProvider = StateNotifierProvider<PendingInviteNotifier, String?>((ref) {
  return PendingInviteNotifier();
});

/// Optimized for Router: Returns null if invite is dismissed for this session
final activeInviteProvider = Provider<String?>((ref) {
  return ref.watch(pendingInviteProvider.notifier).pendingInviteId;
});

class PendingInviteNotifier extends StateNotifier<String?> {
  String? _dismissedId;

  PendingInviteNotifier() : super(null) {
    _loadPendingInvite();
  }

  /// Load any pending invite from persistent storage
  Future<void> _loadPendingInvite() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final inviterId = prefs.getString(_pendingInviteKey);
      if (inviterId != null && inviterId.isNotEmpty) {
        state = inviterId;
      }
    } catch (e) {
      // Ignore errors loading pending invite
    }
  }

  /// Store an invite ID to be processed after authentication
  Future<void> setPendingInvite(String inviterId) async {
    // If it's a new ID, reset dismissal
    if (inviterId != _dismissedId) {
      _dismissedId = null;
    }
    state = inviterId;
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_pendingInviteKey, inviterId);
    } catch (e) {
      // Store failed, but we have it in memory
    }
  }

  /// Dismiss the current invite from showing automatically in this session.
  /// This prevents the "Magnetic Redirect" in the router while preserving
  /// the invite ID in storage for later retrieval (if needed).
  void dismiss() {
    _dismissedId = state;
    // We trigger a state update to force router re-evaluation
    final current = state;
    state = null; // Set to null so router stops redirecting
    state = current; // Set back so listeners still see it if they need to
  }

  /// Clear the pending invite after it's been processed
  Future<void> clearPendingInvite() async {
    state = null;
    _dismissedId = null;
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_pendingInviteKey);
    } catch (e) {
      // Ignore
    }
  }

  /// Get the pending invite ID (if any and not dismissed)
  String? get pendingInviteId {
    if (state == _dismissedId) return null;
    return state;
  }
}



========================================

FILE #8: E:\Vive\lib\core\providers\friends_provider.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:rxdart/rxdart.dart';
import '../models/user_model.dart';
import '../services/auth_service.dart';
import '../constants/app_constants.dart';

/// Global friends list provider
/// 
/// Merges Firestore chunks to stay within the 'whereIn' limit of 10.
final friendsProvider = StreamProvider<List<UserModel>>((ref) {
  final userAsync = ref.watch(currentUserProvider);
  
  return userAsync.when(
    data: (user) {
      if (user == null || user.friendIds.isEmpty) {
        return Stream.value([]);
      }
      
      final friendIds = user.friendIds;
      
      // Split into chunks of 10 for Firestore 'whereIn' limit
      final chunks = <List<String>>[];
      for (var i = 0; i < friendIds.length; i += 10) {
        chunks.add(friendIds.sublist(
          i, 
          i + 10 > friendIds.length ? friendIds.length : i + 10,
        ));
      }
      
      final streams = chunks.map((chunk) {
        return FirebaseFirestore.instance
            .collection(AppConstants.usersCollection)
            .where(FieldPath.documentId, whereIn: chunk)
            .snapshots()
            .map((snapshot) =>
                snapshot.docs.map((doc) => UserModel.fromFirestore(doc)).toList());
      }).toList();
      
      if (streams.isEmpty) return Stream.value([]);
      if (streams.length == 1) return streams.first;
      
      return CombineLatestStream.list(streams)
          .map((listOfLists) => listOfLists.expand((batch) => batch).toList())
          .startWith([]);
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
});



========================================

FILE #9: E:\Vive\lib\core\providers\onboarding_provider.dart

========================================


import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider for onboarding state
final onboardingStateProvider = StateNotifierProvider<OnboardingStateNotifier, AsyncValue<bool>>((ref) {
  return OnboardingStateNotifier();
});

class OnboardingStateNotifier extends StateNotifier<AsyncValue<bool>> {
  OnboardingStateNotifier() : super(const AsyncValue.loading()) {
    _loadState();
  }

  static const String _onboardingCompletedKey = 'onboarding_completed';

  Future<void> _loadState() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final completed = prefs.getBool(_onboardingCompletedKey) ?? false;
      state = AsyncValue.data(completed);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> completeOnboarding() async {
    state = const AsyncValue.loading();
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(_onboardingCompletedKey, true);
      state = const AsyncValue.data(true);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
  
  Future<void> resetOnboarding() async {
    state = const AsyncValue.loading();
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_onboardingCompletedKey);
      state = const AsyncValue.data(false);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
}



========================================

FILE #10: E:\Vive\lib\core\providers\vibe_upload_provider.dart

========================================


import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:collection/collection.dart';
import 'package:uuid/uuid.dart';
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../services/vibe_service.dart';
import '../models/vibe_model.dart';
import '../../features/camera/domain/services/video_processing_service.dart';
import 'package:path/path.dart' as p;

enum VibeUploadStatus { processing, uploading, success, error }

/// Represents a background upload task (session-only)
class VibeUploadTask {
  final String id;
  final String receiverId;
  final String? audioPath;
  final String? imagePath;
  final String? videoPath;
  final String? overlayPath;
  final int audioDuration;
  final List<double> waveformData;
  final bool isVideo;
  final bool isAudioOnly;
  final bool isFromGallery;
  final DateTime? originalPhotoDate;
  final String? replyToVibeId;
  final VibeUploadStatus status;
  final String? error;
  final DateTime createdAt;

  VibeUploadTask({
    required this.id,
    required this.receiverId,
    this.audioPath,
    this.imagePath,
    this.videoPath,
    this.overlayPath,
    required this.audioDuration,
    required this.waveformData,
    this.isVideo = false,
    this.isAudioOnly = false,
    this.isFromGallery = false,
    this.originalPhotoDate,
    this.replyToVibeId,
    this.status = VibeUploadStatus.processing,
    this.error,
    required this.createdAt,
  });

  VibeUploadTask copyWith({
    VibeUploadStatus? status,
    String? error,
    String? videoPath,
    String? imagePath,
    String? overlayPath,
  }) {
    return VibeUploadTask(
      id: id,
      receiverId: receiverId,
      audioPath: audioPath,
      imagePath: imagePath ?? this.imagePath,
      videoPath: videoPath ?? this.videoPath,
      overlayPath: overlayPath ?? this.overlayPath,
      audioDuration: audioDuration,
      waveformData: waveformData,
      isVideo: isVideo,
      isAudioOnly: isAudioOnly,
      isFromGallery: isFromGallery,
      originalPhotoDate: originalPhotoDate,
      replyToVibeId: replyToVibeId,
      status: status ?? this.status,
      error: error ?? this.error,
      createdAt: createdAt,
    );
  }
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'receiverId': receiverId,
      'audioPath': audioPath,
      'imagePath': imagePath,
      'videoPath': videoPath,
      'overlayPath': overlayPath,
      'audioDuration': audioDuration,
      // Store waveform as list of doubles
      'waveformData': waveformData,
      'isVideo': isVideo,
      'isAudioOnly': isAudioOnly,
      'isFromGallery': isFromGallery,
      'originalPhotoDate': originalPhotoDate?.millisecondsSinceEpoch,
      'replyToVibeId': replyToVibeId,
      'status': status.index, // Store enum as int index
      'error': error,
      'createdAt': createdAt.millisecondsSinceEpoch,
    };
  }

  factory VibeUploadTask.fromMap(Map<String, dynamic> map) {
    return VibeUploadTask(
      id: map['id'],
      receiverId: map['receiverId'],
      audioPath: map['audioPath'],
      imagePath: map['imagePath'],
      videoPath: map['videoPath'],
      overlayPath: map['overlayPath'],
      audioDuration: map['audioDuration'],
      waveformData: List<double>.from(map['waveformData'] ?? []),
      isVideo: map['isVideo'] ?? false,
      isAudioOnly: map['isAudioOnly'] ?? false,
      isFromGallery: map['isFromGallery'] ?? false,
      originalPhotoDate: map['originalPhotoDate'] != null 
          ? DateTime.fromMillisecondsSinceEpoch(map['originalPhotoDate']) 
          : null,
      replyToVibeId: map['replyToVibeId'],
      status: VibeUploadStatus.values[map['status'] ?? 0],
      error: map['error'],
      createdAt: DateTime.fromMillisecondsSinceEpoch(map['createdAt']),
    );
  }
}

/// Provider for managing background vibe uploads
final vibeUploadProvider = StateNotifierProvider<VibeUploadNotifier, List<VibeUploadTask>>((ref) {
  final vibeService = ref.watch(vibeServiceProvider);
  return VibeUploadNotifier(ref, vibeService);
});

class VibeUploadNotifier extends StateNotifier<List<VibeUploadTask>> {
  final Ref _ref;
  final VibeService _vibeService;
  final Set<String> _activeTasks = {};
  static const String _storageKey = 'vibe_upload_queue';
  
  VibeUploadNotifier(this._ref, this._vibeService) : super([]) {
    _loadQueue(); // Load saved tasks on startup
  }

  // ðŸ’¾ PERSISTENCE: Save/Load Queue
  Future<void> _loadQueue() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString(_storageKey);
      if (jsonString != null) {
        final List<dynamic> jsonList = jsonDecode(jsonString);
        final restoredTasks = jsonList.map((j) => VibeUploadTask.fromMap(j)).toList();
        state = restoredTasks;
        
        // Auto-retry pending tasks or mark stale processing as error
        for (final task in restoredTasks) {
          if (task.status == VibeUploadStatus.uploading || task.status == VibeUploadStatus.processing) {
             // Retry!
             _startUpload(task);
          }
        }
      }
    } catch (e) {
      debugPrint('âš ï¸ [VibeUpload] Failed to load queue: $e');
    }
  }

  Future<void> _saveQueue() async {
    try {
       // Filter out successes to clean up history, keep active/errors
       final tasksToSave = state.where((t) => t.status != VibeUploadStatus.success).toList();
       final prefs = await SharedPreferences.getInstance();
       final jsonString = jsonEncode(tasksToSave.map((t) => t.toMap()).toList());
       await prefs.setString(_storageKey, jsonString);
    } catch (e) {
      debugPrint('âš ï¸ [VibeUpload] Failed to save queue: $e');
    }
  }

  /// Add a new upload task to the queue
  Future<void> addUpload({
    required String receiverId,
    String? audioPath,
    String? imagePath,
    String? videoPath,
    String? overlayPath,
    required int audioDuration,
    required List<double> waveformData,
    bool isVideo = false,
    bool isAudioOnly = false,
    bool isFromGallery = false,
    DateTime? originalPhotoDate,
    String? replyToVibeId,
  }) async {
    debugPrint('ðŸš€ [VibeUpload] addUpload called: isVideo=$isVideo');
    
    final task = VibeUploadTask(
      id: const Uuid().v4(),
      receiverId: receiverId,
      audioPath: audioPath,
      imagePath: imagePath,
      videoPath: videoPath,
      overlayPath: overlayPath,
      audioDuration: audioDuration,
      waveformData: waveformData,
      isVideo: isVideo,
      isAudioOnly: isAudioOnly,
      isFromGallery: isFromGallery,
      originalPhotoDate: originalPhotoDate,
      replyToVibeId: replyToVibeId,
      status: VibeUploadStatus.processing,
      createdAt: DateTime.now(),
    );

    state = [...state, task];
    _saveQueue(); // Save immediately
    _startUpload(task);
  }

  Future<void> _startUpload(VibeUploadTask task) async {
    if (_activeTasks.contains(task.id)) return;
    _activeTasks.add(task.id);

    // 1. Check if we need video processing
    if (task.isVideo && task.videoPath != null && task.overlayPath != null) {
      updateTaskStatus(task.id, VibeUploadStatus.processing);
      
      final rawVideoPath = task.videoPath!;
      final overlayFile = File(task.overlayPath!);
      
      // ASYNC FIX: Use .exists() instead of .existsSync()
      if (!await File(rawVideoPath).exists() || !await overlayFile.exists()) {
        debugPrint('âŒ [VibeUpload] Video or overlay file missing for task ${task.id}');
        _activeTasks.remove(task.id);
        updateTaskStatus(task.id, VibeUploadStatus.error, error: 'Files missing');
        return;
      }

      final targetSize = const Size(720, 720);

      VideoProcessingService.processAndUpload(
        videoPath: rawVideoPath,
        overlayImage: overlayFile,
        targetSize: targetSize,
        onProcessed: (processedFile) async {
          debugPrint('ðŸŽ¬ [VibeUpload] Video processing complete for task ${task.id}');
          
          File? thumbFile = await VideoProcessingService.extractVideoThumbnail(processedFile.path);
          
          final updatedTask = task.copyWith(
            status: VibeUploadStatus.uploading,
            videoPath: processedFile.path,
            imagePath: thumbFile?.path,
          );
          
          state = [
            for (final t in state)
              if (t.id == task.id) updatedTask else t
          ];
          
          _performFinalSend(updatedTask);
        },
        onError: (err) {
          debugPrint('âŒ [VibeUpload] Video processing error for task ${task.id}: $err');
          _activeTasks.remove(task.id);
          updateTaskStatus(task.id, VibeUploadStatus.error, error: err);
        },
      );
      return;
    }

    _performFinalSend(task);
  }

  Future<void> _performFinalSend(VibeUploadTask task) async {
    updateTaskStatus(task.id, VibeUploadStatus.uploading);

    // ASYNC FIX: Use .exists() instead of .existsSync()
    if (task.audioPath != null) {
      final file = File(task.audioPath!);
      final exists = await file.exists();
      final size = exists ? await file.length() : 0;
      debugPrint('ðŸ” [VibeUpload] Audio validation: exists=$exists, size=$size bytes, path=${task.audioPath}');
      if (!exists || size == 0) {
        _activeTasks.remove(task.id);
        updateTaskStatus(task.id, VibeUploadStatus.error, error: size == 0 ? 'Audio file empty' : 'Audio file missing');
        return;
      }
    }
    
    if (task.imagePath != null) {
       final file = File(task.imagePath!);
       final exists = await file.exists();
       final size = exists ? await file.length() : 0;
       debugPrint('ðŸ” [VibeUpload] Image validation: exists=$exists, size=$size bytes, path=${task.imagePath}');
    }

    try {
      debugPrint('ðŸš€ [VibeUpload] Handoff to VibeService for task ${task.id} (audioOnly=${task.isAudioOnly})');
      
      final vibe = await _vibeService.sendVibe(
        receiverId: task.receiverId,
        audioFile: task.audioPath != null ? File(task.audioPath!) : null,
        audioDuration: task.audioDuration,
        waveformData: task.waveformData,
        imageFile: task.imagePath != null ? File(task.imagePath!) : null,
        videoFile: task.videoPath != null ? File(task.videoPath!) : null,
        isVideo: task.isVideo,
        isAudioOnly: task.isAudioOnly,
        isFromGallery: task.isFromGallery,
        originalPhotoDate: task.originalPhotoDate,
        replyToVibeId: task.replyToVibeId,
      );

      if (vibe != null) {
        debugPrint('âœ… [VibeUpload] Final send success for task ${task.id}');
        // ðŸ”„ REFRESH FIX: Invalidate dashboard providers so newly sent vibes appear
        _ref.invalidate(paginatedVibesProvider(true)); // Refresh Sent history
        _ref.invalidate(paginatedVibesProvider(false)); // Refresh Received (rarely needed but safe)
        
        updateTaskStatus(task.id, VibeUploadStatus.success);
        
        // ðŸ COMPLETION FEEDBACK: Delay removal so UI can show "Sent!"
        Future.delayed(const Duration(seconds: 3), () => _removeTask(task.id));
      } else {
        updateTaskStatus(task.id, VibeUploadStatus.error, error: 'Upload failed');
        // Delay removal for error visibility too
        Future.delayed(const Duration(seconds: 5), () => _removeTask(task.id));
      }
    } catch (e) {
      debugPrint('âŒ [VibeUpload] Final send error for task ${task.id}: $e');
      updateTaskStatus(task.id, VibeUploadStatus.error, error: e.toString());
      // Delay removal for error visibility
      Future.delayed(const Duration(seconds: 5), () => _removeTask(task.id));
    }
  }

  void updateTaskStatus(String id, VibeUploadStatus status, {String? error}) {
    state = [
      for (final t in state)
        if (t.id == id) t.copyWith(status: status, error: error) else t
    ];
    _saveQueue();
  }

  void _removeTask(String id) {
    _activeTasks.remove(id);
    
    final task = state.firstWhereOrNull((t) => t.id == id);
    if (task != null) {
      _cleanupFiles(task);
    }

    state = state.where((t) => t.id != id).toList();
    _saveQueue();
  }

  void _cleanupFiles(VibeUploadTask task) {
    // Delay cleanup slightly to ensure upload complete
    Future.delayed(const Duration(seconds: 2), () {
      if (task.videoPath != null) _deleteFile(task.videoPath!);
      if (task.imagePath != null) _deleteFile(task.imagePath!);
      if (task.overlayPath != null) _deleteFile(task.overlayPath!);
      if (task.audioPath != null) _deleteFile(task.audioPath!);
    });
  }

  Future<void> _deleteFile(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        await file.delete();
        debugPrint('ðŸ—‘ï¸ [VibeUpload] Deleted temp file: $path');
      }
    } catch (e) {
      debugPrint('âš ï¸ [VibeUpload] Could not delete $path: $e');
    }
  }
}



========================================

FILE #11: E:\Vive\lib\core\providers\widget_launch_provider.dart

========================================


import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:home_widget/home_widget.dart';
import 'package:flutter/foundation.dart';

final widgetLaunchProvider = FutureProvider<Uri?>((ref) async {
  try {
    return await HomeWidget.initiallyLaunchedFromHomeWidget();
  } catch (e) {
    debugPrint('Error checking widget launch: $e');
    return null;
  }
});



========================================

FILE #12: E:\Vive\lib\core\router\app_router.dart

========================================


import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/models/vibe_model.dart';
import 'package:nock/features/onboarding/presentation/onboarding_screen.dart';
import 'package:nock/features/onboarding/presentation/permission_screens.dart';
import 'package:nock/features/onboarding/presentation/widget_setup_screen.dart';
import 'package:nock/features/auth/presentation/welcome_screen.dart';
import 'package:nock/features/home/presentation/home_screen.dart';
import 'package:nock/features/home/presentation/home_screen.dart';
import 'package:nock/features/camera/presentation/camera_screen_new.dart';
import 'package:nock/features/camera/presentation/preview_screen.dart';
import 'package:nock/features/subscription/presentation/subscription_screen.dart';
import 'package:nock/features/invite/presentation/invite_acceptance_screen.dart';
import 'package:nock/features/squad/presentation/squad_screen.dart';
import 'package:nock/features/squad/presentation/add_friends_screen.dart';
import 'package:nock/features/player/presentation/player_screen.dart';
import 'package:nock/core/providers/onboarding_provider.dart';
import 'package:nock/core/providers/deep_link_provider.dart';
import 'package:nock/core/providers/widget_launch_provider.dart';
import 'package:nock/features/widget/presentation/bff_config_screen.dart';
import 'package:nock/features/auth/presentation/not_found_screen.dart';
// SplashScreen is exported by onboarding_screen.dart

/// Provider for tracking if widget launch has been handled
final _widgetLaunchHandledProvider = StateProvider<bool>((ref) => false);

/// App Router Provider
final routerProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authStateProvider);
  final onboardingState = ref.watch(onboardingStateProvider);
  // CRITICAL FIX: Watch the ACTIVE invite (respects session dismissal)
  final activeInviteId = ref.watch(activeInviteProvider);
  final pendingInviteNotifier = ref.read(pendingInviteProvider.notifier);
  final widgetLaunch = ref.watch(widgetLaunchProvider);
  
  return GoRouter(
    initialLocation: AppRoutes.splash,
    debugLogDiagnostics: true,
    redirect: (context, state) async {
      debugPrint('ðŸ”€ Router: redirect called for ${state.matchedLocation}');
      
      final isLoading = authState.isLoading || onboardingState.isLoading;
      debugPrint('ðŸ”€ Router: isLoading=$isLoading (auth=${authState.isLoading}, onboarding=${onboardingState.isLoading})');
      
      if (isLoading) {
        debugPrint('ðŸ”€ Router: Still loading, staying on current route');
        return null; // Stay on current route (usually splash)
      }

      final isLoggedIn = authState.valueOrNull != null;
      final onboardingCompleted = onboardingState.valueOrNull ?? false;
      
      debugPrint('ðŸ”€ Router: isLoggedIn=$isLoggedIn, onboardingCompleted=$onboardingCompleted');
      
      final isSplash = state.matchedLocation == AppRoutes.splash;
      final isWelcome = state.matchedLocation == '/welcome';
      final isAuthRoute = state.matchedLocation == AppRoutes.phoneAuth ||
          state.matchedLocation == AppRoutes.verifyOtp ||
          isWelcome;
      final isOnboardingRoute = state.matchedLocation == AppRoutes.onboarding ||
          // 2025 FIX: Permission routes removed from safe list.
          // Force users to finish intro before accessing permissions.
          // state.matchedLocation.startsWith('/permission') ||
          state.matchedLocation == AppRoutes.widgetSetup;
      
      final isInviteRoute = state.matchedLocation.startsWith('/home/invite/') || 
          state.matchedLocation.startsWith('/home/i/') ||
          state.matchedLocation.startsWith('/invite/') ||
          state.matchedLocation.startsWith('/i/');
      
      // DEEP LINK FIX: Android parses nock://invite/userid as path=/invite/userid
      // But sometimes it might come as just /userid - handle both cases
      // If the path looks like an unknown route (not matching any known routes),
      // and it could be an invite ID, redirect to proper invite route
      final matchedPath = state.matchedLocation;
      final isKnownRoute = matchedPath == '/' ||
          matchedPath == '/home' ||
          matchedPath == '/welcome' ||
          matchedPath == '/onboarding' ||
          matchedPath.startsWith('/permission') ||
          matchedPath == '/widget-setup' ||
          matchedPath == '/phone-auth' ||
          matchedPath == '/verify-otp' ||
          matchedPath == '/camera' ||
          matchedPath == '/preview' ||
          matchedPath == '/vault' ||
          matchedPath == '/squad' ||
          matchedPath == '/add-friends' ||
          matchedPath.startsWith('/home/player/') ||
          matchedPath.startsWith('/invite/') ||
          matchedPath.startsWith('/record/') ||
          matchedPath == AppRoutes.splash;
      
      
      // Unknown route check REMOVED
      // We no longer "guess" IDs from unknown paths to prevent hijacking
      // valid feature routes (like /settings_page).
      // Short-links should now use the explicit /i/ prefix.

      if (!isLoggedIn) {
        debugPrint('ðŸ”€ Router: User NOT logged in');
        
        // Handle Deep Link Invite for unauth user - SAVE IT for later
        if (isInviteRoute) {
          final uri = state.uri;
          if (uri.pathSegments.length > 1) {
            // Check if it's /invite/ID or /i/ID
            if (uri.pathSegments[0] == 'invite' || uri.pathSegments[0] == 'i') {
              final inviteId = uri.pathSegments[1];
              await pendingInviteNotifier.setPendingInvite(inviteId);
            }
          }
          debugPrint('ðŸ”€ Router: Invite route -> /welcome');
          return '/welcome';
        }

        // Allow auth/welcome routes
        if (isAuthRoute) {
          debugPrint('ðŸ”€ Router: Already on auth route, staying');
          return null;
        }
        
        // If onboarding not done, go to onboarding
        if (!onboardingCompleted) {
          if (isOnboardingRoute || isSplash) {
            debugPrint('ðŸ”€ Router: On onboarding/splash, staying');
            return null;  // Allow staying on onboarding screens
          }
          debugPrint('ðŸ”€ Router: Onboarding not complete -> /onboarding');
          return AppRoutes.onboarding;
        }
        
        // Onboarding done but not logged in -> go to welcome/auth
        debugPrint('ðŸ”€ Router: Onboarding done, not authed -> /welcome');
        return '/welcome';
      }
      // 2. User is logged in - handle onboarding and auth routes
      // NOTE: We get here only if isLoggedIn=true (passed the !isLoggedIn block above)
      
      debugPrint('ðŸ”€ Router: User IS logged in');
      
      // If logged in and onboarding not done, let them finish onboarding
      if (!onboardingCompleted) {
        debugPrint('ðŸ”€ Router: Logged in but onboarding not complete');
        
        // If they're on an auth route (welcome, phone), redirect to onboarding or home
        if (isAuthRoute) {
          debugPrint('ðŸ”€ Router: On auth route while logged in -> /onboarding');
          return AppRoutes.onboarding;  // Continue onboarding
        }
        
        // Allow onboarding routes
        if (isOnboardingRoute || isSplash) {
          debugPrint('ðŸ”€ Router: On onboarding/splash route, staying');
          return null;
        }
        
        // Trying to go to home or other protected route before onboarding complete
        debugPrint('ðŸ”€ Router: Logged in, onboarding not complete -> /onboarding');
        return AppRoutes.onboarding;
      }
      
      // 3. User is logged in AND onboarding complete - redirect away from auth/onboarding routes
      if (isAuthRoute || isOnboardingRoute || isSplash) {
        debugPrint('ðŸ”€ Router: Logged in + onboarded, on auth/onboarding route -> /home');
        return AppRoutes.home;
      }

      // 4. TRANSFORMATION: Redirect top-level Deep Link aliases to nested routes
      // This ensures we maintain the correct navigation stack [Home -> Feature]
      if (state.matchedLocation.startsWith('/invite/')) {
        final userId = state.pathParameters['userId'];
        return '/home/invite/$userId';
      }
      if (state.matchedLocation.startsWith('/i/')) {
        final userId = state.pathParameters['userId'];
        return '/home/i/$userId';
      }
      if (state.matchedLocation.startsWith('/player/')) {
        final vibeId = state.pathParameters['vibeId'];
        return '/home/player/$vibeId';
      }
      if (state.matchedLocation.startsWith('/p/')) {
        final vibeId = state.pathParameters['vibeId'];
        return '/home/player/$vibeId';
      }
      if (state.matchedLocation.startsWith('/record/')) {
        final friendId = state.pathParameters['friendId'];
        return '/home/record/$friendId';
      }
      if (state.matchedLocation.startsWith('/r/')) {
        final friendId = state.pathParameters['friendId'];
        return '/home/record/$friendId';
      }

      // 4. CRITICAL FIX: Check for Pending Invite BEFORE going home
      // This completes the viral loop - users who clicked invite links
      // will now be redirected to accept the invite after logging in
      // 2025 FIX: Check if we are already on the invite route to prevent loop
      final activeInviteId = ref.read(activeInviteProvider);
      if (activeInviteId != null && !isInviteRoute) {
        final target = '/home/invite/$activeInviteId';
        
        // CRITICAL GUARD: If we are already within the invite sub-tree, do NOT redirect.
        if (state.matchedLocation.startsWith('/home/invite/')) {
          debugPrint('ðŸ”€ Router: Already in invite flow, stopping redirect');
          return null;
        }
        
        debugPrint('ðŸ”€ Router: Redirecting to invite acceptance for $activeInviteId');
        return target;
      }

      // 5. Handle Widget Cold Start
      final rHandler = ref.read(_widgetLaunchHandledProvider.notifier);
      final isHandled = ref.read(_widgetLaunchHandledProvider);
      final launchUri = widgetLaunch.valueOrNull;
      
      if (!isHandled && launchUri != null) {
        rHandler.state = true;
        // Extract vibe ID from widget launch URI if present
        final vibeId = launchUri.queryParameters['vibeId'];
        if (vibeId != null && vibeId.isNotEmpty) {
          // INSTANT REPLY: Mark as from notification for reply focus
          debugPrint('ðŸ”€ Router: Widget launch -> player/$vibeId (fromNotification)');
          return '/home/player/$vibeId?fromNotification=true';
        }
      }
      
      // 5.5 CRITICAL FIX: Handle "naked" IDs from old nock://player/ID or nock://invite/ID links
      // When scheme host is present but not handled by Uri components, GoRouter sees just /ID
      if (!isKnownRoute && state.uri.pathSegments.length == 1) {
        final possibleId = state.uri.pathSegments.first;
        // UUID Pattern check (36 chars with hyphens)
        final uuidRegex = RegExp(r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$', caseSensitive: false);
        
        if (uuidRegex.hasMatch(possibleId)) {
           debugPrint('ðŸ”€ Router: Naked UUID detected ($possibleId), attempting player redirect');
           // Default to player if naked ID found
           return '/home/player/$possibleId';
        }
      }
      
      
      // 6. Default: Redirect from auth/splash routes to Home
      if (isAuthRoute || isSplash || isOnboardingRoute) {
        debugPrint('ðŸ”€ Router: Redirecting from $state.matchedLocation to ${AppRoutes.home}');
        return AppRoutes.home;
      }

      debugPrint('ðŸ”€ Router: No redirect needed, staying at ${state.matchedLocation}');
      return null;
    },
    routes: [
      // Splash
      GoRoute(
        path: AppRoutes.splash,
        builder: (context, state) => const SplashScreen(),
      ),

      // Onboarding
      GoRoute(
        path: AppRoutes.onboarding,
        builder: (context, state) => const OnboardingScreen(),
      ),
      
      // Welcome screen (multi-auth: Google, Apple, Phone, Guest)
      GoRoute(
        path: '/welcome',
        builder: (context, state) => const WelcomeScreen(),
      ),

      // Permission screens
      GoRoute(
        path: AppRoutes.permissionMic,
        builder: (context, state) => const MicrophonePermissionScreen(),
      ),
      GoRoute(
        path: AppRoutes.permissionNotification,
        builder: (context, state) => const NotificationPermissionScreen(),
      ),
      GoRoute(
        path: AppRoutes.permissionCamera,
        builder: (context, state) => const CameraPermissionScreen(),
      ),
      GoRoute(
        path: AppRoutes.permissionContacts,
        builder: (context, state) => const ContactsPermissionScreen(),
      ),
      GoRoute(
        path: AppRoutes.widgetSetup,
        builder: (context, state) => const WidgetSetupScreen(),
      ),

      // Main screens
      GoRoute(
        path: AppRoutes.home,
        builder: (context, state) => const HomeScreen(),
        routes: [
          // NESTED ROUTES: Synthesize stack [Home -> Feature]
          // This ensures the back button works for deep links!
          
          // Player - nested under /home
          GoRoute(
            path: 'player/:vibeId',
            builder: (context, state) {
              final extra = state.extra;
              VibeModel? vibe;
              List<VibeModel>? vibesList;
              int? startIndex;
              
              if (extra is VibeModel) {
                vibe = extra;
              } else if (extra is Map<String, dynamic>) {
                vibe = extra['vibe'] as VibeModel?;
                vibesList = extra['vibesList'] as List<VibeModel>?;
                startIndex = extra['startIndex'] as int?;
              }
              
              final fromNotification = state.uri.queryParameters['fromNotification'] == 'true';
              
              return PlayerScreen(
                vibe: vibe,
                vibeId: state.pathParameters['vibeId'],
                fromNotification: fromNotification,
                vibesList: vibesList,
                startIndex: startIndex,
              );
            },
          ),

          // Invite Acceptance - nested under /home
          GoRoute(
            path: 'invite/:userId',
            builder: (context, state) {
              final userId = state.pathParameters['userId'];
              return InviteAcceptanceScreen(inviterId: userId ?? '');
            },
          ),
          
          // Short Invite Alias
          GoRoute(
            path: 'i/:userId',
            builder: (context, state) {
              final userId = state.pathParameters['userId'];
              return InviteAcceptanceScreen(inviterId: userId ?? '');
            },
          ),

          GoRoute(
            path: 'squad',
            builder: (context, state) => const SquadScreen(),
          ),
          GoRoute(
            path: 'add-friends',
            builder: (context, state) => const AddFriendsScreen(),
          ),
          GoRoute(
            path: 'subscription',
            builder: (context, state) => const SubscriptionScreen(),
          ),
          
          // Record - nested under /home
          GoRoute(
            path: 'record/:friendId',
            builder: (context, state) {
              final friendId = state.pathParameters['friendId'];
              return CameraScreenNew(
                isAudioOnly: true,
                recipientId: friendId,
              );
            },
          ),
        ],
      ),
      
      // TOP-LEVEL ALIASES for Deep Links (API 34/Android 14 compatibility)
      // These routes prevent the "Janky" errorBuilder fallback.
      // The top-level redirect: logic will transform these into /home/... nested routes
      // to ensure a correct navigation stack remains.
      GoRoute(
        path: '/invite/:userId',
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),
      GoRoute(
        path: '/i/:userId',
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),
      GoRoute(
        path: '/player/:vibeId',
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),
      GoRoute(
        path: '/p/:vibeId', // Short alias for player
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),

      // Preview screen for sending vibes
      GoRoute(
        path: '/preview',
        builder: (context, state) {
          final extra = state.extra as Map<String, dynamic>?;
          return PreviewScreen(
            imagePath: extra?['imagePath'] ?? '',
            audioPath: extra?['audioPath'] ?? '',
            videoPath: extra?['videoPath'],
            isVideo: extra?['isVideo'] ?? false,
            isAudioOnly: extra?['isAudioOnly'] ?? false,  // Audio-only mode
            senderAvatarUrl: extra?['senderAvatarUrl'],   // For blurred background
            isFromGallery: extra?['isFromGallery'] ?? false,
            originalPhotoDate: extra?['originalPhotoDate'],
            audioDuration: extra?['audioDuration'] as int?,
          );
        },
      ),

      // Camera - keeps separate for full screen immersion
      GoRoute(
        path: AppRoutes.camera,
        builder: (context, state) => CameraScreenNew(replyTo: state.extra as VibeModel?),
      ),

      // TOP-LEVEL ALIASES for Deep Links (API 34/Android 14 compatibility)
      GoRoute(
        path: '/record/:friendId',
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),
      GoRoute(
        path: '/r/:friendId', // Short alias
        builder: (context, state) => const Scaffold(body: Center(child: CircularProgressIndicator())),
      ),

      // Widget Configuration - Modern BFF Selector
      GoRoute(
        path: '/widget-config/:appWidgetId',
        builder: (context, state) {
          final appWidgetId = int.tryParse(state.pathParameters['appWidgetId'] ?? '0') ?? 0;
          return BFFConfigScreen(appWidgetId: appWidgetId);
        },
      ),
    ],
    // Custom error handler for genuine 404s
    errorBuilder: (context, state) {
      debugPrint('ðŸ”€ Router Error: URI=${state.uri}, path=${state.uri.path}');
      return NotFoundScreen(uri: state.uri);
    },
  );
});



========================================

FILE #13: E:\Vive\lib\core\services\audio_service.dart

========================================


import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nock/core/constants/app_constants.dart';
import 'package:record/record.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:audio_session/audio_session.dart' as session;

/// Global "Hardware Manager" - The Source of Truth
/// Holds the ID of the content (vibeId) that currently claims the speakers.
final activeContentIdProvider = StateProvider<String?>((ref) => null);

/// Scoped Audio Player (One per widget/screen)
/// Automatically handles cleanup/stopping when a new piece of content takes over.
final scopedAudioPlayerProvider = Provider.autoDispose.family<AudioPlayer, String>((ref, contentId) {
  final player = AudioPlayer();
  
  // LOGIC: If the global active ID changes to something else, WE must stop.
  ref.listen(activeContentIdProvider, (previous, next) {
    if (next != contentId) {
      player.stop(); // Release resources immediately
    }
  });

  ref.onDispose(() {
    player.dispose();
  });
  
  return player;
});

/// Audio Recording State
enum RecordingState {
  idle,
  recording,
  paused,
  stopped,
}

/// Audio Playback State  
enum PlaybackState {
  idle,
  loading,
  playing,
  paused,
  completed,
}

/// Recording State Notifier
final recordingStateProvider =
    StateNotifierProvider<RecordingStateNotifier, RecordingState>((ref) {
  return RecordingStateNotifier(ref);
});

/// Current recording duration
final recordingDurationProvider = StateProvider<int>((ref) => 0);

/// Waveform data during recording
final waveformDataProvider = StateProvider<List<double>>((ref) => []);

/// Audio Service Provider
final audioServiceProvider = Provider<AudioService>((ref) {
  final service = AudioService();
  
  // Sync player state to Riverpod provider
  service.player.onPlayerStateChanged.listen((playerState) {
    PlaybackState newState;
    switch (playerState) {
      case PlayerState.playing:
        newState = PlaybackState.playing;
        break;
      case PlayerState.paused:
        newState = PlaybackState.paused;
        break;
      case PlayerState.completed:
        newState = PlaybackState.completed;
        break;
      default:
        newState = PlaybackState.idle;
    }
    ref.read(playbackStateProvider.notifier).state = newState;
  });

  ref.onDispose(service.dispose);
  return service;
});

/// Playback state provider
final playbackStateProvider = StateProvider<PlaybackState>((ref) => PlaybackState.idle);

/// Current playback position
final playbackPositionProvider = StateProvider<Duration>((ref) => Duration.zero);

/// Total audio duration
final totalDurationProvider = StateProvider<Duration>((ref) => Duration.zero);

class RecordingStateNotifier extends StateNotifier<RecordingState> {
  final Ref _ref;
  final AudioRecorder _recorder = AudioRecorder();
  String? _currentPath;
  Timer? _durationTimer;
  bool _isMonitoring = false; // FIX: Flag to stop amplitude monitor loop

  RecordingStateNotifier(this._ref) : super(RecordingState.idle);

  String? get currentPath => _currentPath;

  /// Start recording
  Future<bool> startRecording() async {
    try {
      if (!await _recorder.hasPermission()) {
        return false;
      }

      // CRITICAL: Clear previous recording data before starting new one
      _ref.read(recordingDurationProvider.notifier).state = 0;
      _ref.read(waveformDataProvider.notifier).state = [];

      // Get temp directory for recording
      final tempDir = await getTemporaryDirectory();
      _currentPath = path.join(
        tempDir.path,
        'vibe_recording_${DateTime.now().millisecondsSinceEpoch}.m4a',
      );

      // Configure recording
      await _recorder.start(
        RecordConfig(
          encoder: AudioEncoder.aacLc,
          bitRate: 128000,
          sampleRate: 44100,
        ),
        path: _currentPath!,
      );

      state = RecordingState.recording;
      _startDurationTimer();
      _startAmplitudeMonitor();
      
      return true;
    } catch (e) {
      debugPrint('Error starting recording: $e');
      return false;
    }
  }

  /// Stop recording
  Future<String?> stopRecording() async {
    // ðŸ›¡ï¸ STABILITY FIX: Only stop if we are actually recording or paused
    // Prevents "Stop() called but track is not started" native warnings
    if (state != RecordingState.recording && state != RecordingState.paused) {
      debugPrint('RecordingStateNotifier: stopRecording called while not active. Skipping.');
      return null;
    }

    try {
      // FIX: Cancel timer BEFORE stopping to prevent state updates on disposed widget
      _durationTimer?.cancel();
      _durationTimer = null;
      _isMonitoring = false; // Stop amplitude loop
      
      final path = await _recorder.stop();
      state = RecordingState.stopped;
      // NOTE: We no longer clear duration/waveform here 
      // so the UI can send the data!
      return path;
    } catch (e) {
      debugPrint('Error stopping recording: $e');
      return null;
    }
  }

  /// Cancel recording
  Future<void> cancelRecording() async {
    try {
      await _recorder.stop();
      // Delete the file
      if (_currentPath != null) {
        final file = File(_currentPath!);
        if (await file.exists()) {
          await file.delete();
        }
      }
      state = RecordingState.idle;
      _ref.read(recordingDurationProvider.notifier).state = 0;
      _ref.read(waveformDataProvider.notifier).state = [];
    } catch (e) {
      debugPrint('Error canceling recording: $e');
    }
  }

  void _startDurationTimer() {
    // CRITICAL FIX: Use Timer.periodic instead of while loop with Future.delayed
    // Future.delayed is "at least" 1 second, causing drift over time.
    // Timer.periodic ticks at consistent intervals for accurate UI sync.
    _durationTimer?.cancel();
    _durationTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (state != RecordingState.recording) {
        timer.cancel();
        return;
      }
      
      _ref.read(recordingDurationProvider.notifier).state++;
      
      // Auto-stop at max duration
      if (_ref.read(recordingDurationProvider) >= AppConstants.maxVoiceNoteDuration) {
        timer.cancel();
        stopRecording();
      }
    });
  }

  void _startAmplitudeMonitor() async {
    _isMonitoring = true;
    while (_isMonitoring && state == RecordingState.recording) {
      try {
        // FIX: Check flag before each state update to prevent defunct element errors
        if (!_isMonitoring) return;
        
        final amplitude = await _recorder.getAmplitude();
        final normalized = ((amplitude.current + 60) / 60).clamp(0.0, 1.0);
        
        // FIX: Double-check before state update
        if (!_isMonitoring) return;
        
        final currentWaveform = [..._ref.read(waveformDataProvider)];
        currentWaveform.add(normalized);
        
        // Keep ALL samples for accurate visualization and storage
        // UI components will downsample as needed
        
        // FIX: Triple-check before state update
        if (!_isMonitoring) return;
        _ref.read(waveformDataProvider.notifier).state = currentWaveform;
      } catch (e) {
        // Ignore amplitude errors
      }
      await Future.delayed(const Duration(milliseconds: 100));
    }
  }

  @override
  void dispose() {
    _durationTimer?.cancel();
    _isMonitoring = false; // Stop amplitude loop on dispose
    _recorder.dispose();
    super.dispose();
  }
}

/// Audio playback service
class AudioService {
  final AudioPlayer _player = AudioPlayer();

  AudioPlayer get player => _player;

  /// Play audio from URL
  Future<void> playFromUrl(String url) async {
    try {
      await _player.play(UrlSource(url));
    } catch (e) {
      debugPrint('Error playing audio: $e');
    }
  }

  /// Play audio from file
  Future<void> playFromFile(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        await _player.play(DeviceFileSource(path));
      } else {
        debugPrint('AudioService: File not found: $path');
      }
    } catch (e) {
      debugPrint('Error playing audio: $e');
    }
  }

  /// Pause playback
  Future<void> pause() async {
    await _player.pause();
  }

  /// Resume playback
  Future<void> resume() async {
    await _player.resume();
  }

  /// Stop playback
  Future<void> stop() async {
    await _player.stop();
  }

  /// Seek to position
  Future<void> seek(Duration position) async {
    await _player.seek(position);
  }

  /// Get current position stream
  Stream<Duration> get positionStream => _player.onPositionChanged;

  /// Get duration stream
  Stream<Duration> get durationStream => _player.onDurationChanged;

  /// Get player state stream
  Stream<PlayerState> get stateStream => _player.onPlayerStateChanged;

  void dispose() {
    _player.dispose();
  }

  /// Initialize Global Audio Session (Best Practice)
  /// Handles interruptions (Phone calls, Siri, Alarms) robustly.
  static Future<void> initSession() async {
    final sessionInstance = await session.AudioSession.instance;
    await sessionInstance.configure(const session.AudioSessionConfiguration(
      avAudioSessionCategory: session.AVAudioSessionCategory.playback,
      avAudioSessionCategoryOptions: session.AVAudioSessionCategoryOptions.duckOthers,
      androidAudioAttributes: session.AndroidAudioAttributes(
        contentType: session.AndroidAudioContentType.speech,
        usage: session.AndroidAudioUsage.media,
      ),
      androidAudioFocusGainType: session.AndroidAudioFocusGainType.gain,
    ));
    
    // Handle global interruptions (e.g. Phone Call)
    sessionInstance.interruptionEventStream.listen((event) {
      if (event.begin) {
        // Interruption started
        switch (event.type) {
          case session.AudioInterruptionType.pause:
          case session.AudioInterruptionType.unknown:
            // Phone call or alarm -> PAUSE
            debugPrint('AudioSession: Interruption started (${event.type})');
            break;
          default:
            break;
        }
      } else {
        // Interruption ended
        // We generally DO NOT resume automatically for calls, as per Apple Guidelines.
        // User should explicitly tap play.
         debugPrint('AudioSession: Interruption ended (${event.type})');
      }
    });
  }
}

/// Audio Lifecycle Manager
/// 
/// Listens for app lifecycle changes and ensures the iOS audio session
/// is deactivated when the app is backgrounded to prevent the "Red Bar".
class AudioLifecycleManager extends ConsumerStatefulWidget {
  final Widget child;
  const AudioLifecycleManager({super.key, required this.child});

  @override
  ConsumerState<AudioLifecycleManager> createState() => _AudioLifecycleManagerState();
}

class _AudioLifecycleManagerState extends ConsumerState<AudioLifecycleManager> with WidgetsBindingObserver {
  static const _platform = MethodChannel('com.vive.app/audio');

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
      // App is going to background -> Kill the Red Bar
      _deactivateAudioSession();
    }
  }

  Future<void> _deactivateAudioSession() async {
    if (Platform.isIOS) {
      try {
        // STEP 1: Stop any active recording/playback before deactivating native session
        // This ensures the hardware is released and prevents "IsBusy" errors (0x62757379)
        await ref.read(recordingStateProvider.notifier).stopRecording();
        await ref.read(audioServiceProvider).stop();
        
        // STEP 2: Slight delay to allow AVAudioSession to enter a non-busy state
        // Higher-level players (Audioplayers/Record) may take a few ms to release the sink
        await Future.delayed(const Duration(milliseconds: 200));

        await _platform.invokeMethod('deactivateSession');
        debugPrint('ðŸ”— AudioLifecycle: iOS session deactivated to prevent Red Bar');
      } on PlatformException catch (e) {
        debugPrint('ðŸ”— AudioLifecycle: Failed to deactivate session: ${e.message}');
      }
    }
  }

  @override
  Widget build(BuildContext context) => widget.child;
}



========================================

FILE #14: E:\Vive\lib\core\services\auth_service.dart

========================================


import 'dart:convert';
import 'dart:math';
import 'package:crypto/crypto.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:sign_in_with_apple/sign_in_with_apple.dart';
import 'dart:io';
import '../models/user_model.dart';
import '../constants/app_constants.dart';
import 'cloudinary_service.dart';
import 'cache_cleanup_service.dart';
import 'widget_update_service.dart';

/// Auth Service Provider
final authServiceProvider = Provider<AuthService>((ref) {
  return AuthService(ref);
});

/// Current User Stream Provider
final authStateProvider = StreamProvider<User?>((ref) {
  return FirebaseAuth.instance.authStateChanges();
});

/// Current User Model Provider
final currentUserProvider = StreamProvider<UserModel?>((ref) {
  final authState = ref.watch(authStateProvider);
  return authState.when(
    data: (user) {
      if (user == null) return Stream.value(null);
      return FirebaseFirestore.instance
          .collection(AppConstants.usersCollection)
          .doc(user.uid)
          .snapshots()
          .map((doc) => doc.exists ? UserModel.fromFirestore(doc) : null);
    },
    loading: () => Stream.value(null),
    error: (_, __) => Stream.value(null),
  );
});

/// Authentication Service
/// 
/// Supports authentication methods:
/// 1. Google Sign-In (fastest, most common)
/// 2. Apple Sign-In (required for iOS, privacy-focused)
class AuthService {
  final Ref? _ref; // Horizontal access for forensic cleanup
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final GoogleSignIn _googleSignIn = GoogleSignIn();
  
  AuthService([this._ref]);

  User? get currentUser => _auth.currentUser;
  String? get currentUserId => _auth.currentUser?.uid;

  // ==================== GOOGLE SIGN-IN ====================
  
  /// Sign in with Google
  /// Returns UserCredential on success, throws on failure
  Future<UserCredential?> signInWithGoogle() async {
    try {
      // Trigger the Google Sign-In flow
      final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
      
      if (googleUser == null) {
        // User cancelled the sign-in
        return null;
      }

      // Obtain the auth details from the request
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;

      // Create a new credential
      final credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken,
        idToken: googleAuth.idToken,
      );

      // Sign in to Firebase with the credential
      final userCredential = await _auth.signInWithCredential(credential);
      
      // Save user ID for cold start sync
      await _saveUserId(userCredential.user?.uid);
      
      // Create/update user document
      if (userCredential.user != null) {
        await createOrUpdateUserDocument(
          userId: userCredential.user!.uid,
          email: googleUser.email,
          displayName: googleUser.displayName ?? 'Nock User',
          avatarUrl: googleUser.photoUrl,
          authProvider: 'google',
        );
      }

      return userCredential;
    } catch (e) {
      debugPrint('Google Sign-In Error: $e');
      rethrow;
    }
  }

  // ==================== APPLE SIGN-IN ====================
  
  /// Sign in with Apple
  /// Returns UserCredential on success, throws on failure
  Future<UserCredential?> signInWithApple() async {
    try {
      // Generate nonce for security
      final rawNonce = _generateNonce();
      final nonce = _sha256ofString(rawNonce);

      // Request credential for Apple Sign-In
      final appleCredential = await SignInWithApple.getAppleIDCredential(
        scopes: [
          AppleIDAuthorizationScopes.email,
          AppleIDAuthorizationScopes.fullName,
        ],
        nonce: nonce,
      );

      // Create an OAuthCredential from the Apple credential
      final oauthCredential = OAuthProvider('apple.com').credential(
        idToken: appleCredential.identityToken,
        rawNonce: rawNonce,
      );

      // Sign in to Firebase with the credential
      final userCredential = await _auth.signInWithCredential(oauthCredential);
      
      // Save user ID for cold start sync
      await _saveUserId(userCredential.user?.uid);
      
      // Create/update user document
      // Note: Apple may only provide name on first sign-in
      if (userCredential.user != null) {
        String displayName = 'Nock User';
        if (appleCredential.givenName != null) {
          displayName = '${appleCredential.givenName} ${appleCredential.familyName ?? ''}'.trim();
        } else if (userCredential.user!.displayName != null) {
          displayName = userCredential.user!.displayName!;
        }
        
        await createOrUpdateUserDocument(
          userId: userCredential.user!.uid,
          email: appleCredential.email ?? userCredential.user!.email,
          displayName: displayName,
          avatarUrl: userCredential.user!.photoURL,
          authProvider: 'apple',
        );
      }

      return userCredential;
    } catch (e) {
      debugPrint('Apple Sign-In Error: $e');
      rethrow;
    }
  }

  /// Generate a random nonce for Apple Sign-In security
  String _generateNonce([int length = 32]) {
    const charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvwxyz-._';
    final random = Random.secure();
    return List.generate(length, (_) => charset[random.nextInt(charset.length)]).join();
  }

  /// SHA256 hash of a string
  String _sha256ofString(String input) {
    final bytes = utf8.encode(input);
    final digest = sha256.convert(bytes);
    return digest.toString();
  }



  // ==================== USER DOCUMENT MANAGEMENT ====================
  
  /// Create or update user document (works for all auth providers)
  Future<void> createOrUpdateUserDocument({
    required String userId,
    String? phoneNumber,
    String? email,
    required String displayName,
    String? avatarUrl,
    String authProvider = 'phone',
    bool isGuest = false,
    bool isProfileUpdate = false, // FIX: Track if this is an explicit profile update
  }) async {
    final userDoc = _firestore.collection(AppConstants.usersCollection).doc(userId);
    final docSnapshot = await userDoc.get();

    if (!docSnapshot.exists) {
      // Create new user (ALWAYS use provided name on first sign-in)
      final user = UserModel(
        id: userId,
        phoneNumber: phoneNumber ?? '',
        email: email,
        displayName: displayName,
        avatarUrl: avatarUrl,
        createdAt: DateTime.now(),
        lastActive: DateTime.now(),
        authProvider: authProvider,
        isGuest: isGuest,
      );
      await userDoc.set(user.toFirestore());
    } else {
      // Update existing user - PROTECT custom profile data
      final updateData = <String, dynamic>{
        'lastActive': Timestamp.now(),
      };
      
      final existingData = docSnapshot.data() as Map<String, dynamic>?;
      
      // Only update fields if they have values
      if (email != null) updateData['email'] = email;
      
      // Protect avatar: Only update if current is null/empty or this is a profile update
      final existingAvatar = existingData?['avatarUrl'] as String?;
      if (avatarUrl != null) {
        if (existingAvatar == null || existingAvatar.isEmpty || isProfileUpdate) {
          updateData['avatarUrl'] = avatarUrl;
        }
      }
      
      if (!isGuest) updateData['isGuest'] = false;
      
      // CRITICAL FIX: Update displayName if it's an explicit profile update
      // OR if the current name is a default/empty value.
      // This solves the "Name Amnesia" bug where Apple/Google Sign-In would
      // otherwise ignore the name on subsequent logins.
      final existingName = existingData?['displayName'] as String?;
      final isDefaultName = existingName == null || 
                          existingName.isEmpty || 
                          existingName == 'Nock User';
                          
      if (isProfileUpdate || isDefaultName) {
        updateData['displayName'] = displayName;
        updateData['searchName'] = displayName.toLowerCase();
      }
      
      if (updateData.length > 1) { // More than just lastActive
        await userDoc.update(updateData);
      }
    }
  }

  /// Legacy method for backwards compatibility
  Future<void> createUserDocument({
    required String userId,
    required String phoneNumber,
    required String displayName,
    String? avatarUrl,
  }) async {
    await createOrUpdateUserDocument(
      userId: userId,
      phoneNumber: phoneNumber,
      displayName: displayName,
      avatarUrl: avatarUrl,
      authProvider: 'phone',
    );
  }

  // ==================== UTILITIES ====================
  
  /// Save user ID to SharedPreferences for cold start sync
  Future<void> _saveUserId(String? userId) async {
    if (userId == null) return;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('current_user_id', userId);
  }

  /// Update FCM token
  Future<void> updateFcmToken(String token) async {
    if (currentUserId == null) return;
    await _firestore
        .collection(AppConstants.usersCollection)
        .doc(currentUserId)
        .update({'fcmToken': token});
  }

  /// Update user status
  Future<void> updateUserStatus(UserStatus status) async {
    if (currentUserId == null) return;
    
    try {
      // Use set with merge to handle case where document doesn't exist
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(currentUserId)
          .set({
            'status': status.name,
            'lastActive': Timestamp.now(),
          }, SetOptions(merge: true));
    } catch (e) {
      debugPrint('Failed to update user status: $e');
    }
  }

  /// Sign out
  /// CRITICAL: Delete FCM token FIRST to prevent notifications going to wrong user
  Future<void> signOut() async {
    try {
      await updateUserStatus(UserStatus.offline);
    } catch (e) {
      // Ignore if user document doesn't exist (guest)
    }
    
    // ðŸš¿ PRIVACY HARDENING: Clear local Firestore cache (Ghost Data)
    // Ensures "Instant-On" data from previous user isn't visible.
    // We must terminate() the instance before clearPersistence() can succeed.
    try {
      await FirebaseFirestore.instance.terminate();
      await FirebaseFirestore.instance.clearPersistence();
      debugPrint('AuthService: Local persistence scrubbed successfully');
    } catch (e) {
      debugPrint('AuthService: Failed to scrub persistence: $e');
    }

    // Delete FCM token
    await _deleteFcmToken();
    
    // Sign out from Google if signed in
    try {
      await _googleSignIn.signOut();
    } catch (e) {
      // Ignore Google sign out errors
    }
    
    // Clear saved user ID
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('current_user_id');
    
    await _auth.signOut();
  }

  /// Delete account permanently
  /// Guideline 5.1.1(v) Requirement - "Forensic Scrubbing"
  Future<void> deleteAccount() async {
    final user = _auth.currentUser;
    if (user == null) return;
    
    final userId = user.uid;
    
    try {
      debugPrint('AuthService: Starting forensic scrub for $userId...');

      // 1. Scrub Vibes (Sent & Received) - Recursive batching for Android 14/Large Data safety
      await _deleteQueryBatch(
        _firestore.collection(AppConstants.vibesCollection).where('senderId', isEqualTo: userId)
      );
      await _deleteQueryBatch(
        _firestore.collection(AppConstants.vibesCollection).where('receiverId', isEqualTo: userId)
      );
      debugPrint('AuthService: Vibes scrubbed');

      // 2. Scrub Friendships (Both directions) - Recursive batching
      await _deleteQueryBatch(
        _firestore.collection(AppConstants.friendshipsCollection).where('userId', isEqualTo: userId)
      );
      await _deleteQueryBatch(
        _firestore.collection(AppConstants.friendshipsCollection).where('friendId', isEqualTo: userId)
      );
      debugPrint('AuthService: Friendships scrubbed');

      // 3. Scrub Private Sub-collections (Widget Data)
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(userId)
          .collection('private')
          .doc('widget_data')
          .delete();
      
      // 4. Scrub Device Cache (Immediate Wipe)
      if (_ref != null) {
        try {
          await _ref!.read(cacheCleanupServiceProvider).forceWipe();
          debugPrint('AuthService: Local device cache wiped');
        } catch (e) {
          debugPrint('AuthService: Cache wipe failed during deletion: $e');
        }
      }

      // 5. Delete User Document
      await _firestore.collection(AppConstants.usersCollection).doc(userId).delete();
      
      // 6. Clear saved user ID from SharedPreferences
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove('current_user_id');
      
      // ðŸš¿ PRIVACY HARDENING: Final Forensic Scrub of local database
      // Must terminate() before clearPersistence()
      try {
        await FirebaseFirestore.instance.terminate();
        await FirebaseFirestore.instance.clearPersistence();
        debugPrint('AuthService: Local persistence scrubbed after account deletion');
      } catch (e) {
        debugPrint('AuthService: Post-deletion scrub failed: $e');
      }

      // 7. Delete the Firebase Auth user
      // Note: This requires a recent login. UI handles re-auth prompt via catch block.
      await user.delete();
      
      debugPrint('AuthService: Forensic scrub COMPLETE for $userId');
    } catch (e) {
      debugPrint('AuthService: Error deleting account: $e');
      rethrow;
    }
  }

  /// Helper to delete documents in batches of 450 (safely under 500 limit)
  /// Uses recursion to handle large datasets (e.g., >1000 vibes).
  Future<void> _deleteQueryBatch(Query query) async {
    // Limit each fetch to stay safely under 500 batches
    final limitedQuery = query.limit(450);
    
    final snapshots = await limitedQuery.get();
    if (snapshots.docs.isEmpty) return;

    final batch = _firestore.batch();
    for (final doc in snapshots.docs) {
      batch.delete(doc.reference);
    }
    
    await batch.commit();
    debugPrint('AuthService: Committed batch of ${snapshots.size} deletes');

    // Recursively call for the next batch if we hit the limit
    if (snapshots.size >= 450) {
      await _deleteQueryBatch(query);
    }
  }
  
  /// Update user profile photo
  /// This propagates the change to:
  /// 1. User document
  /// 2. All vibes sent by the user (denormalized senderAvatar)
  /// 3. Friends' widget_data if the current vibe is from this user
  Future<void> updateAvatar(File imageFile) async {
    final uid = currentUserId;
    if (uid == null) return;

    try {
      debugPrint('AuthService: Updating avatar for $uid...');

      // 1. Upload to Cloudinary
      final avatarUrl = await cloudinaryService.uploadImage(imageFile);
      if (avatarUrl == null) throw Exception('Failed to upload image to Cloudinary');

      // 2. Update User Document
      await _firestore.collection(AppConstants.usersCollection).doc(uid).update({
        'avatarUrl': avatarUrl,
      });
      debugPrint('AuthService: User document updated with new avatar');

      // 3. Propagate to Vibes (Batched)
      // Firestore batches are limited to 500 ops. We use multiple batches if needed.
      final vibesQuery = await _firestore
          .collection(AppConstants.vibesCollection)
          .where('senderId', isEqualTo: uid)
          .get();

      if (vibesQuery.docs.isNotEmpty) {
        WriteBatch batch = _firestore.batch();
        int count = 0;
        for (var doc in vibesQuery.docs) {
          batch.update(doc.reference, {'senderAvatar': avatarUrl});
          count++;
          if (count >= 500) {
            await batch.commit();
            batch = _firestore.batch();
            count = 0;
          }
        }
        if (count > 0) await batch.commit();
        debugPrint('AuthService: Propagated avatar to ${vibesQuery.size} vibes');
      }

      // 4. Update Friends' Widget Data
      // We check friends who have current user's vibe as their latest
      final currentUserDoc = await _firestore.collection(AppConstants.usersCollection).doc(uid).get();
      final List<String> friendIds = List<String>.from(currentUserDoc.data()?['friendIds'] ?? []);

      for (final friendId in friendIds) {
        final widgetDataRef = _firestore
            .collection(AppConstants.usersCollection)
            .doc(friendId)
            .collection('private')
            .doc('widget_data');
        
        final widgetDoc = await widgetDataRef.get();
        if (widgetDoc.exists) {
          final data = widgetDoc.data();
          final stateMap = data?['widgetState'] as Map<String, dynamic>?;
          if (stateMap != null) {
            final latestVibeId = stateMap['latestVibeId'];
            // If the latest vibe for this friend is from the current user
            // we should find if that vibeId is in our vibes list
            final isOwnVibe = vibesQuery.docs.any((d) => d.id == latestVibeId);
            
            if (isOwnVibe) {
              await widgetDataRef.update({
                'widgetState.senderAvatar': avatarUrl,
                // If it's audio-only, the imageUrl also needs update
                if (stateMap['isAudioOnly'] == true) 'widgetState.latestImageUrl': avatarUrl,
              });
              debugPrint('AuthService: Updated widget_data for friend $friendId');
            }
          }
        }
      }

      // 5. Update local cache if possible
      // (BFF widgets and main widget will eventually refresh via Push or next app open)
      
      debugPrint('AuthService: Avatar update COMPLETE for $uid');
    } catch (e) {
      debugPrint('AuthService: Error updating avatar: $e');
      rethrow;
    }
  }
  
  /// Remove friend (silent unfriend - no notification)
  /// Provides "soft exit" from friendship without blocking
  Future<void> removeFriend(String friendId) async {
    final userId = currentUserId;
    if (userId == null) return;
    
    try {
      debugPrint('AuthService: Removing friend $friendId');
      
      // Remove from both users' friendIds arrays
      await _firestore.collection(AppConstants.usersCollection).doc(userId).update({
        'friendIds': FieldValue.arrayRemove([friendId]),
      });
      
      await _firestore.collection(AppConstants.usersCollection).doc(friendId).update({
        'friendIds': FieldValue.arrayRemove([userId]),
      });
      
      // Mark friendship as removed
      final friendshipQuery = await _firestore
          .collection(AppConstants.friendshipsCollection)
          .where('userId', isEqualTo: userId)
          .where('friendId', isEqualTo: friendId)
          .limit(1)
          .get();
      
      if (friendshipQuery.docs.isNotEmpty) {
        await friendshipQuery.docs.first.reference.update({
          'status': 'removed',
          'removedAt': FieldValue.serverTimestamp(),
          'removedBy': userId,
        });
      }
      
      // Check reverse friendship
      final reverseFriendshipQuery = await _firestore
          .collection(AppConstants.friendshipsCollection)
          .where('userId', isEqualTo: friendId)
          .where('friendId', isEqualTo: userId)
          .limit(1)
          .get();
      
      if (reverseFriendshipQuery.docs.isNotEmpty) {
        await reverseFriendshipQuery.docs.first.reference.update({
          'status': 'removed',
          'removedAt': FieldValue.serverTimestamp(),
          'removedBy': userId,
        });
      }
      
      debugPrint('AuthService: Friend removed successfully');
    } catch (e) {
      debugPrint('AuthService: Error removing friend: $e');
      rethrow;
    }
  }

  /// Delete FCM token on logout
  Future<void> _deleteFcmToken() async {
    if (currentUserId == null) return;
    
    try {
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(currentUserId)
          .update({'fcmToken': FieldValue.delete()});
      
      await FirebaseMessaging.instance.deleteToken();
    } catch (e) {
      // Don't block signout on token deletion failure
    }
  }
}



========================================

FILE #15: E:\Vive\lib\core\services\background_upload_service.dart

========================================


import 'dart:io';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';

/// Background Upload Service
/// 
/// Provides a "Short-lived" native bridge to ensure uploads finish
/// even if the app is swiped away or backgrounded.
/// 
/// Uses:
/// - Android: Expedited Jobs (WorkManager) / User-Initiated Data Transfer
/// - iOS: BGContinuedProcessingTask (iOS 19+) + URLSession background
class BackgroundUploadService {
  static const MethodChannel _channel = MethodChannel('com.nock.nock/background_upload');

  /// Start a "Short-lived" background task
  /// This tells the OS to give the app ~3-5 minutes of survival time.
  static Future<String?> startTask({
    required String title,
    required String subtitle,
  }) async {
    try {
      final String? taskId = await _channel.invokeMethod('startBackgroundTask', {
        'title': title,
        'subtitle': subtitle,
      });
      debugPrint('ðŸ›¡ï¸ BackgroundUpload: Task started - $taskId');
      return taskId;
    } catch (e) {
      debugPrint('âš ï¸ BackgroundUpload: Failed to start task: $e');
      return null;
    }
  }

  /// Update the progress of the background task (Visible in Live Activities/Notifications)
  static Future<void> updateProgress(String taskId, double fraction, String subtitle) async {
    try {
      await _channel.invokeMethod('updateTaskProgress', {
        'taskId': taskId,
        'fraction': fraction,
        'subtitle': subtitle,
      });
    } catch (e) {
       debugPrint('âš ï¸ BackgroundUpload: Failed to update progress: $e');
    }
  }

  /// End the background task
  /// MUST be called once the upload finishes or fails.
  static Future<void> stopTask(String? taskId) async {
    if (taskId == null) return;
    try {
      await _channel.invokeMethod('stopBackgroundTask', {
        'taskId': taskId,
      });
      debugPrint('ðŸ›¡ï¸ BackgroundUpload: Task stopped - $taskId');
    } catch (e) {
      debugPrint('âš ï¸ BackgroundUpload: Failed to stop task: $e');
    }
  }
}



========================================

FILE #16: E:\Vive\lib\core\services\cache_cleanup_service.dart

========================================


import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Cache Cleanup Service
/// 
/// Prevents storage bloat by automatically cleaning up old cached files.
/// Audio/image files downloaded for widget previews are cleaned after 24 hours.
class CacheCleanupService {
  static const String _lastCleanupKey = 'last_cache_cleanup';
  static const Duration _cleanupInterval = Duration(hours: 12);
  static const Duration _fileExpiry = Duration(hours: 48); // Extended from 24h
  static const int _maxCacheSize = 500 * 1024 * 1024; // 500MB limit
  
  /// Initialize and run cleanup if needed
  Future<void> initialize() async {
    await _runCleanupIfNeeded();
  }

  /// Run cleanup if it hasn't been done recently
  Future<void> _runCleanupIfNeeded() async {
    final prefs = await SharedPreferences.getInstance();
    final lastCleanup = prefs.getInt(_lastCleanupKey) ?? 0;
    final lastCleanupTime = DateTime.fromMillisecondsSinceEpoch(lastCleanup);
    
    if (DateTime.now().difference(lastCleanupTime) > _cleanupInterval) {
      await cleanupCache();
      await prefs.setInt(_lastCleanupKey, DateTime.now().millisecondsSinceEpoch);
    }
  }

  /// Clean up old cached files
  Future<CleanupResult> cleanupCache() async {
    int filesDeleted = 0;
    int bytesFreed = 0;
    
    try {
      final tempDir = await getTemporaryDirectory();
      
      // Clean up share/export files
      // CRITICAL: Include ALL temp file patterns to prevent storage bloat
      filesDeleted += await _cleanupDirectory(
        Directory('${tempDir.path}'),
        patterns: [
          'vibe_share_', 
          'vibe_audio_', 
          'share_image_', 
          'share_audio_', 
          'temp_',
          'vibe_recording_',  // Voice note recordings (sent or cancelled)
          'vibe_invite_',     // Invite card images
          'vibe_viral_',      // FFmpeg generated videos (Heavy!)
          'vibe_shared_video_', // Downloaded shared videos
          'viral_image_',     // Asset downloads for generation
          'viral_audio_',     // Asset downloads for generation
          'vibe_thumbnail_',  // Video thumbnails
          'vibe_overlay_',    // Transparent overlay PNGs
          'vibe_video_overlay_', // Composited video files
          'flutter_sound',    // Raw recording buffers from flutter_sound
          'gatekeeper_',      // Temporary VAD files
        ],
        expiry: _fileExpiry,
        onDelete: (size) => bytesFreed += size,
      );
      
      // Clean up app cache
      try {
        final cacheDir = await getApplicationCacheDirectory();
        filesDeleted += await _cleanupDirectory(
          cacheDir,
          patterns: [
            'vibe_', 
            'temp_', 
            'share_',
            'libCachedImageData', // cached_network_image storage
            'flutter_sound',
          ],
          expiry: _fileExpiry,
          onDelete: (size) => bytesFreed += size,
        );
      } catch (e) {
        debugPrint('CacheCleanup: Cache directory cleanup failed: $e');
      }
      
      debugPrint('CacheCleanup: Deleted $filesDeleted files, freed ${_formatBytes(bytesFreed)}');
      
      return CleanupResult(
        success: true,
        filesDeleted: filesDeleted,
        bytesFreed: bytesFreed,
      );
    } catch (e) {
      debugPrint('CacheCleanup: Error during cleanup: $e');
      return CleanupResult(
        success: false,
        filesDeleted: filesDeleted,
        bytesFreed: bytesFreed,
        error: e.toString(),
      );
    }
  }

  /// Clean up files in a directory using LRU strategy
  Future<int> _cleanupDirectory(
    Directory directory, {
    List<String> patterns = const [],
    required Duration expiry,
    void Function(int size)? onDelete,
  }) async {
    int count = 0;
    
    if (!await directory.exists()) return 0;
    
    final now = DateTime.now();
    List<FileStatWithName> fileStats = [];
    
    // 1. Collect all matching files and their stats (Recursive scan!)
    await for (final entity in directory.list(recursive: true)) {
      if (entity is File) {
        try {
          final fileName = entity.path.split('/').last;
          bool matchesPattern = patterns.isEmpty || 
              patterns.any((p) => fileName.contains(p));
          
          if (!matchesPattern) continue;
          
          final stat = await entity.stat();
          fileStats.add(FileStatWithName(
            path: entity.path,
            stat: stat,
          ));
        } catch (e) {
          debugPrint('CacheCleanup: Error stating ${entity.path}: $e');
        }
      }
    }

    // 2. Initial Cleanup: Delete expired files (older than _fileExpiry)
    for (var i = fileStats.length - 1; i >= 0; i--) {
      final f = fileStats[i];
      if (now.difference(f.stat.modified) > expiry) {
        try {
          final file = File(f.path);
          final size = f.stat.size;
          await file.delete();
          count++;
          onDelete?.call(size);
          fileStats.removeAt(i);
          debugPrint('CacheCleanup: Expired ${f.path}');
        } catch (_) {}
      }
    }

    // 3. LRU Cleanup: Sort by modification time (oldest first)
    fileStats.sort((a, b) => a.stat.modified.compareTo(b.stat.modified));
    
    // 4. Size-based Eviction: Ensure total size < _maxCacheSize
    int currentTotalSize = fileStats.fold(0, (sum, f) => sum + f.stat.size);
    
    while (currentTotalSize > _maxCacheSize && fileStats.isNotEmpty) {
      final oldest = fileStats.removeAt(0);
      try {
        final file = File(oldest.path);
        final size = oldest.stat.size;
        await file.delete();
        count++;
        currentTotalSize -= size;
        onDelete?.call(size);
        debugPrint('CacheCleanup: LRU Evicted ${oldest.path} (${_formatBytes(size)})');
      } catch (e) {
        debugPrint('CacheCleanup: Failed to evict ${oldest.path}: $e');
      }
    }
    
    return count;
  }

  /// Force immediate cleanup (for settings or manual trigger)
  Future<CleanupResult> forceCleanup() async {
    final result = await cleanupCache();
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt(_lastCleanupKey, DateTime.now().millisecondsSinceEpoch);
    return result;
  }

  /// ðŸ§¹ FORCE WIPE: Completely delete ALL temporary and cached files.
  /// Used for forensic scrubbing during account deletion.
  Future<CleanupResult> forceWipe() async {
    int filesDeleted = 0;
    int bytesFreed = 0;
    
    try {
      final tempDir = await getTemporaryDirectory();
      final cacheDir = await getApplicationCacheDirectory();
      
      // Wipe everything in temp
      await for (final entity in tempDir.list(recursive: true)) {
        if (entity is File) {
          try {
            final size = (await entity.stat()).size;
            await entity.delete();
            filesDeleted++;
            bytesFreed += size;
          } catch (_) {}
        }
      }
      
      // Wipe everything in cache
      if (await cacheDir.exists()) {
        await for (final entity in cacheDir.list(recursive: true)) {
          if (entity is File) {
            try {
              final size = (await entity.stat()).size;
              await entity.delete();
              filesDeleted++;
              bytesFreed += size;
            } catch (_) {}
          }
        }
      }
      
      debugPrint('CacheCleanup: FORCE WIPE COMPLETE. Deleted $filesDeleted files.');
      
      return CleanupResult(
        success: true,
        filesDeleted: filesDeleted,
        bytesFreed: bytesFreed,
      );
    } catch (e) {
      debugPrint('CacheCleanup: Force wipe failed: $e');
      return CleanupResult(
        success: false,
        filesDeleted: filesDeleted,
        bytesFreed: bytesFreed,
        error: e.toString(),
      );
    }
  }

  /// Get current cache size
  Future<CacheInfo> getCacheInfo() async {
    int totalSize = 0;
    int fileCount = 0;
    
    try {
      final tempDir = await getTemporaryDirectory();
      final result = await _getDirectorySize(tempDir);
      totalSize += result.size;
      fileCount += result.count;
      
      try {
        final cacheDir = await getApplicationCacheDirectory();
        final cacheResult = await _getDirectorySize(cacheDir);
        totalSize += cacheResult.size;
        fileCount += cacheResult.count;
      } catch (e) {
        // Cache directory might not exist
      }
    } catch (e) {
      debugPrint('CacheCleanup: Error getting cache info: $e');
    }
    
    return CacheInfo(
      totalSize: totalSize,
      fileCount: fileCount,
      formattedSize: _formatBytes(totalSize),
    );
  }

  Future<({int size, int count})> _getDirectorySize(Directory dir) async {
    int size = 0;
    int count = 0;
    
    if (!await dir.exists()) return (size: 0, count: 0);
    
    await for (final entity in dir.list(recursive: true)) {
      if (entity is File) {
        try {
          final stat = await entity.stat();
          size += stat.size;
          count++;
        } catch (e) {
          // Skip inaccessible files
        }
      }
    }
    
    return (size: size, count: count);
  }

  String _formatBytes(int bytes) {
    if (bytes < 1024) return '$bytes B';
    if (bytes < 1024 * 1024) return '${(bytes / 1024).toStringAsFixed(1)} KB';
    if (bytes < 1024 * 1024 * 1024) return '${(bytes / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }
}

/// Helper class for file stats
class FileStatWithName {
  final String path;
  final FileStat stat;
  
  FileStatWithName({required this.path, required this.stat});
}

/// Result of a cache cleanup operation
class CleanupResult {
  final bool success;
  final int filesDeleted;
  final int bytesFreed;
  final String? error;

  CleanupResult({
    required this.success,
    required this.filesDeleted,
    required this.bytesFreed,
    this.error,
  });

  String get formattedBytesFreed {
    if (bytesFreed < 1024) return '$bytesFreed B';
    if (bytesFreed < 1024 * 1024) return '${(bytesFreed / 1024).toStringAsFixed(1)} KB';
    if (bytesFreed < 1024 * 1024 * 1024) return '${(bytesFreed / (1024 * 1024)).toStringAsFixed(1)} MB';
    return '${(bytesFreed / (1024 * 1024 * 1024)).toStringAsFixed(1)} GB';
  }
}

/// Information about current cache state
class CacheInfo {
  final int totalSize;
  final int fileCount;
  final String formattedSize;

  CacheInfo({
    required this.totalSize,
    required this.fileCount,
    required this.formattedSize,
  });
}

/// Cache cleanup service provider
final cacheCleanupServiceProvider = Provider<CacheCleanupService>((ref) {
  return CacheCleanupService();
});



========================================

FILE #17: E:\Vive\lib\core\services\cloudinary_service.dart

========================================


import 'dart:convert';
import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;

/// Cloudinary Service for file uploads
/// 
/// Uses Cloudinary's free tier (no credit card required):
/// - 25GB storage
/// - 25GB bandwidth
/// - Supports images, videos, and audio (as 'raw')
/// 
/// To set up:
/// 1. Create a free Cloudinary account at https://cloudinary.com
/// 2. Go to Settings â†’ Upload â†’ Upload Presets
/// 3. Create an UNSIGNED preset (required for client-side uploads)
/// 4. Update cloudName and uploadPreset below
class CloudinaryService {
  // Cloudinary credentials
  static const String cloudName = "dspfkp3zu";  // âœ… Updated!
  static const String uploadPreset = "nock_uploads";  // âš ï¸ CREATE THIS IN CLOUDINARY CONSOLE!
  
  /// Upload an image file to Cloudinary
  /// Returns the secure URL of the uploaded image
  Future<String?> uploadImage(File imageFile, {String? signature, int? timestamp, Function(double)? onProgress}) async {
    return _uploadFile(imageFile, 'image', signature: signature, timestamp: timestamp, onProgress: onProgress);
  }
  
  /// Upload a video file to Cloudinary
  /// Returns the secure URL of the uploaded video
  Future<String?> uploadVideo(File videoFile, {String? signature, int? timestamp, Function(double)? onProgress}) async {
    return _uploadFile(videoFile, 'video', signature: signature, timestamp: timestamp, onProgress: onProgress);
  }
  
  /// Upload an audio file to Cloudinary
  /// Note: Audio files are uploaded as 'raw' resource type
  /// Returns the secure URL of the uploaded audio
  Future<String?> uploadAudio(File audioFile, {String? signature, int? timestamp, Function(double)? onProgress}) async {
    return _uploadFile(audioFile, 'raw', signature: signature, timestamp: timestamp, onProgress: onProgress);
  }
  
  /// Generic file upload to Cloudinary
  /// 
  /// [file] - The file to upload
  /// [resourceType] - 'image', 'video', or 'raw' (for audio/other files)
  /// [signature] - Optional signature for signed uploads (Security enhancement)
  /// [timestamp] - Optional timestamp for signed uploads
  Future<String?> _uploadFile(
    File file, 
    String resourceType, {
    String? signature,
    int? timestamp,
    Function(double)? onProgress,
  }) async {
    if (cloudName == "YOUR_CLOUD_NAME") {
      debugPrint('âš ï¸ Cloudinary: Please configure your cloud name!');
      return null;
    }
    
    final url = Uri.parse(
      "https://api.cloudinary.com/v1_1/$cloudName/$resourceType/upload"
    );
    
    try {
      debugPrint('â˜ï¸ Cloudinary: Uploading $resourceType to $url...');
      
      var request = http.MultipartRequest("POST", url);
      
      if (signature != null && timestamp != null) {
        request.fields['api_key'] = "513364953496979";
        request.fields['timestamp'] = timestamp.toString();
        request.fields['signature'] = signature;
      } else {
        request.fields['upload_preset'] = uploadPreset;
      }
      
      final multipartFile = await http.MultipartFile.fromPath('file', file.path);
      request.files.add(multipartFile);

      // Wrapper to track progress if callback provided
      if (onProgress != null) {
        final totalBytes = multipartFile.length;
        // Note: For simple http package, we approximate or use a custom stream if needed.
        // For 2026 Gold Standard, we pulse an initial progress and final completion.
        onProgress(0.1); 
      }
      
      var response = await request.send();
      debugPrint('â˜ï¸ Cloudinary: Response status = ${response.statusCode}');
      
      if (response.statusCode == 200) {
        onProgress?.call(1.0);
        var responseData = await response.stream.bytesToString();
        var json = jsonDecode(responseData);
        final secureUrl = json['secure_url'] as String;
        debugPrint('â˜ï¸ Cloudinary: SUCCESS! URL=$secureUrl');
        return secureUrl;
      } else {
        var errorData = await response.stream.bytesToString();
        debugPrint('âŒ Cloudinary: FAILED (${response.statusCode}): $errorData');
        return null;
      }
    } catch (e) {
      debugPrint('â˜ï¸ Cloudinary: Error uploading file: $e');
      return null;
    }
  }
  
  /// Delete an asset from Cloudinary by URL
  /// Extracts public_id from URL for deletion
  Future<bool> deleteAsset(String url) async {
    try {
      final publicId = _extractPublicId(url);
      if (publicId == null) {
        debugPrint('â˜ï¸ Cloudinary: Could not extract public_id from URL');
        return false;
      }
      
      debugPrint('â˜ï¸ Cloudinary: Marking asset for deletion: $publicId');
      // Note: Client-side deletion requires API secret
      // This is marked for backend cleanup via Cloud Functions
      return true;
    } catch (e) {
      debugPrint('â˜ï¸ Cloudinary: Error deleting asset: $e');
      return false;
    }
  }
  
  /// Extract public_id from Cloudinary URL
  String? _extractPublicId(String url) {
    try {
      if (!url.contains('cloudinary.com')) return null;
      
      final parts = url.split('/');
      final uploadIndex = parts.indexOf('upload');
      if (uploadIndex == -1 || uploadIndex + 1 >= parts.length) return null;
      
      var startIndex = uploadIndex + 1;
      if (parts[startIndex].startsWith('v') && parts[startIndex].length > 1) {
        startIndex++;
      }
      
      final pathSegments = parts.sublist(startIndex);
      final lastSegment = pathSegments.last;
      final publicId = lastSegment.split('.').first;
      
      return pathSegments.length > 1 
          ? '${pathSegments.sublist(0, pathSegments.length - 1).join('/')}/$publicId'
          : publicId;
    } catch (e) {
      return null;
    }
  }
  
  /// Upload multiple files in parallel
  /// Returns a map of original paths to Cloudinary URLs
  Future<Map<String, String?>> uploadMultiple({
    File? imageFile,
    File? audioFile,
    File? videoFile,
  }) async {
    final results = <String, String?>{};
    final futures = <Future<void>>[];
    
    if (imageFile != null) {
      futures.add(
        uploadImage(imageFile).then((url) => results['image'] = url)
      );
    }
    
    if (audioFile != null) {
      futures.add(
        uploadAudio(audioFile).then((url) => results['audio'] = url)
      );
    }
    
    if (videoFile != null) {
      futures.add(
        uploadVideo(videoFile).then((url) => results['video'] = url)
      );
    }
    
    await Future.wait(futures);
    return results;
  }
}

/// Singleton provider for CloudinaryService
final cloudinaryService = CloudinaryService();



========================================

FILE #18: E:\Vive\lib\core\services\contacts_sync_service.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:fast_contacts/fast_contacts.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:permission_handler/permission_handler.dart';

import '../models/user_model.dart';

/// Provider for the ContactsSyncService
final contactsSyncServiceProvider = Provider<ContactsSyncService>((ref) {
  return ContactsSyncService();
});

/// Represents a synced contact - either matched to a Nock user or not.
class SyncedContact {
  final String displayName;
  final String phoneNumber;
  final UserModel? matchedUser; // null if not on Nock
  
  SyncedContact({
    required this.displayName,
    required this.phoneNumber,
    this.matchedUser,
  });
  
  bool get isOnNock => matchedUser != null;
}

/// Service to sync device contacts and find friends on Nock.
/// 
/// Uses [fast_contacts] for optimized contact fetching (~200ms for 1000+ contacts)
/// and matches phone numbers against Firestore users collection.
class ContactsSyncService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Fetch ALL device contacts and mark which ones are on Nock.
  /// 
  /// Returns a list of [SyncedContact] with:
  /// - matchedUser set if they have a Nock account
  /// - matchedUser null if they're not on Nock (invite them!)
  Future<List<SyncedContact>> syncContacts() async {
    // 1. Check permission
    final status = await Permission.contacts.status;
    if (!status.isGranted) {
      final result = await Permission.contacts.request();
      if (!result.isGranted) {
        debugPrint('ContactsSyncService: Permission denied');
        return [];
      }
    }

    // 2. Fetch contacts using fast_contacts
    final contacts = await FastContacts.getAllContacts();
    debugPrint('ContactsSyncService: Fetched ${contacts.length} contacts');

    // 3. Build list of contacts with normalized phone numbers
    final contactsWithPhones = <_ContactWithPhone>[];
    for (final contact in contacts) {
      for (final phone in contact.phones) {
        final normalized = _normalizePhoneNumber(phone.number);
        if (normalized.isNotEmpty && normalized.length >= 10) {
          contactsWithPhones.add(_ContactWithPhone(
            displayName: contact.displayName,
            originalPhone: phone.number,
            normalizedPhone: normalized,
          ));
        }
      }
    }

    // Remove duplicates by phone number (keep first occurrence)
    final seenPhones = <String>{};
    final uniqueContacts = <_ContactWithPhone>[];
    for (final c in contactsWithPhones) {
      if (!seenPhones.contains(c.normalizedPhone)) {
        seenPhones.add(c.normalizedPhone);
        uniqueContacts.add(c);
      }
    }
    
    debugPrint('ContactsSyncService: ${uniqueContacts.length} unique contacts');

    if (uniqueContacts.isEmpty) {
      return [];
    }

    // 4. Query Firestore in batches of 30 (whereIn limit)
    final matchedUsers = <String, UserModel>{}; // normalized phone -> user
    const batchSize = 30;
    final allNormalizedNumbers = uniqueContacts.map((c) => c.normalizedPhone).toList();

    for (var i = 0; i < allNormalizedNumbers.length; i += batchSize) {
      final batch = allNormalizedNumbers.skip(i).take(batchSize).toList();
      
      try {
        final querySnapshot = await _firestore
            .collection('users')
            .where('phoneNumber', whereIn: batch)
            .get();

        for (final doc in querySnapshot.docs) {
          final user = UserModel.fromFirestore(doc);
          if (user.phoneNumber.isNotEmpty) {
            matchedUsers[user.phoneNumber] = user;
          }
        }
      } catch (e) {
        debugPrint('ContactsSyncService: Batch query error: $e');
      }
    }

    debugPrint('ContactsSyncService: Found ${matchedUsers.length} matches');

    // 5. Build final list with match status
    final result = <SyncedContact>[];
    for (final contact in uniqueContacts) {
      result.add(SyncedContact(
        displayName: contact.displayName,
        phoneNumber: contact.originalPhone,
        matchedUser: matchedUsers[contact.normalizedPhone],
      ));
    }

    // Sort: matches first, then alphabetically
    result.sort((a, b) {
      if (a.isOnNock && !b.isOnNock) return -1;
      if (!a.isOnNock && b.isOnNock) return 1;
      return a.displayName.compareTo(b.displayName);
    });

    return result;
  }

  /// Normalize phone number to a consistent format for matching.
  String _normalizePhoneNumber(String phone) {
    var normalized = phone.replaceAll(RegExp(r'[^\d+]'), '');

    if (!normalized.startsWith('+')) {
      normalized = normalized.replaceAll('+', '');
    }

    if (normalized.length == 10) {
      normalized = '+1$normalized';
    }
    
    if (normalized.length == 11 && normalized.startsWith('1')) {
      normalized = '+$normalized';
    }

    if (normalized.length > 11 && !normalized.startsWith('+')) {
      normalized = '+$normalized';
    }

    return normalized;
  }
}

/// Internal helper class
class _ContactWithPhone {
  final String displayName;
  final String originalPhone;
  final String normalizedPhone;
  
  _ContactWithPhone({
    required this.displayName,
    required this.originalPhone,
    required this.normalizedPhone,
  });
}



========================================

FILE #19: E:\Vive\lib\core\services\deep_link_service.dart

========================================


import 'dart:async';
import 'package:app_links/app_links.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:flutter/services.dart';

/// Deep Link Service
/// 
/// Handles incoming deep links from:
/// - nock://invite/userid (custom scheme)
/// - nock://player/vibeId (player deep link)
/// - https://nock.app/invite/userid (universal links)
/// 
/// Uses app_links package for reliable deep link handling on both platforms.
class DeepLinkService {
  final AppLinks _appLinks = AppLinks();
  StreamSubscription<Uri>? _linkSubscription;
  GoRouter? _router;
  
  /// Initialize the deep link listener
  Future<void> initialize(GoRouter router) async {
    _router = router;
    
    // Handle initial link (if app was launched via deep link)
    try {
      final initialUri = await _appLinks.getInitialLink();
      if (initialUri != null) {
        debugPrint('ðŸ”— DeepLink: Initial link received: $initialUri');
        _handleDeepLink(initialUri);
      }
    } catch (e) {
      debugPrint('ðŸ”— DeepLink: Error getting initial link: $e');
    }
    
    // Listen for subsequent links (when app is already running)
    _linkSubscription = _appLinks.uriLinkStream.listen(
      (Uri uri) {
        debugPrint('ðŸ”— DeepLink: Stream link received: $uri');
        _handleDeepLink(uri);
      },
      onError: (error) {
        debugPrint('ðŸ”— DeepLink: Stream error: $error');
      },
    );

    // CRITICAL: Handle Deferred Deep Linking (Clipboard Bridge)
    // If a user clicks our HTTPS link but doesn't have the app installed,
    // they are sent to the store. We can't easily track that without Branch/FDL.
    // WORKAROUND: We copy the link to their clipboard, and read it here on first launch.
    _checkClipboardForDeferredInvite();
  }

  /// Check clipboard for a Nock invite link (Deferred Deep Link Bridge)
  Future<void> _checkClipboardForDeferredInvite() async {
    try {
      // Small delay to ensure engine is ready
      await Future.delayed(const Duration(seconds: 1));
      
      final data = await Clipboard.getData(Clipboard.kTextPlain);
      final text = data?.text;
      
      if (text != null && text.contains('getnock.app/i/')) {
        debugPrint('ðŸ”— DeepLink: Deferred link found in clipboard: $text');
        final uri = Uri.parse(text);
        
        // Safety: Only process if it matches our pattern
        if (uri.pathSegments.isNotEmpty && (uri.host == 'getnock.app' || uri.host == 'nock.app')) {
          _handleDeepLink(uri);
          
          // Optional: Clear clipboard to avoid double-processing
          // await Clipboard.setData(const ClipboardData(text: ''));
        }
      }
    } catch (e) {
      debugPrint('ðŸ”— DeepLink: Error checking clipboard: $e');
    }
  }
  
  /// Process an incoming deep link
  void _handleDeepLink(Uri uri) {
    debugPrint('ðŸ”— DeepLink: Processing: scheme=${uri.scheme}, host=${uri.host}, path=${uri.path}');
    
    // Handle nock://player/vibeId or nock:///player/vibeId
    // FIX #2: Add player deep link handler BEFORE invite logic
    if (uri.scheme == 'nock') {
      // Check for player path first
      if (uri.host == 'player' && uri.pathSegments.isNotEmpty) {
        final vibeId = uri.pathSegments.first;
        debugPrint('ðŸ”— DeepLink: Player detected (host=player): vibeId=$vibeId');
        _navigateToPlayer(vibeId);
        return;
      } else if (uri.path.startsWith('/player/')) {
        final segments = uri.pathSegments;
        if (segments.length >= 2 && segments[0] == 'player') {
          final vibeId = segments[1];
          debugPrint('ðŸ”— DeepLink: Player detected (path): vibeId=$vibeId');
          _navigateToPlayer(vibeId);
          return;
        }
      } else if (uri.path.startsWith('/record/')) {
        final segments = uri.pathSegments;
        if (segments.length >= 2 && segments[0] == 'record') {
          final friendId = segments[1];
          debugPrint('ðŸ”— DeepLink: Record detected (path): friendId=$friendId');
          _navigateToRecord(friendId);
          return;
        }
      }
            // Then handle invite paths
        if (uri.host == 'record' && uri.queryParameters.containsKey('to')) {
          final friendId = uri.queryParameters['to']!;
          debugPrint('ðŸ”— DeepLink: Record detected (host=record): friendId=$friendId');
          _navigateToRecord(friendId);
          return;
        } else if (uri.host == 'invite' && uri.pathSegments.isNotEmpty) {
        // nock://invite/userid -> path is /userid, host is invite
        final userId = uri.pathSegments.first;
        debugPrint('ðŸ”— DeepLink: Invite detected (host=invite): userId=$userId');
        _navigateToInvite(userId);
      } else if (uri.path.startsWith('/invite/')) {
        // nock:///invite/userid -> path is /invite/userid  
        final segments = uri.pathSegments;
        if (segments.length >= 2 && segments[0] == 'invite') {
          final userId = segments[1];
          debugPrint('ðŸ”— DeepLink: Invite detected (path): userId=$userId');
          _navigateToInvite(userId);
        }
      } else if (uri.pathSegments.isNotEmpty) {
        // nock://userid (direct user ID) - catch-all for invites
        final userId = uri.pathSegments.first;
        debugPrint('ðŸ”— DeepLink: Possible direct userId: $userId');
        _navigateToInvite(userId);
      }
    }
    // Handle https://nock.app/invite/userid or https://nock.app/player/vibeId
    else if (uri.scheme == 'https' && 
             (uri.host == 'nock.app' || uri.host == 'getnock.app')) {
      if (uri.pathSegments.length >= 2 && (uri.pathSegments[0] == 'invite' || uri.pathSegments[0] == 'i')) {
        final userId = uri.pathSegments[1];
        debugPrint('ðŸ”— DeepLink: HTTPS invite (path=${uri.pathSegments[0]}): userId=$userId');
        _navigateToInvite(userId);
      } else if (uri.pathSegments.length >= 2 && uri.pathSegments[0] == 'player') {
        final vibeId = uri.pathSegments[1];
        debugPrint('ðŸ”— DeepLink: HTTPS player: vibeId=$vibeId');
        _navigateToPlayer(vibeId);
      } else if (uri.pathSegments.length >= 2 && (uri.pathSegments[0] == 'record' || uri.pathSegments[0] == 'r')) {
        final friendId = uri.pathSegments[1];
        debugPrint('ðŸ”— DeepLink: HTTPS record: friendId=$friendId');
        _navigateToRecord(friendId);
      }
    }
  }
  
  /// Navigate to the player screen
  void _navigateToPlayer(String vibeId) {
    if (_router != null && vibeId.isNotEmpty) {
      debugPrint('ðŸ”— DeepLink: Navigating to /home/player/$vibeId');
      _router!.go('/home/player/$vibeId?fromNotification=true');
    }
  }
  
  /// Navigate to the invite acceptance screen
  void _navigateToInvite(String userId) {
    if (_router != null && userId.isNotEmpty) {
      debugPrint('ðŸ”— DeepLink: Navigating to /home/invite/$userId');
      _router!.go('/home/invite/$userId');
    }
  }

  /// Navigate to the recording screen (Walkie-Talkie mode)
  void _navigateToRecord(String friendId) {
    if (_router != null && friendId.isNotEmpty) {
      debugPrint('ðŸ”— DeepLink: Navigating to /home/record/$friendId');
      _router!.go('/home/record/$friendId');
    }
  }
  
  /// Dispose of the listener
  void dispose() {
    _linkSubscription?.cancel();
  }
}

/// Provider for the deep link service
final deepLinkServiceProvider = Provider<DeepLinkService>((ref) {
  return DeepLinkService();
});



========================================

FILE #20: E:\Vive\lib\core\services\distance_service.dart

========================================


import 'dart:math' as math;
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:geolocator/geolocator.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Location & Distance Service
/// 
/// Competitor Analysis: 73 requests for distance features (especially from LDR couples).
/// This enables the "Distance Badge" on widgets showing how far apart friends are.
/// 
/// Privacy-First Design:
/// - Location is OPTIONAL (off by default)
/// - Only shares with accepted friends
/// - City-level precision (not exact coordinates)
/// - Can disable at any time
class DistanceService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  
  static const String _locationEnabledKey = 'location_sharing_enabled';
  static const String _lastLatKey = 'last_latitude';
  static const String _lastLngKey = 'last_longitude';
  static const String _lastCityKey = 'last_city';
  
  /// Check if user has enabled location sharing
  Future<bool> isLocationSharingEnabled() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(_locationEnabledKey) ?? false;
  }
  
  /// Enable/disable location sharing
  Future<void> setLocationSharing(bool enabled, String userId) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_locationEnabledKey, enabled);
    
    if (enabled) {
      // Update location immediately
      await updateLocation(userId);
    } else {
      // Clear location from Firestore
      await _firestore.collection('users').doc(userId).update({
        'location': FieldValue.delete(),
        'locationUpdatedAt': FieldValue.delete(),
      });
    }
  }
  
  /// Check if location permissions are granted
  Future<bool> checkPermissions() async {
    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        return false;
      }
      
      // Check permission
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          return false;
        }
      }
      
      if (permission == LocationPermission.deniedForever) {
        return false;
      }
      
      return true;
    } catch (e) {
      debugPrint('DistanceService: Error checking permissions: $e');
      return false;
    }
  }
  
  /// Get current position
  Future<Position?> getCurrentPosition() async {
    try {
      final hasPermission = await checkPermissions();
      if (!hasPermission) return null;
      
      // Use low accuracy for privacy (city-level)
      return await Geolocator.getCurrentPosition(
        locationSettings: const LocationSettings(
          accuracy: LocationAccuracy.low, // City-level precision
          distanceFilter: 1000, // Only update if moved 1km+
        ),
      );
    } catch (e) {
      debugPrint('DistanceService: Error getting position: $e');
      return null;
    }
  }
  
  /// Update user's location in Firestore (with privacy rounding)
  Future<bool> updateLocation(String userId) async {
    try {
      final isEnabled = await isLocationSharingEnabled();
      if (!isEnabled) return false;
      
      final position = await getCurrentPosition();
      if (position == null) return false;
      
      // Round to 2 decimal places for privacy (~1km accuracy)
      final roundedLat = (position.latitude * 100).round() / 100;
      final roundedLng = (position.longitude * 100).round() / 100;
      
      // Save locally
      final prefs = await SharedPreferences.getInstance();
      await prefs.setDouble(_lastLatKey, roundedLat);
      await prefs.setDouble(_lastLngKey, roundedLng);
      
      // Update Firestore
      await _firestore.collection('users').doc(userId).update({
        'location': GeoPoint(roundedLat, roundedLng),
        'locationUpdatedAt': FieldValue.serverTimestamp(),
      });
      
      debugPrint('DistanceService: Location updated (${roundedLat}, ${roundedLng})');
      return true;
    } catch (e) {
      debugPrint('DistanceService: Error updating location: $e');
      return false;
    }
  }
  
  /// Calculate distance between two users
  Future<DistanceInfo?> getDistanceBetweenUsers(
    String userId1,
    String userId2,
  ) async {
    try {
      final doc1 = await _firestore.collection('users').doc(userId1).get();
      final doc2 = await _firestore.collection('users').doc(userId2).get();
      
      final data1 = doc1.data();
      final data2 = doc2.data();
      
      if (data1 == null || data2 == null) return null;
      
      final location1 = data1['location'] as GeoPoint?;
      final location2 = data2['location'] as GeoPoint?;
      
      if (location1 == null || location2 == null) return null;
      
      final distanceMeters = Geolocator.distanceBetween(
        location1.latitude,
        location1.longitude,
        location2.latitude,
        location2.longitude,
      );
      
      return DistanceInfo(
        distanceMeters: distanceMeters,
        user1HasLocation: true,
        user2HasLocation: true,
      );
    } catch (e) {
      debugPrint('DistanceService: Error calculating distance: $e');
      return null;
    }
  }
  
  /// Get distance from current user to a friend
  Future<DistanceInfo?> getDistanceToFriend(
    String currentUserId,
    String friendId,
  ) async {
    return getDistanceBetweenUsers(currentUserId, friendId);
  }
  
  /// Get formatted distance string for widget display
  Future<String?> getDistanceLabel(
    String currentUserId,
    String friendId,
  ) async {
    final distance = await getDistanceToFriend(currentUserId, friendId);
    if (distance == null) return null;
    return distance.formattedDistance;
  }
}

/// Distance information model
class DistanceInfo {
  final double distanceMeters;
  final bool user1HasLocation;
  final bool user2HasLocation;
  
  DistanceInfo({
    required this.distanceMeters,
    required this.user1HasLocation,
    required this.user2HasLocation,
  });
  
  /// Distance in kilometers
  double get distanceKm => distanceMeters / 1000;
  
  /// Distance in miles
  double get distanceMiles => distanceMeters / 1609.34;
  
  /// Formatted distance string (auto-selects unit)
  String get formattedDistance {
    if (distanceMeters < 1000) {
      // Less than 1km - show "nearby"
      return 'ðŸ“ Nearby';
    } else if (distanceKm < 10) {
      // Less than 10km
      return 'ðŸ“ ${distanceKm.toStringAsFixed(1)}km';
    } else if (distanceKm < 100) {
      // Less than 100km
      return 'ðŸ“ ${distanceKm.round()}km';
    } else if (distanceMiles < 100) {
      // Use miles for larger distances (US users)
      return 'ðŸ“ ${distanceMiles.round()}mi';
    } else {
      // Very far - just show rounded miles
      return 'ðŸ“ ${(distanceMiles / 100).round() * 100}mi';
    }
  }
  
  /// Short format for widget display
  String get shortFormat {
    if (distanceMeters < 1000) {
      return 'Nearby';
    } else if (distanceKm < 100) {
      return '${distanceKm.round()}km';
    } else {
      return '${distanceMiles.round()}mi';
    }
  }
  
  /// Check if users are "close" (within 50km)
  bool get isClose => distanceKm < 50;
  
  /// Check if users are in same city (within 10km)
  bool get isSameCity => distanceKm < 10;
  
  /// Check if it's a long-distance relationship (>500km)
  bool get isLongDistance => distanceKm > 500;
}

/// Provider for DistanceService
final distanceServiceProvider = Provider<DistanceService>((ref) {
  return DistanceService();
});

/// Provider for location sharing enabled state
final locationSharingEnabledProvider = FutureProvider<bool>((ref) async {
  final service = ref.watch(distanceServiceProvider);
  return service.isLocationSharingEnabled();
});

/// State notifier for managing location settings
class LocationSettingsNotifier extends StateNotifier<LocationSettingsState> {
  final DistanceService _service;
  final String _userId;
  
  LocationSettingsNotifier(this._service, this._userId)
      : super(const LocationSettingsState()) {
    _loadInitialState();
  }
  
  Future<void> _loadInitialState() async {
    final isEnabled = await _service.isLocationSharingEnabled();
    final hasPermission = await _service.checkPermissions();
    
    state = state.copyWith(
      isEnabled: isEnabled,
      hasPermission: hasPermission,
      isLoading: false,
    );
  }
  
  Future<void> toggleLocationSharing() async {
    if (state.isLoading) return;
    
    state = state.copyWith(isLoading: true);
    
    // If enabling, check permissions first
    if (!state.isEnabled && !state.hasPermission) {
      final hasPermission = await _service.checkPermissions();
      if (!hasPermission) {
        state = state.copyWith(
          isLoading: false,
          error: 'Location permission denied',
        );
        return;
      }
      state = state.copyWith(hasPermission: true);
    }
    
    // Toggle the setting
    final newEnabled = !state.isEnabled;
    await _service.setLocationSharing(newEnabled, _userId);
    
    state = state.copyWith(
      isEnabled: newEnabled,
      isLoading: false,
      error: null,
    );
  }
  
  Future<void> updateLocation() async {
    if (!state.isEnabled) return;
    
    state = state.copyWith(isUpdating: true);
    await _service.updateLocation(_userId);
    state = state.copyWith(isUpdating: false);
  }
  
  void clearError() {
    state = state.copyWith(error: null);
  }
}

/// State for location settings
class LocationSettingsState {
  final bool isEnabled;
  final bool hasPermission;
  final bool isLoading;
  final bool isUpdating;
  final String? error;
  
  const LocationSettingsState({
    this.isEnabled = false,
    this.hasPermission = false,
    this.isLoading = true,
    this.isUpdating = false,
    this.error,
  });
  
  LocationSettingsState copyWith({
    bool? isEnabled,
    bool? hasPermission,
    bool? isLoading,
    bool? isUpdating,
    String? error,
  }) {
    return LocationSettingsState(
      isEnabled: isEnabled ?? this.isEnabled,
      hasPermission: hasPermission ?? this.hasPermission,
      isLoading: isLoading ?? this.isLoading,
      isUpdating: isUpdating ?? this.isUpdating,
      error: error,
    );
  }
}

/// Family provider for location settings
final locationSettingsProvider = StateNotifierProvider.family<
    LocationSettingsNotifier, LocationSettingsState, String>((ref, userId) {
  final service = ref.watch(distanceServiceProvider);
  return LocationSettingsNotifier(service, userId);
});

/// Provider for distance to a specific friend
final distanceToFriendProvider =
    FutureProvider.family<DistanceInfo?, ({String userId, String friendId})>(
        (ref, params) async {
  final service = ref.watch(distanceServiceProvider);
  return service.getDistanceToFriend(params.userId, params.friendId);
});



========================================

FILE #21: E:\Vive\lib\core\services\fcm_token_service.dart

========================================


import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:go_router/go_router.dart';

/// FCM Token Service
/// 
/// Manages FCM (Firebase Cloud Messaging) tokens for push notifications.
/// Tokens are saved to Firestore so Cloud Functions can send targeted pushes.
class FCMTokenService {
  final FirebaseMessaging _messaging = FirebaseMessaging.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;
  
  GoRouter? _router;

  /// Initialize FCM and save token
  /// Pass router for navigation when user taps notification
  Future<void> initialize({GoRouter? router}) async {
    _router = router;
    
    // Listen for token refresh
    _messaging.onTokenRefresh.listen(_saveTokenToFirestore);

    // Get current token and save
    final token = await getToken();
    if (token != null) {
      await _saveTokenToFirestore(token);
    }

    // Handle foreground messages
    FirebaseMessaging.onMessage.listen(_handleForegroundMessage);
    
    // FIX #1: Handle notification clicks when app is in background/terminated
    // This enables Deep Link from Notification â†’ Player Screen
    FirebaseMessaging.onMessageOpenedApp.listen(_handleNotificationClick);
    
    // FIX #1b: Handle cold start from notification (app was terminated)
    final initialMessage = await _messaging.getInitialMessage();
    if (initialMessage != null) {
      debugPrint('FCMTokenService: App opened from terminated state via notification');
      _handleNotificationClick(initialMessage);
    }
  }
  
  /// Handle notification click - Navigate to appropriate screen
  void _handleNotificationClick(RemoteMessage message) {
    debugPrint('FCMTokenService: Notification clicked');
    debugPrint('  Data: ${message.data}');
    
    if (_router == null) {
      debugPrint('FCMTokenService: Router not available, cannot navigate');
      return;
    }
    
    final messageType = message.data['type'];
    final vibeId = message.data['vibeId'];
    
    switch (messageType) {
      case 'NEW_VIBE':
      case 'WIDGET_UPDATE':
        // Navigate directly to player screen with fromNotification=true
        if (vibeId != null && vibeId.isNotEmpty) {
          debugPrint('FCMTokenService: Navigating to /player/$vibeId');
          _router!.go('/player/$vibeId?fromNotification=true');
        }
        break;
        
        
      default:
        debugPrint('FCMTokenService: Unknown type, going home');
        _router!.go('/home');
    }
  }

  /// Save FCM token to user's Firestore document
  /// 2025 BEST PRACTICE: Check-then-Sync to avoid redundant writes
  Future<void> _saveTokenToFirestore(String? token) async {
    if (token == null || token.isEmpty) return;

    final user = _auth.currentUser;
    if (user == null) {
      debugPrint('FCMTokenService: No user signed in, cannot save token');
      return;
    }

    try {
      // 1. Fetch current document to check if sync is actually needed
      final doc = await _firestore.collection('users').doc(user.uid).get();
      
      if (doc.exists) {
        final data = doc.data();
        final currentToken = data?['fcmToken'] as String?;
        final lastUpdated = data?['fcmTokenUpdatedAt'] as Timestamp?;
        
        // 2. Only update if token changed OR sync is older than 30 days
        bool needsSync = currentToken != token;
        
        if (!needsSync && lastUpdated != null) {
          final thirtyDaysAgo = DateTime.now().subtract(const Duration(days: 30));
          if (lastUpdated.toDate().isBefore(thirtyDaysAgo)) {
            needsSync = true;
          }
        }

        if (!needsSync) {
          debugPrint('FCMTokenService: Token already synced and fresh, skipping write');
          return;
        }

        await _firestore.collection('users').doc(user.uid).update({
          'fcmToken': token,
          'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),
        });
      } else {
        // Document doesn't exist, create it
        await _firestore.collection('users').doc(user.uid).set({
          'fcmToken': token,
          'fcmTokenUpdatedAt': FieldValue.serverTimestamp(),
        }, SetOptions(merge: true));
      }
      
      debugPrint('FCMTokenService: Token successfully synced for user ${user.uid}');
    } catch (e) {
      debugPrint('FCMTokenService: Error syncing token: $e');
    }
  }

  /// Get current FCM token
  /// 2025 BEST PRACTICE: Graceful handling of registration limits
  Future<String?> getToken() async {
    try {
      return await _messaging.getToken();
    } catch (e) {
      final errorStr = e.toString().toUpperCase();
      
      if (errorStr.contains('TOO_MANY_REGISTRATIONS')) {
        debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        debugPrint('CRITICAL: FCM Registration Limit Reached (TOO_MANY_REGISTRATIONS)');
        debugPrint('This usually happens on Emulators with stale data.');
        debugPrint('FIX: Wipe Data on your Android Emulator (AVD Manager -> Wipe Data)');
        debugPrint('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
      } else {
        debugPrint('FCMTokenService: getToken error: $e');
      }
      return null;
    }
  }

  /// Handle foreground messages (app is open)
  void _handleForegroundMessage(RemoteMessage message) {
    debugPrint('FCMTokenService: Foreground message received');
    debugPrint('  Data: ${message.data}');
    
    final messageType = message.data['type'];
    
    switch (messageType) {
      case 'WIDGET_UPDATE':
        // Update widget even when app is open
        debugPrint('FCMTokenService: Widget update received in foreground');
        // Widget is already synced via Firestore listener when app is open
        break;
        
        
      default:
        debugPrint('FCMTokenService: Unknown message type: $messageType');
    }
  }

  /// Delete token on logout
  Future<void> deleteToken() async {
    final user = _auth.currentUser;
    if (user != null) {
      try {
        await _firestore.collection('users').doc(user.uid).update({
          'fcmToken': FieldValue.delete(),
        });
      } catch (e) {
        debugPrint('FCMTokenService: Error deleting token: $e');
      }
    }
    
    // Also delete from FCM
    await _messaging.deleteToken();
  }

  /// Check notification permission status
  Future<AuthorizationStatus> getPermissionStatus() async {
    final settings = await _messaging.getNotificationSettings();
    return settings.authorizationStatus;
  }

  /// Request notification permissions
  Future<bool> requestPermission() async {
    final settings = await _messaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
      criticalAlert: false,
      announcement: false,
      carPlay: false,
    );
    
    return settings.authorizationStatus == AuthorizationStatus.authorized ||
           settings.authorizationStatus == AuthorizationStatus.provisional;
  }
}

/// FCM Token Service Provider
final fcmTokenServiceProvider = Provider<FCMTokenService>((ref) {
  return FCMTokenService();
});



========================================

FILE #22: E:\Vive\lib\core\services\gatekeeper_service.dart

========================================


import 'dart:async';
import 'dart:io';
import 'package:ffmpeg_kit_flutter_new_https/ffmpeg_kit.dart';
import 'package:ffmpeg_kit_flutter_new_https/return_code.dart';
import 'package:path_provider/path_provider.dart';
import 'package:vad/vad.dart';
import 'package:flutter/foundation.dart';

/// Gatekeeper Service - Local Voice Activity Detection (VAD)
/// 
/// POLICY: FAIL-CLOSED
/// If audio is corrupt, silent, or fails processing, this service returns NULL.
/// We do NOT upload garbage to the server. This protects:
/// 1. Backend stability (no corrupt files)
/// 2. OpenAI costs (no empty transcription requests)
/// 3. Data integrity (consistent format across all uploads)
class GatekeeperService {
  static final GatekeeperService instance = GatekeeperService._();
  GatekeeperService._();

  /// ðŸ›¡ï¸ The Bouncer: Fail-Closed Voice Detection
  /// 
  /// Returns [File] (WAV) if human speech is detected.
  /// Returns [null] if silent, noisy, or verification fails.
  /// 
  /// Technical fixes applied:
  /// - FIX 1: `-c:a pcm_s16le` forces 16-bit Integer codec (prevents "Robot Noise" on iOS/Android)
  /// - FIX 2: `frameSamples: 512` syncs with our 1024-byte chunks (prevents "Skipped Frame" bug)
  /// - FIX 3: `executeAsync` prevents UI jank during compression
  Future<File?> hasSpeech(File mediaFile, {bool isVideo = false}) async {
    final tempDir = await getTemporaryDirectory();
    final String sessionKey = DateTime.now().millisecondsSinceEpoch.toString();
    final File wavFile = File('${tempDir.path}/gatekeeper_$sessionKey.wav');
    
    // Resource Management: Create handler here for safe disposal in finally block
    final VadHandler vadHandler = VadHandler.create(isDebug: kDebugMode);
    StreamSubscription? vadSubscription;

    try {
      // ---------------------------------------------------------
      // STEP 1: Robust Normalization (FFmpeg)
      // ---------------------------------------------------------
      // -vn          : Disable video (extract audio only)
      // -ar 16000    : Resample to 16kHz (REQUIRED by Silero VAD)
      // -ac 1        : Downmix to Mono (REQUIRED by Silero VAD)
      // -c:a pcm_s16le : FORCE 16-bit Signed Integer Little Endian
      //                  (CRITICAL: Prevents 32-bit float output on iOS)
      // -y           : Overwrite output file if exists
      // ---------------------------------------------------------
      final command = '-y -hwaccel auto -i "${mediaFile.path}" -vn -ar 16000 -ac 1 -c:a pcm_s16le "${wavFile.path}"';
      
      // FIX: Use executeAsync to prevent UI thread blocking on heavy files
      final ffmpegCompleter = Completer<bool>();
      
      await FFmpegKit.executeAsync(command, (session) async {
        final returnCode = await session.getReturnCode();
        if (ReturnCode.isSuccess(returnCode)) {
          ffmpegCompleter.complete(true);
        } else {
          final logs = await session.getLogs();
          final lastLog = logs.isNotEmpty ? logs.last.getMessage() : 'No logs';
          debugPrint('Gatekeeper: FFmpeg failed. Code: $returnCode, Last log: $lastLog');
          ffmpegCompleter.complete(false);
        }
      });

      // FAIL-CLOSED: If FFmpeg fails, reject the file to protect backend
      if (!await ffmpegCompleter.future) {
        debugPrint('Gatekeeper: Normalization failed. Rejecting upload (Fail-Closed).');
        return null;
      }

      // ---------------------------------------------------------
      // STEP 2: Binary Validation (Isolate-offloaded)
      // ---------------------------------------------------------
      if (!await wavFile.exists()) return null;
      
      // FIX: Offload heavy file reading and sublisting to background isolate
      // This prevents the main thread from stalling on massive audio buffers
      final List<Uint8List> chunks = await compute(_chunkFileIsolate, wavFile.path);
      
      if (chunks.isEmpty) {
        debugPrint('Gatekeeper: WAV file empty or too small.');
        try { await wavFile.delete(); } catch (_) {}
        return null;
      }

      // ---------------------------------------------------------
      // STEP 3: VAD Analysis (Synchronized Frame Processing)
      // ---------------------------------------------------------
      final detectionCompleter = Completer<bool>();
      bool hasSpeech = false;

      // OPTIMIZATION: Early exit - stop immediately upon first speech detection
      vadSubscription = vadHandler.onSpeechStart.listen((_) {
        if (!hasSpeech) {
          hasSpeech = true;
          debugPrint('Gatekeeper: Speech detected! Early exit.');
          if (!detectionCompleter.isCompleted) detectionCompleter.complete(true);
        }
      });

      // Chunk size: 1024 bytes = 512 samples (16-bit = 2 bytes/sample)
      // This matches Silero VAD v5 requirements for 16kHz audio
      final audioStream = Stream<Uint8List>.fromIterable(chunks);

      await vadHandler.startListening(
        audioStream: audioStream,
        // CRITICAL FIX: Explicitly tell VAD we are sending 512 samples/chunk
        // Default is often 1536 (legacy), which would BREAK this stream
        frameSamples: 512,
        recordConfig: const RecordConfig(
          sampleRate: 16000,
          numChannels: 1,
          encoder: AudioEncoder.pcm16bits,
        ),
      );

      // TIMEOUT: 2x Duration Safety Buffer
      // Prevents hanging on slow devices or edge cases
      // Logic: Duration(ms) = (Bytes / 32) * 2 (Safety Factor) + 500ms buffer
      final totalBytes = chunks.fold<int>(0, (sum, chunk) => sum + chunk.length);
      final processingTimeout = Duration(milliseconds: (totalBytes / 16).ceil() + 500);
      
      try {
        await Future.any([
          detectionCompleter.future,
          Future.delayed(processingTimeout, () => false),
        ]);
      } catch (e) {
        debugPrint('Gatekeeper: VAD timeout or error: $e');
      }

      await vadHandler.stopListening();

      debugPrint('Gatekeeper: Speech detected = $hasSpeech');

      if (hasSpeech) {
        return wavFile; // âœ… Verified Speech - caller owns this file now
      } else {
        // Cleanup silent/rejected file to save storage
        try { await wavFile.delete(); } catch (_) {}
        return null; // ðŸ›‘ Fail-Closed: No speech detected
      }

    } catch (e) {
      debugPrint('Gatekeeper: Critical Error: $e');
      // Ensure temp file is cleaned up on crash
      try { if (await wavFile.exists()) await wavFile.delete(); } catch (_) {}
      return null; // ðŸ›‘ Fail-Closed on Exception
    } finally {
      // Resource Safety: Always dispose native resources
      await vadSubscription?.cancel();
      vadHandler.dispose();
    }
  }
}

/// FIX: Global static helper for 'compute' compatibility
/// Offloads binary I/O to background isolate
List<Uint8List> _chunkFileIsolate(String path) {
  try {
    final file = File(path);
    final bytes = file.readAsBytesSync();
    
    // Validate standard WAV header (44 bytes)
    if (bytes.length <= 44 + 3200) { // 44 header + 0.1s data
      return [];
    }
    
    // Extract Raw PCM Data (Skip WAV Header)
    final Uint8List audioBytes = bytes.sublist(44);
    
    // Chunk size: 1024 bytes = 512 samples
    final List<Uint8List> chunks = [];
    const int chunkSize = 1024;
    
    for (int i = 0; i < audioBytes.length; i += chunkSize) {
      int end = (i + chunkSize < audioBytes.length) ? i + chunkSize : audioBytes.length;
      chunks.add(audioBytes.sublist(i, end));
    }
    
    return chunks;
  } catch (e) {
    debugPrint('Gatekeeper: Isolate I/O error: $e');
    return [];
  }
}



========================================

FILE #23: E:\Vive\lib\core\services\invite_service.dart

========================================


import 'dart:async';
import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:appinio_social_share/appinio_social_share.dart';
import 'package:flutter/services.dart';
import '../theme/app_colors.dart';

/// Invite Service - The "Visual Invite" Engine
/// 
/// Based on competitor analysis (Locket, NoteIt, Widgetable):
/// - Visual invites (images/videos) outperform text links
/// - Story-ready 9:16 content gets higher engagement
/// - Deep links should be attached as stickers
/// 
/// Strategy:
/// 1. Generate a beautiful "Invite Card" with user's Aura
/// 2. Share to Instagram Stories, Snapchat, WhatsApp, SMS
/// 3. Include personalized deep link for tracking
class InviteService {
  final AppinioSocialShare _socialShare = AppinioSocialShare();
  
  // Your app's store URLs (replace with actual)
  static const String appStoreUrl = 'https://apps.apple.com/app/nock/id0000000000';
  static const String playStoreUrl = 'https://play.google.com/store/apps/details?id=com.nock.nock';
  
  // --------------------------
  // INVITE LINK STRATEGY
  // --------------------------
  // 
  // CURRENT (MVP): Using custom scheme nock://
  //   + Works if app is installed
  //   - NOT clickable on Instagram, TikTok, WhatsApp (shows as plain text)
  //   - Shows error if app not installed
  //
  // FOR PRODUCTION: Switch to HTTPS with Universal Links
  //   Option A: Use your own domain (e.g., https://getvibe.app/invite/)
  //     - Requires AASA file on server
  //     - Requires Associated Domains entitlement
  //   
  //   Option B: Use Firebase Dynamic Links (deprecated) or Branch.io
  //     - Handles app-not-installed gracefully (redirects to store)
  //     - Links are clickable on all social platforms
  //     - Provides analytics
  //
  // TODO: For production, replace nock:// with https:// and set up
  // Universal Links (iOS) + App Links (Android)
  // DEFERRED LINK STRATEGY: Use a Universal Link (HTTPS) as the base.
  // This ensures links are clickable on Instagram/WhatsApp and provides
  // a bridge for users who don't have the app installed yet.
  static const String webInviteBaseUrl = 'https://getnock.app/i/';
  
  /// Generate a personalized invite link
  /// Format: nock://invite/USERID (matches document ID in Firestore)
  /// Generate a personalized invite link
  /// Format: https://getvibe.app/i/USERID
  /// ALSO: Copies to clipboard to support the "Clipboard Bridge" for new users!
  Future<String> generateInviteLink(String userId) async {
    final link = '$webInviteBaseUrl$userId';
    await copyInviteLink(link); // Force copy to clipboard for deferred linking
    return link;
  }
  
  /// Get the appropriate store URL for the current platform
  String getStoreUrl() {
    return Platform.isIOS ? appStoreUrl : playStoreUrl;
  }
  
  /// Generate the default invite message with CLICKABLE store link
  /// Note: nock:// links are NOT clickable in WhatsApp/SMS
  /// So we use the store URL which IS clickable
  String generateInviteMessage({
    required String senderName,
    String? customMessage,
    String? userId,
  }) {
    if (customMessage != null && customMessage.isNotEmpty) {
      return customMessage;
    }
    
    // Use store URL (clickable) instead of custom scheme (not clickable)
    final storeLink = getStoreUrl();
    
    return '''ðŸŽ™ï¸ $senderName invited you to Nock!

Nock lets you send voice messages right to your friends' home screen ðŸ’«

Download now: $storeLink''';
  }
  
  /// Share invite via Instagram Stories (most viral!)
  /// API: shareToInstagramStory(appId, {stickerImage, backgroundImage, ...})
  /// Returns true only if Instagram actually opened
  Future<bool> shareToInstagramStory({
    required String imagePath,
    String? senderName,
    String? facebookAppId,
  }) async {
    try {
      final appId = facebookAppId ?? 'YOUR_FB_APP_ID';
      String? result;
      
      if (Platform.isAndroid) {
        result = await _socialShare.android.shareToInstagramStory(
          appId,
          stickerImage: imagePath,
          backgroundTopColor: '#0A0A0A',
          backgroundBottomColor: '#1A1A2E',
          attributionURL: getStoreUrl(),
        );
      } else if (Platform.isIOS) {
        result = await _socialShare.iOS.shareToInstagramStory(
          appId,
          stickerImage: imagePath,
          backgroundTopColor: '#0A0A0A',
          backgroundBottomColor: '#1A1A2E',
          attributionURL: getStoreUrl(),
        );
      }
      
      // appinio_social_share returns non-empty string on success
      final success = result != null && result.isNotEmpty;
      debugPrint('InviteService: Instagram Story result: $result, success: $success');
      return success;
    } catch (e) {
      debugPrint('InviteService: Instagram Story share failed: $e');
      return false;
    }
  }
  
  /// Share invite via Instagram DM / Feed
  /// Android: shareToInstagramFeed(message, filePath)
  /// iOS: shareToInstagramFeed(imagePath) - only path
  /// Returns true only if Instagram opened, false triggers system share fallback
  Future<bool> shareToInstagramDm({
    required String imagePath,
    required String message,
  }) async {
    try {
      String? result;
      if (Platform.isAndroid) {
        result = await _socialShare.android.shareToInstagramFeed(message, imagePath);
      } else if (Platform.isIOS) {
        result = await _socialShare.iOS.shareToInstagramFeed(imagePath);
      }
      
      final success = result != null && result.isNotEmpty;
      debugPrint('InviteService: Instagram Feed result: $result, success: $success');
      
      if (!success) {
        // Instagram not installed - use system share
        debugPrint('InviteService: Instagram not available, using system share');
        return await shareToSystem(imagePath: imagePath, message: message);
      }
      return true;
    } catch (e) {
      debugPrint('InviteService: Instagram share failed: $e');
      // Fallback to system share - tell caller it was a fallback
      return await shareToSystem(imagePath: imagePath, message: message);
    }
  }
  
  /// Share invite via Snapchat (uses system share - no direct API)
  Future<bool> shareToSnapchat({
    required String imagePath,
    String? message,
  }) async {
    try {
      await Share.shareXFiles(
        [XFile(imagePath)],
        text: message ?? 'Join me on Nock! ðŸŽ™ï¸',
      );
      return true;
    } catch (e) {
      debugPrint('InviteService: Snapchat share failed: $e');
      return false;
    }
  }
  
  /// Share invite via WhatsApp
  /// Android: shareToWhatsapp(message, filePath) - supports file
  /// iOS: shareImageToWhatsApp(imagePath) - image only
  /// Returns true only if WhatsApp opened
  Future<bool> shareToWhatsApp({
    required String imagePath,
    required String message,
  }) async {
    try {
      String? result;
      if (Platform.isAndroid) {
        // Android supports message + file
        result = await _socialShare.android.shareToWhatsapp(message, imagePath);
      } else {
        // iOS: Use shareImageToWhatsApp for image sharing
        result = await _socialShare.iOS.shareImageToWhatsApp(imagePath);
      }
      
      final success = result != null && result.isNotEmpty;
      debugPrint('InviteService: WhatsApp result: $result, success: $success');
      
      if (!success) {
        debugPrint('InviteService: WhatsApp not available, using system share');
        return await shareToSystem(imagePath: imagePath, message: message);
      }
      return true;
    } catch (e) {
      debugPrint('InviteService: WhatsApp share failed: $e');
      // Fallback to system share
      return await shareToSystem(imagePath: imagePath, message: message);
    }
  }
  
  /// Share invite via SMS/Messages
  /// If recipientPhone is provided, opens SMS directly to that contact
  Future<bool> shareToMessages({
    required String message,
    String? imagePath,
    String? recipientPhone,
  }) async {
    try {
      // If we have a specific recipient, open SMS directly
      if (recipientPhone != null && recipientPhone.isNotEmpty) {
        final encodedMessage = Uri.encodeComponent(message);
        final cleanPhone = recipientPhone.replaceAll(RegExp(r'[^\d+]'), '');
        
        // Use sms: URI scheme - works on both iOS and Android
        // Format: sms:+1234567890?body=Hello%20World
        final smsUri = Uri.parse('sms:$cleanPhone?body=$encodedMessage');
        
        // Use platform's default SMS app
        if (Platform.isIOS) {
          // iOS requires & instead of ? for additional params
          final iosSmsUri = Uri.parse('sms:$cleanPhone&body=$encodedMessage');
          await Share.share(message); // Fallback - iOS doesn't always support body in sms:
          debugPrint('InviteService: SMS to $cleanPhone opened via share');
        } else {
          // Android handles sms: URI well
          await Share.share(message);
        }
        return true;
      }
      
      // Generic share (no specific recipient)
      if (imagePath != null) {
        await Share.shareXFiles(
          [XFile(imagePath)],
          text: message,
        );
      } else {
        await Share.share(message);
      }
      return true;
    } catch (e) {
      debugPrint('InviteService: Messages share failed: $e');
      return false;
    }
  }
  
  /// Share invite via Messenger
  /// IMPORTANT: shareToMessenger only takes (String message) - no file support!
  /// We use system share for file + message - opens native share sheet
  Future<bool> shareToMessenger({
    required String imagePath,
    required String message,
  }) async {
    try {
      // Messenger API only supports text, use system share for image
      // This opens the native share sheet where user can select Messenger
      return await shareToSystem(imagePath: imagePath, message: message);
    } catch (e) {
      debugPrint('InviteService: Messenger share failed: $e');
      return false;
    }
  }
  
  /// Share invite via Telegram  
  /// Android: shareToTelegram(message, filePath) - supports file
  /// iOS: Uses system share (Telegram API only supports text on iOS)
  Future<bool> shareToTelegram({
    required String imagePath,
    required String message,
  }) async {
    try {
      if (Platform.isAndroid) {
        // Android supports message + file
        final result = await _socialShare.android.shareToTelegram(message, imagePath);
        final success = result != null && result.isNotEmpty;
        debugPrint('InviteService: Telegram result: $result, success: $success');
        
        if (!success) {
          debugPrint('InviteService: Telegram not available, using system share');
          return await shareToSystem(imagePath: imagePath, message: message);
        }
        return true;
      } else {
        // iOS only supports text - use system share for files
        return await shareToSystem(imagePath: imagePath, message: message);
      }
    } catch (e) {
      debugPrint('InviteService: Telegram share failed: $e');
      return await shareToSystem(imagePath: imagePath, message: message);
    }
  }
  
  /// System share sheet (ultimate fallback - uses share_plus)
  Future<bool> shareToSystem({
    String? imagePath,
    required String message,
  }) async {
    try {
      if (imagePath != null) {
        await Share.shareXFiles(
          [XFile(imagePath)],
          text: message,
          subject: 'Join me on Nock!',
        );
      } else {
        await Share.share(message, subject: 'Join me on Nock!');
      }
      return true;
    } catch (e) {
      debugPrint('InviteService: System share failed: $e');
      return false;
    }
  }
  
  /// Copy invite link to clipboard
  /// This is CRITICAL for the "Clipboard Bridge" deferred deep link strategy.
  /// When a new user installs the app, we check the clipboard for this link.
  Future<void> copyInviteLink(String link) async {
    try {
      await Clipboard.setData(ClipboardData(text: link));
      debugPrint('InviteService: Link copied to clipboard for bridge: $link');
    } catch (e) {
      debugPrint('InviteService: Failed to copy link: $e');
    }
  }
}

/// Visual Invite Card Generator
/// 
/// Creates beautiful 9:16 story-ready images for sharing.
/// Based on competitor analysis: Visual invites >> Text links
class InviteCardGenerator {
  /// Generate an invite card widget (to be captured as image)
  static Widget buildInviteCard({
    required String senderName,
    required String username,
    String? avatarUrl,
    Color primaryColor = AppColors.bioLime,
    Color secondaryColor = AppColors.digitalLavender,
  }) {
    return LayoutBuilder(
      builder: (context, constraints) {
        // RESPONSIVE FIX: Use scale factor instead of hardcoded 1080x1920
        // Baseline width is 360 (standard mobile logical width)
        final scale = constraints.maxWidth / 360;

        return AspectRatio(
          aspectRatio: 9 / 16,
          child: Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: [
                  AppColors.background,
                  AppColors.surfaceLight,
                  AppColors.backgroundAlt,
                ],
              ),
            ),
            child: Stack(
              alignment: Alignment.center,
              children: [
                // Background effects
                _buildBackgroundEffects(primaryColor, secondaryColor, scale),
                
                // Main content
                Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Spacer(flex: 2),
                    
                    // "Aura" glow effect + Avatar
                    Container(
                      width: 100 * scale,
                      height: 100 * scale,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(
                            color: primaryColor.withOpacity(0.3),
                            blurRadius: 30 * scale,
                            spreadRadius: 15 * scale,
                          ),
                          BoxShadow(
                            color: secondaryColor.withOpacity(0.2),
                            blurRadius: 50 * scale,
                            spreadRadius: 10 * scale,
                          ),
                        ],
                      ),
                      child: Container(
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          gradient: LinearGradient(
                            begin: Alignment.topLeft,
                            end: Alignment.bottomRight,
                            colors: [
                              primaryColor.withOpacity(0.2),
                              secondaryColor.withOpacity(0.2),
                            ],
                          ),
                          border: Border.all(
                            color: primaryColor.withOpacity(0.5),
                            width: 1 * scale,
                          ),
                        ),
                        child: ClipOval(
                          child: avatarUrl != null && avatarUrl.isNotEmpty
                              ? Image.network(
                                  avatarUrl,
                                  fit: BoxFit.cover,
                                  width: 98 * scale,
                                  height: 98 * scale,
                                  errorBuilder: (context, error, stackTrace) {
                                    return Center(
                                      child: Text(
                                        senderName.isNotEmpty ? senderName[0].toUpperCase() : 'V',
                                        style: TextStyle(
                                          fontSize: 40 * scale,
                                          fontWeight: FontWeight.bold,
                                          color: Colors.white,
                                          shadows: [
                                            Shadow(
                                              color: primaryColor,
                                              blurRadius: 10 * scale,
                                            ),
                                          ],
                                        ),
                                      ),
                                    );
                                  },
                                )
                              : Center(
                                  child: Text(
                                    senderName.isNotEmpty ? senderName[0].toUpperCase() : 'V',
                                    style: TextStyle(
                                      fontSize: 40 * scale,
                                      fontWeight: FontWeight.bold,
                                      color: Colors.white,
                                      shadows: [
                                        Shadow(
                                          color: primaryColor,
                                          blurRadius: 10 * scale,
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                        ),
                      ),
                    ),
                    
                    SizedBox(height: 12 * scale),
                    
                    // Sender name
                    Text(
                      senderName,
                      style: TextStyle(
                        fontSize: 16 * scale,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                        letterSpacing: 0.3 * scale,
                      ),
                    ),
                    
                    SizedBox(height: 4 * scale),
                    
                    // Invite text
                    Text(
                      'wants to send you Vibes',
                      style: TextStyle(
                        fontSize: 9 * scale,
                        color: Colors.white.withOpacity(0.8),
                      ),
                    ),
                    
                    const Spacer(flex: 1),
                    
                    // Call to action
                    Container(
                      padding: EdgeInsets.symmetric(
                        horizontal: 14 * scale, 
                        vertical: 6 * scale
                      ),
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          colors: [primaryColor, secondaryColor],
                        ),
                        borderRadius: BorderRadius.circular(16 * scale),
                        boxShadow: [
                          BoxShadow(
                            color: primaryColor.withOpacity(0.5),
                            blurRadius: 10 * scale,
                            spreadRadius: 2 * scale,
                          ),
                        ],
                      ),
                      child: Text(
                        'Download Vibe',
                        style: TextStyle(
                          fontSize: 11 * scale,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                    ),
                    
                    SizedBox(height: 8 * scale),
                    
                    // Username/link indicator
                    Container(
                      padding: EdgeInsets.symmetric(
                        horizontal: 8 * scale, 
                        vertical: 4 * scale
                      ),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(6 * scale),
                      ),
                      child: Text(
                        'nock://invite/${username.length > 12 ? username.substring(0, 12) : username}...',
                        style: TextStyle(
                          fontSize: 7 * scale,
                          color: Colors.white.withOpacity(0.7),
                          fontFamily: 'monospace',
                        ),
                      ),
                    ),
                    
                    const Spacer(flex: 2),
                    
                    // Bottom branding
                    Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          'ðŸŽ¤',
                          style: TextStyle(fontSize: 11 * scale),
                        ),
                        SizedBox(width: 4 * scale),
                        Text(
                          'NOCK',
                          style: TextStyle(
                            fontSize: 8 * scale,
                            fontWeight: FontWeight.bold,
                            color: primaryColor,
                            letterSpacing: 2 * scale,
                          ),
                        ),
                      ],
                    ),
                    
                    SizedBox(height: 20 * scale),
                  ],
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  static Widget _buildBackgroundEffects(Color primary, Color secondary, double scale) {
    return Stack(
      children: [
        // Top-left glow
        Positioned(
          top: -30 * scale,
          left: -30 * scale,
          child: Container(
            width: 130 * scale,
            height: 130 * scale,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: RadialGradient(
                colors: [
                  primary.withOpacity(0.3),
                  primary.withOpacity(0.0),
                ],
              ),
            ),
          ),
        ),
        // Bottom-right glow
        Positioned(
          bottom: -30 * scale,
          right: -30 * scale,
          child: Container(
            width: 170 * scale,
            height: 170 * scale,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: RadialGradient(
                colors: [
                  secondary.withOpacity(0.2),
                  secondary.withOpacity(0.0),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
  
  /// Capture the invite card as an image using the widget tree
  /// Falls back to offscreen rendering if widget is not painted
  static Future<File?> captureInviteCard({
    required GlobalKey cardKey,
    double pixelRatio = 2.0,
  }) async {
    try {
      // Wait for multiple frames to ensure painting is complete
      for (int i = 0; i < 3; i++) {
        await Future.delayed(const Duration(milliseconds: 100));
        await _waitForNextFrame();
      }
      
      final context = cardKey.currentContext;
      if (context == null) {
        debugPrint('InviteCardGenerator: Card context is null');
        return null;
      }
      
      RenderRepaintBoundary? boundary;
      try {
        boundary = context.findRenderObject() as RenderRepaintBoundary?;
      } catch (e) {
        debugPrint('InviteCardGenerator: Cannot find RenderRepaintBoundary: $e');
        return null;
      }
      
      if (boundary == null) {
        debugPrint('InviteCardGenerator: Boundary is null');
        return null;
      }
      
      // If still needs paint after waiting, try forcing layout
      if (boundary.debugNeedsPaint) {
        debugPrint('InviteCardGenerator: Forcing layout...');
        
        // Force a layout pass
        (context as Element).markNeedsBuild();
        await _waitForNextFrame();
        await Future.delayed(const Duration(milliseconds: 300));
        await _waitForNextFrame();
      }
      
      // Final attempt - capture anyway (may work in release mode)
      // debugNeedsPaint only fires in debug mode
      try {
        ui.Image image = await boundary.toImage(pixelRatio: pixelRatio);
        final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
        if (byteData == null) {
          debugPrint('InviteCardGenerator: byteData is null');
          return null;
        }
        final pngBytes = byteData.buffer.asUint8List();
        
        final tempDir = await getTemporaryDirectory();
        final timestamp = DateTime.now().millisecondsSinceEpoch;
        final file = File('${tempDir.path}/vibe_invite_$timestamp.png');
        await file.writeAsBytes(pngBytes);
        
        debugPrint('InviteCardGenerator: Card captured successfully');
        return file;
      } catch (e) {
        debugPrint('InviteCardGenerator: Capture failed: $e');
        // This is expected in debug mode if widget is still painting
        // In release mode, this typically works
        return null;
      }
    } catch (e) {
      debugPrint('InviteCardGenerator: Failed to capture card: $e');
      return null;
    }
  }
  
  /// Helper to wait for next frame
  static Future<void> _waitForNextFrame() async {
    final completer = Completer<void>();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      completer.complete();
    });
    return completer.future;
  }
  
  /// Render invite card offscreen using Canvas (doesn't require widget tree)
  /// This is a fallback when widget-based capture fails
  static Future<File?> renderInviteCardOffscreen({
    required String senderName,
    required String username,
    String? avatarUrl,
    Color primaryColor = AppColors.bioLime,
    Color secondaryColor = AppColors.digitalLavender,
    double pixelRatio = 2.0,
    double width = 1080,
    double height = 1920,
  }) async {
    try {
      debugPrint('InviteCardGenerator: Using canvas-based rendering...');
      
      final scale = width / 1080; // Baseline width for scaling
      
      // Create a picture recorder and canvas
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder, Rect.fromLTWH(0, 0, width, height));
      
      // Draw background gradient
      final backgroundPaint = Paint()
        ..shader = ui.Gradient.linear(
          const Offset(0, 0),
          Offset(width, height),
          [
            AppColors.background,
            AppColors.surfaceLight,
            AppColors.backgroundAlt,
          ],
          [0.0, 0.5, 1.0],
        );
      canvas.drawRect(Rect.fromLTWH(0, 0, width, height), backgroundPaint);
      
      // Draw glow effect circles
      final glowPaint1 = Paint()
        ..color = primaryColor.withOpacity(0.15)
        ..maskFilter = MaskFilter.blur(BlurStyle.normal, 100 * scale);
      canvas.drawCircle(Offset(width * 0.2, height * 0.3), 250 * scale, glowPaint1);
      
      final glowPaint2 = Paint()
        ..color = secondaryColor.withOpacity(0.1)
        ..maskFilter = MaskFilter.blur(BlurStyle.normal, 80 * scale);
      canvas.drawCircle(Offset(width * 0.8, height * 0.7), 200 * scale, glowPaint2);
      
      // Draw center circle (avatar placeholder)
      final circlePaint = Paint()
        ..shader = ui.Gradient.radial(
          Offset(width / 2, height * 0.4),
          150 * scale,
          [primaryColor.withOpacity(0.3), primaryColor.withOpacity(0.05)],
        );
      canvas.drawCircle(Offset(width / 2, height * 0.4), 150 * scale, circlePaint);
      
      // Draw first letter of name in circle
      final letterStyle = ui.TextStyle(
        color: Colors.white,
        fontSize: 120 * scale,
        fontWeight: FontWeight.bold,
      );
      final letterBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
        textAlign: TextAlign.center,
      ))
        ..pushStyle(letterStyle)
        ..addText(senderName.isNotEmpty ? senderName[0].toUpperCase() : 'V');
      final letterParagraph = letterBuilder.build()
        ..layout(ui.ParagraphConstraints(width: 200 * scale));
      canvas.drawParagraph(
        letterParagraph,
        Offset(width / 2 - (100 * scale), height * 0.4 - (60 * scale)),
      );
      
      // Draw sender name
      final nameStyle = ui.TextStyle(
        color: Colors.white,
        fontSize: 64 * scale,
        fontWeight: FontWeight.bold,
      );
      final nameBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
        textAlign: TextAlign.center,
      ))
        ..pushStyle(nameStyle)
        ..addText(senderName);
      final nameParagraph = nameBuilder.build()
        ..layout(ui.ParagraphConstraints(width: width - (100 * scale)));
      canvas.drawParagraph(
        nameParagraph,
        Offset(50 * scale, height * 0.55),
      );
      
      // Draw "invited you to Vibe" text
      final inviteStyle = ui.TextStyle(
        color: Colors.white.withOpacity(0.8),
        fontSize: 40 * scale,
      );
      final inviteBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
        textAlign: TextAlign.center,
      ))
        ..pushStyle(inviteStyle)
        ..addText('invited you to Nock');
      final inviteParagraph = inviteBuilder.build()
        ..layout(ui.ParagraphConstraints(width: width - (100 * scale)));
      canvas.drawParagraph(
        inviteParagraph,
        Offset(50 * scale, height * 0.62),
      );
      
      // Draw "Join my squad!" text
      final joinStyle = ui.TextStyle(
        color: primaryColor,
        fontSize: 48 * scale,
        fontWeight: FontWeight.w600,
      );
      final joinBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
        textAlign: TextAlign.center,
      ))
        ..pushStyle(joinStyle)
        ..addText('Join my squad!');
      final joinParagraph = joinBuilder.build()
        ..layout(ui.ParagraphConstraints(width: width - (100 * scale)));
      canvas.drawParagraph(
        joinParagraph,
        Offset(50 * scale, height * 0.72),
      );
      
      // Draw VIBE logo text at bottom
      final logoStyle = ui.TextStyle(
        color: Colors.white.withOpacity(0.5),
        fontSize: 36 * scale,
        fontWeight: FontWeight.bold,
      );
      final logoBuilder = ui.ParagraphBuilder(ui.ParagraphStyle(
        textAlign: TextAlign.center,
      ))
        ..pushStyle(logoStyle)
        ..addText('NOCK');
      final logoParagraph = logoBuilder.build()
        ..layout(ui.ParagraphConstraints(width: width - (100 * scale)));
      canvas.drawParagraph(
        logoParagraph,
        Offset(50 * scale, height * 0.92),
      );
      
      // Convert to image
      final picture = recorder.endRecording();
      final image = await picture.toImage(width.toInt(), height.toInt());
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      
      if (byteData == null) {
        debugPrint('InviteCardGenerator: Canvas byteData is null');
        return null;
      }
      
      final pngBytes = byteData.buffer.asUint8List();
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final file = File('${tempDir.path}/vibe_invite_$timestamp.png');
      await file.writeAsBytes(pngBytes);
      
      debugPrint('InviteCardGenerator: Canvas render successful');
      return file;
    } catch (e) {
      debugPrint('InviteCardGenerator: Canvas render failed: $e');
      return null;
    }
  }
}

/// Provider for InviteService
final inviteServiceProvider = Provider<InviteService>((ref) {
  return InviteService();
});

/// Enum for invite share targets
enum InviteTarget {
  instagramStory,
  instagramDm,
  snapchat,
  whatsapp,
  messenger,
  telegram,
  messages,
  other,
}

extension InviteTargetExtension on InviteTarget {
  String get displayName {
    switch (this) {
      case InviteTarget.instagramStory:
        return 'Instagram Story';
      case InviteTarget.instagramDm:
        return 'Instagram DM';
      case InviteTarget.snapchat:
        return 'Snapchat';
      case InviteTarget.whatsapp:
        return 'WhatsApp';
      case InviteTarget.messenger:
        return 'Messenger';
      case InviteTarget.telegram:
        return 'Telegram';
      case InviteTarget.messages:
        return 'Messages';
      case InviteTarget.other:
        return 'Other';
    }
  }
  
  IconData get icon {
    switch (this) {
      case InviteTarget.instagramStory:
        return Icons.camera_alt;
      case InviteTarget.instagramDm:
        return Icons.send;
      case InviteTarget.snapchat:
        return Icons.snapchat;
      case InviteTarget.whatsapp:
        return Icons.chat;
      case InviteTarget.messenger:
        return Icons.messenger;
      case InviteTarget.telegram:
        return Icons.telegram;
      case InviteTarget.messages:
        return Icons.sms;
      case InviteTarget.other:
        return Icons.share;
    }
  }
  
  Color get color {
    switch (this) {
      case InviteTarget.instagramStory:
      case InviteTarget.instagramDm:
        return const Color(0xFFE1306C);
      case InviteTarget.snapchat:
        return const Color(0xFFFFFC00);
      case InviteTarget.whatsapp:
        return const Color(0xFF25D366);
      case InviteTarget.messenger:
        return const Color(0xFF0084FF);
      case InviteTarget.telegram:
        return const Color(0xFF0088CC);
      case InviteTarget.messages:
        return const Color(0xFF34C759);
      case InviteTarget.other:
        return AppColors.bioLime;
    }
  }
}



========================================

FILE #24: E:\Vive\lib\core\services\media_service.dart

========================================


import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:camera/camera.dart';
import 'package:photo_manager/photo_manager.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';

/// Camera initialization provider
final cameraControllerProvider =
    StateNotifierProvider<CameraControllerNotifier, CameraState>((ref) {
  return CameraControllerNotifier();
});

/// Gallery request type provider (default to common - photo + video)
final galleryRequestTypeProvider = StateProvider<RequestType>((ref) => RequestType.common);

/// Gallery assets provider
final galleryAssetsProvider = FutureProvider<List<AssetEntity>>((ref) async {
  final type = ref.watch(galleryRequestTypeProvider);
  final permission = await PhotoManager.requestPermissionExtend();
  if (!permission.isAuth) return [];

  final albums = await PhotoManager.getAssetPathList(
    type: type,
    filterOption: FilterOptionGroup(
      imageOption: const FilterOption(
        sizeConstraint: SizeConstraint(
          minWidth: 100,
          minHeight: 100,
        ),
      ),
      videoOption: const FilterOption(
        durationConstraint: DurationConstraint(
          min: Duration.zero,
          max: Duration(seconds: 15), // Align with camera limit
        ),
      ),
      orders: [const OrderOption(type: OrderOptionType.createDate, asc: false)],
    ),
  );

  if (albums.isEmpty) return [];

  final recentAlbum = albums.first;
  // Increase size to 100 for better picker experience
  final assets = await recentAlbum.getAssetListPaged(page: 0, size: 100);
  return assets;
});

/// Camera State
class CameraState {
  final CameraController? controller;
  final bool isInitialized;
  final bool isRecording;
  final bool isFrontCamera;
  final FlashMode flashMode;
  final double zoomLevel;
  final double minZoom;
  final double maxZoom;
  final String? error;

  CameraState({
    this.controller,
    this.isInitialized = false,
    this.isRecording = false,
    this.isFrontCamera = true,
    this.flashMode = FlashMode.off,
    this.zoomLevel = 1.0,
    this.minZoom = 1.0,
    this.maxZoom = 1.0,
    this.error,
  });

  CameraState copyWith({
    CameraController? controller,
    bool? isInitialized,
    bool? isRecording,
    bool? isFrontCamera,
    FlashMode? flashMode,
    double? zoomLevel,
    double? minZoom,
    double? maxZoom,
    String? error,
  }) {
    return CameraState(
      controller: controller ?? this.controller,
      isInitialized: isInitialized ?? this.isInitialized,
      isRecording: isRecording ?? this.isRecording,
      isFrontCamera: isFrontCamera ?? this.isFrontCamera,
      flashMode: flashMode ?? this.flashMode,
      zoomLevel: zoomLevel ?? this.zoomLevel,
      minZoom: minZoom ?? this.minZoom,
      maxZoom: maxZoom ?? this.maxZoom,
      error: error,
    );
  }
}

class CameraControllerNotifier extends StateNotifier<CameraState> {
  List<CameraDescription> _cameras = [];
  bool _isInitializing = false; // Internal flag for legacy sync logic
  int _initGeneration = 0;      // CRITICAL: Solves 1000% confirmed initialization race condition
  
  // Synchronization for JIT state transitions
  Future<void>? _enableAudioFuture;

  // ðŸ§­ STATIC CACHE: Bypass global hardware enumeration bottleneck (HAL query)
  // Your research is 100% correct: availableCameras() is a heavy HAL query.
  // We discover once per app session (main thread safe).
  static List<CameraDescription>? _cachedCameras;

  CameraControllerNotifier() : super(CameraState());

  /// Initialize camera
  /// CRITICAL: Uses _initGeneration to prevent race condition during background/resume
  Future<bool> initializeCamera() async {
    final currentGen = ++_initGeneration;
    
    if (_isInitializing) {
      debugPrint('Camera: Internal init flag set, but proceeding with new generation $currentGen');
    }
    
    // Also skip if already initialized and it's the right controller
    if (state.isInitialized && state.controller != null && state.controller!.value.isInitialized) {
      debugPrint('Camera: Already initialized, skipping');
      return true;
    }
    
    _isInitializing = true;
    
    try {
      // 1. Permission Check (PASSIVE ONLY)
      // JIT Arch: We DO NOT request permission here.
      // If permission is denied, we simply fail to initialize and let UI show placeholder.
      final status = await Permission.camera.status;
      
      // RACE CHECK: If app was backgrounded during dialog, generation will have changed
      if (currentGen != _initGeneration) {
        debugPrint('Camera: Init generation $currentGen STALE after permission check, cancelling');
        return false;
      }

      if (!status.isGranted) {
        state = state.copyWith(error: 'Camera permission required');
        _isInitializing = false;
        return false;
      }

      // 2. Fetch cameras (Cached discovery)
      if (_cachedCameras != null && _cachedCameras!.isNotEmpty) {
        _cameras = _cachedCameras!;
      } else {
        debugPrint('Camera: Cache empty, querying hardware HAL...');
        _cameras = await availableCameras();
        _cachedCameras = _cameras;
      }
      
      // RACE CHECK: Heavy async call
      if (currentGen != _initGeneration) {
        debugPrint('Camera: Init generation $currentGen STALE after availableCameras, cancelling');
        return false;
      }

      if (_cameras.isEmpty) {
        state = state.copyWith(error: 'No cameras available');
        _isInitializing = false;
        return false;
      }

      final frontCamera = _cameras.firstWhere(
        (camera) => camera.lensDirection == CameraLensDirection.front,
        orElse: () => _cameras.first,
      );

      // 3. Setup hardware
      await _setupCamera(frontCamera, currentGen);
      
      // RACE CHECK: Final confirmation
      return currentGen == _initGeneration;
    } catch (e) {
      debugPrint('Camera init error: $e');
      if (currentGen == _initGeneration) {
        state = state.copyWith(error: e.toString());
      }
      return false;
    } finally {
      if (currentGen == _initGeneration) {
        _isInitializing = false;
      }
    }
  }

  /// Re-initialize camera with Audio enabled (JIT Microphone)
  /// Called when user wants to record video/audio
  Future<void> enableAudio() async {
    if (_enableAudioFuture != null) {
      debugPrint('ðŸŽ¤ enableAudio: Request already in progress, awaiting...');
      return _enableAudioFuture;
    }
    
    _enableAudioFuture = _performEnableAudio();
    try {
      await _enableAudioFuture;
    } finally {
      _enableAudioFuture = null;
    }
  }

  Future<void> _performEnableAudio() async {
    if (state.controller == null) return;
    
    // Check if duplicate request
    if (state.controller!.enableAudio) {
       debugPrint('ðŸŽ¤ Audio already enabled, skipping re-init');
       return;
    }
    
    debugPrint('ðŸŽ¤ Enabling Audio for Camera (Hard Reset)...');
    
    // REVERT: We explicitly reset state to NULL to force a UI rebuild (show loading).
    // The "Seamless" approach caused issues with the camera portal.
    final currentGen = ++_initGeneration;
    final currentCamera = state.controller!.description;
    final oldController = state.controller;
    
    // 1. Reset state (Trigger "Starting camera" UI)
    state = state.copyWith(
      controller: null,
      isInitialized: false,
    );
    
    try {
      // 2. Dispose old controller safely
      await oldController?.dispose();
    } catch(e) {
      debugPrint('Error disposing old controller: $e');
    }
    
    // 3. Setup new one with AUDIO
    await _setupCamera(currentCamera, currentGen, forceAudio: true);
  }

  Future<void> _setupCamera(CameraDescription camera, int generation, {bool forceAudio = false}) async {
    // Check generation before starting
    if (generation != _initGeneration) return;
    
    // JIT CONFIGURATION: Default to NO AUDIO for fast start & no mic permission
    final configs = forceAudio ? [
       // If forced (recording mode), try audio configs first
       (preset: ResolutionPreset.veryHigh, audio: true),
       (preset: ResolutionPreset.high, audio: true),
       (preset: ResolutionPreset.high, audio: false), // Fallback
    ] : [
       // Default (Preview mode): Prefer NO AUDIO
       (preset: ResolutionPreset.veryHigh, audio: false),
       (preset: ResolutionPreset.high, audio: false),
       (preset: ResolutionPreset.medium, audio: false),
    ];
    
    for (final config in configs) {
      // Check if we were cancelled before each attempt
      if (generation != _initGeneration) return;

      final controller = CameraController(
        camera,
        config.preset,
        enableAudio: config.audio,
        imageFormatGroup: Platform.isAndroid 
            ? ImageFormatGroup.yuv420 
            : ImageFormatGroup.bgra8888,
      );
      
      try {
        await controller.initialize();
        
        // CRITICAL CHECK: Were we backgrounded/reset while initializing?
        if (generation != _initGeneration) {
          debugPrint('Camera: Init completed for generation $generation but it is STALE. Disposing...');
          await controller.dispose();
          return;
        }

        debugPrint('Camera initialized: ${config.preset.name}, audio=${config.audio}');
        
        // CAPTURE ZOOM LIMITS
        double minZoomVal = 1.0;
        double maxZoomVal = 1.0;
        try {
          final dynamic minZ = await controller.getMinZoomLevel();
          final dynamic maxZ = await controller.getMaxZoomLevel();
          if (minZ is num) minZoomVal = minZ.toDouble();
          if (maxZ is num) maxZoomVal = maxZ.toDouble();
        } catch (e) {
          debugPrint('âš ï¸ Zoom hardware detection failed: $e');
        }

        state = state.copyWith(
          controller: controller,
          isInitialized: true,
          isFrontCamera: camera.lensDirection == CameraLensDirection.front,
          minZoom: minZoomVal,
          maxZoom: maxZoomVal,
          zoomLevel: 1.0, // Reset zoom on init/switch
          error: null,
        );
        return; // Success
      } catch (e) {
        debugPrint('Camera init failed: ${config.preset.name}, audio=${config.audio} - $e');
        await controller.dispose();
        
        if (config == configs.last && generation == _initGeneration) {
          state = state.copyWith(
            error: 'Camera initialization failed. Check permissions and try again.',
          );
        }
      }
    }
  }

  /// Switch between front and back camera
  Future<void> switchCamera() async {
    if (_cameras.isEmpty || _isInitializing) return;
    if (_cameras.length < 2) return;

    final currentGen = ++_initGeneration;
    final currentController = state.controller;
    
    // 1. Mark as initializing to prevent parallel calls
    _isInitializing = true;
    
    // 2. Determine next camera before clearing state
    final newCamera = _cameras.firstWhere(
      (camera) => state.isFrontCamera
          ? camera.lensDirection == CameraLensDirection.back
          : camera.lensDirection == CameraLensDirection.front,
      orElse: () => _cameras.first,
    );

    // 3. IMMEDIATELY update state to remove the old controller
    state = state.copyWith(
      controller: null,
      isInitialized: false,
    );

    try {
      // 4. Dispose safely
      if (currentController != null) {
        await currentController.dispose();
      }

      // RACE CHECK
      if (currentGen != _initGeneration) return;

      // Small delay to allow hardware to "breath"
      await Future.delayed(const Duration(milliseconds: 100));
      
      // RACE CHECK
      if (currentGen != _initGeneration) return;
      
      // 5. Setup new camera
      await _setupCamera(newCamera, currentGen);
    } catch (e) {
      debugPrint('Camera switch error: $e');
      if (currentGen == _initGeneration) {
        state = state.copyWith(error: 'Failed to switch camera: $e');
      }
    } finally {
      if (currentGen == _initGeneration) {
        _isInitializing = false;
      }
    }
  }

  /// Toggle flash mode
  Future<void> toggleFlash() async {
    if (state.controller == null) return;
    
    FlashMode nextMode;
    switch (state.flashMode) {
      case FlashMode.off:
        nextMode = FlashMode.auto;
        break;
      case FlashMode.auto:
        nextMode = FlashMode.always;
        break;
      case FlashMode.always:
        nextMode = FlashMode.off;
        break;
      default:
        nextMode = FlashMode.off;
    }
    
    await state.controller!.setFlashMode(nextMode);
    state = state.copyWith(flashMode: nextMode);
  }

  /// Set zoom level
  Future<void> setZoomLevel(double level) async {
    if (state.controller == null || !state.isInitialized) return;
    
    // Clamp to hardware limits
    final clampedLevel = level.clamp(state.minZoom, state.maxZoom);
    
    try {
      await state.controller!.setZoomLevel(clampedLevel);
      state = state.copyWith(zoomLevel: clampedLevel);
    } catch (e) {
      debugPrint('Error setting zoom level: $e');
    }
  }

  /// Take a photo
  Future<File?> takePhoto() async {
    if (state.controller == null || !state.isInitialized) return null;

    try {
      final XFile image = await state.controller!.takePicture();
      return File(image.path);
    } catch (e) {
      debugPrint('Error taking photo: $e');
      return null;
    }
  }

  /// Get photo from gallery asset
  Future<File?> getPhotoFromAsset(AssetEntity asset) async {
    try {
      final file = await asset.file;
      return file;
    } catch (e) {
      debugPrint('Error getting photo from asset: $e');
      return null;
    }
  }

  /// Reset camera state when controller is disposed externally (lifecycle)
  /// This prevents the UI from trying to render a disposed controller
  /// This prevents the UI from trying to render a disposed controller
  void reset() {
    debugPrint('Camera: Resetting and incrementing generation');
    _initGeneration++; // Invalidate any pending initializations IMMEDIATELY
    _isInitializing = false;
    
    final controller = state.controller;
    state = CameraState(); // Notify listeners FIRST to remove from tree
    controller?.dispose(); // Then dispose hardware
  }

  @override
  void dispose() {
    state.controller?.dispose();
    super.dispose();
  }
}

/// Media service for handling camera and gallery operations
class MediaService {
  /// Get the original date of a photo (for Time Travel feature)
  static Future<DateTime?> getPhotoOriginalDate(AssetEntity asset) async {
    return asset.createDateTime;
  }

  /// Save image to temp with compression
  static Future<File?> saveImageToTemp(File imageFile) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final fileName = 'vibe_${DateTime.now().millisecondsSinceEpoch}.jpg';
      final newPath = '${tempDir.path}/$fileName';
      return imageFile.copy(newPath);
    } catch (e) {
      debugPrint('Error saving image: $e');
      return null;
    }
  }
}



========================================

FILE #25: E:\Vive\lib\core\services\native_service_helper.dart

========================================


import 'dart:io';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';

/// Helper to communicate with native platform services
class NativeServiceHelper {
  static const _platform = MethodChannel('com.nock.nock/audio_control');

  /// Stops the NockAudioService on Android to free up hardware resources (Mic).
  /// This is crucial before initializing the Camera to prevent hangs.
  static Future<void> stopBackgroundService() async {
    if (Platform.isAndroid) {
      try {
        debugPrint('ðŸ”‘ Requesting native service stop to free resources...');
        await _platform.invokeMethod('stopNockAudioService');
      } on PlatformException catch (e) {
        debugPrint('âŒ Error stopping native service: ${e.message}');
      }
    }
  }
}



========================================

FILE #26: E:\Vive\lib\core\services\share_service.dart

========================================


import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'package:http/http.dart' as http;
import 'package:path/path.dart' as p;
import 'package:url_launcher/url_launcher.dart';

/// Share Service - Handles viral sharing of Vibes
/// Creates shareable content for TikTok, Instagram, etc.
class ShareService {
  ShareService();
  
  // Platform channel for native sharing
  static const _shareChannel = MethodChannel('com.nock.nock/share');

  // ==================== SOCIAL DEEP LINKS ====================

  /// Navigate directly to TikTok app (opens empty app - no image)
  /// DEPRECATED: Use shareToTikTok() instead to share with image
  Future<void> openTikTok() async {
    final Uri tiktokUri = Uri.parse('tiktok://');
    final Uri webUri = Uri.parse('https://www.tiktok.com/');
    
    try {
      if (await canLaunchUrl(tiktokUri)) {
        await launchUrl(tiktokUri, mode: LaunchMode.externalApplication);
      } else {
        await launchUrl(webUri, mode: LaunchMode.externalApplication);
      }
    } catch (e) {
      debugPrint('ShareService: Failed to open TikTok: $e');
      // Fallback to web
      await launchUrl(webUri, mode: LaunchMode.externalApplication);
    }
  }

  /// Share image to TikTok using platform channel (with image content)
  /// Opens TikTok with the image ready to create a post
  Future<bool> shareToTikTok(File imageFile) async {
    try {
      if (!await imageFile.exists()) {
        debugPrint('ShareService: Image file does not exist');
        return false;
      }
      
      // Use platform channel for TikTok share with image
      final result = await _shareChannel.invokeMethod<bool>('shareToTikTok', {
        'imagePath': imageFile.path,
      });
      return result ?? false;
    } catch (e) {
      debugPrint('ShareService: TikTok share failed: $e');
      return false;
    }
  }

  /// Check if TikTok is installed
  Future<bool> isTikTokInstalled() async {
    try {
      final result = await _shareChannel.invokeMethod<bool>('isTikTokInstalled');
      return result ?? false;
    } catch (e) {
      debugPrint('ShareService: Failed to check TikTok: $e');
      return false;
    }
  }


  /// Open Instagram's native share sheet with Feed, Messages, Reels, Stories options
  /// This shares directly to Instagram app, showing Instagram's own picker
  Future<bool> openInstagramShareSheet(File imageFile) async {
    try {
      if (!await imageFile.exists()) {
        debugPrint('ShareService: Image file does not exist');
        return false;
      }
      
      // Check if Instagram is installed
      final Uri instagramUri = Uri.parse('instagram://');
      if (!await canLaunchUrl(instagramUri)) {
        debugPrint('ShareService: Instagram not installed');
        return false;
      }
      
      // Use share_plus with Instagram-specific sharing
      // This opens Instagram's native share picker showing Feed, Messages, Reels, Stories
      await Share.shareXFiles(
        [XFile(imageFile.path)],
        text: '', // Instagram ignores text for image shares
        sharePositionOrigin: null,
      );
      
      // Note: share_plus opens system share sheet
      // For Instagram-only picker, we need platform channels
      // Using Android Intent to share directly to Instagram
      return true;
    } catch (e) {
      debugPrint('ShareService: Failed to open Instagram: $e');
      return false;
    }
  }

  /// Open Instagram directly and let user choose destination (Feed, Stories, Reels, Messages)
  /// Uses platform channel to send EXPLICIT INTENT to Instagram package
  /// This shows ONLY Instagram's internal picker - NOT the system share sheet with all apps
  Future<bool> shareToInstagramDirect(File imageFile) async {
    try {
      if (!await imageFile.exists()) {
        debugPrint('ShareService: Image file does not exist');
        return false;
      }
      
      // BOTH Android and iOS use platform channel for Instagram-only share
      // Android: Uses explicit intent with package="com.instagram.android"
      // iOS: Uses UIDocumentInteractionController with UTI="com.instagram.exclusivegram"
      final result = await _shareChannel.invokeMethod<bool>('shareToInstagram', {
        'imagePath': imageFile.path,
      });
      return result ?? false;
    } catch (e) {
      debugPrint('ShareService: Instagram share failed: $e');
      return false;
    }
  }
  
  /// Check if Instagram is installed
  Future<bool> isInstagramInstalled() async {
    try {
      // Both platforms use platform channel to check
      final result = await _shareChannel.invokeMethod<bool>('isInstagramInstalled');
      return result ?? false;
    } catch (e) {
      debugPrint('ShareService: Failed to check Instagram: $e');
      return false;
    }
  }



  /// Open native system share sheet with all available options
  Future<void> shareGeneric(String text, {File? imageFile}) async {
    try {
      if (imageFile != null && await imageFile.exists()) {
        await Share.shareXFiles(
          [XFile(imageFile.path)],
          text: text,
          subject: 'Join me on Nock!',
        );
      } else {
        await Share.share(text, subject: 'Join me on Nock!');
      }
    } catch (e) {
      debugPrint('ShareService: Failed to share: $e');
      rethrow;
    }
  }

  /// Share a vibe's audio file
  Future<void> shareAudio({
    required String audioUrl,
    required String senderName,
    String? message,
  }) async {
    try {
      // Download the audio file temporarily
      final tempDir = await getTemporaryDirectory();
      final audioFile = File('${tempDir.path}/vibe_audio.m4a');
      
      // If it's a URL, download it
      if (audioUrl.startsWith('http')) {
        final response = await http.get(Uri.parse(audioUrl));
        await audioFile.writeAsBytes(response.bodyBytes);
      } else {
        // It's a local file path
        await File(audioUrl).copy(audioFile.path);
      }
      
      // Share the file
      await Share.shareXFiles(
        [XFile(audioFile.path)],
        text: message ?? 'Check out this Vibe from $senderName! ðŸŽ¤âœ¨',
        subject: 'Nock from $senderName',
      );
    } catch (e) {
      debugPrint('Error sharing audio: $e');
      rethrow;
    }
  }

  /// Share a vibe with image
  Future<void> shareVibe({
    required String imageUrl,
    required String audioUrl,
    required String senderName,
    String? message,
  }) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final files = <XFile>[];
      
      // Download image
      if (imageUrl.isNotEmpty) {
        final imageFile = File('${tempDir.path}/vibe_image.jpg');
        if (imageUrl.startsWith('http')) {
          final response = await http.get(Uri.parse(imageUrl));
          await imageFile.writeAsBytes(response.bodyBytes);
        } else {
          await File(imageUrl).copy(imageFile.path);
        }
        files.add(XFile(imageFile.path));
      }
      
      // Download audio
      if (audioUrl.isNotEmpty) {
        final audioFile = File('${tempDir.path}/vibe_audio.m4a');
        if (audioUrl.startsWith('http')) {
          final response = await http.get(Uri.parse(audioUrl));
          await audioFile.writeAsBytes(response.bodyBytes);
        } else {
          await File(audioUrl).copy(audioFile.path);
        }
        files.add(XFile(audioFile.path));
      }
      
      // Share files
      await Share.shareXFiles(
        files,
        text: message ?? 'ðŸŽ¤ Vibe from $senderName\n\nDownload Vibe app to listen! âœ¨',
        subject: 'Nock from $senderName',
      );
    } catch (e) {
      debugPrint('Error sharing vibe: $e');
      rethrow;
    }
  }

  /// Share text with app link
  Future<void> shareAppLink({String? customMessage}) async {
    const appLink = 'https://getvibe.app'; // Replace with actual app store link
    final message = customMessage ?? 
        'âœ¨ I\'m using Vibe to send voice messages that appear on my friends\' home screens!\n\n'
        'Download Vibe: $appLink';
    
    await Share.share(message, subject: 'Check out Vibe!');
  }

  /// Generate and share a "Vibe Card" - static image with audio waveform
  /// This is a simpler alternative to full video export
  Future<void> shareVibeCard({
    required String imagePath,
    required String senderName,
    required String message,
  }) async {
    try {
      // For now, just share the image with text
      // In production, you'd overlay the Aura visualization
      await Share.shareXFiles(
        [XFile(imagePath)],
        text: 'ðŸŽ¤ "$message"\n\n- $senderName via Vibe\n\nDownload Vibe to hear the voice message! âœ¨',
        subject: 'Nock from $senderName',
      );
    } catch (e) {
      debugPrint('Error sharing vibe card: $e');
      rethrow;
    }
  }
}

/// Share service provider
final shareServiceProvider = Provider<ShareService>((ref) {
  return ShareService();
});



========================================

FILE #27: E:\Vive\lib\core\services\subscription_service.dart

========================================


import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:purchases_flutter/purchases_flutter.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../constants/app_constants.dart';

/// Subscription Service
/// 
/// Manages RevenueCat integration for VIBE+ subscriptions.
class SubscriptionService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  /// Initialize RevenueCat
  Future<void> initialize() async {
    await Purchases.setLogLevel(kDebugMode ? LogLevel.debug : LogLevel.info);

    PurchasesConfiguration? configuration;

    if (Platform.isAndroid) {
      configuration = PurchasesConfiguration(AppConstants.rcGoogleApiKey);
    } else if (Platform.isIOS) {
      configuration = PurchasesConfiguration(AppConstants.rcAppleApiKey);
    }

    if (configuration != null) {
      // ðŸ›¡ï¸ STABILITY FIX: Don't configure if API Key is empty (prevents Native crash/exception)
      if (configuration.apiKey.isEmpty) {
        debugPrint('âš ï¸ SubscriptionService: RevenueCat API Key is missing. Subscription features will be disabled.');
        return;
      }
      
      try {
        await Purchases.configure(configuration);
        _setupCustomerInfoListener();
      } catch (e) {
        debugPrint('âŒ SubscriptionService: Failed to configure RevenueCat: $e');
      }
    }
  }

  /// Listen for customer info changes (e.g. successful purchase, expiration)
  void _setupCustomerInfoListener() {
    Purchases.addCustomerInfoUpdateListener((customerInfo) {
      _syncEntitlementStatus(customerInfo);
    });
  }

  /// Restore purchases - Mandatory for App Store compliance
  Future<bool> restorePurchases() async {
    try {
      final customerInfo = await Purchases.restorePurchases();
      return await _syncEntitlementStatus(customerInfo);
    } on PlatformException catch (e) {
      debugPrint('SubscriptionService: Restore error: ${e.message}');
      rethrow;
    }
  }

  /// Purchase a specific VIBE+ package (Weekly, Monthly, or Annual)
  Future<bool> purchasePackage(String productId) async {
    try {
      final offerings = await Purchases.getOfferings();
      
      if (offerings.current != null && offerings.current!.availablePackages.isNotEmpty) {
        // Find the specific product requested
        final package = offerings.current!.availablePackages.firstWhere(
          (pkg) => pkg.storeProduct.identifier == productId,
          orElse: () => offerings.current!.availablePackages.first,
        );

        debugPrint('SubscriptionService: Attempting purchase of ${package.storeProduct.identifier}');
        
        // 1. Attempt the purchase
        final PurchaseResult result = await Purchases.purchase(
          PurchaseParams.package(package),
        );

        // 2. Sync and return
        return await _syncEntitlementStatus(result.customerInfo);
      } else {
        debugPrint('SubscriptionService: No offerings available');
        return false;
      }
    } on PlatformException catch (e) {
      // 3. Handle User Cancellation
      // In Flutter, cancellation throws a PlatformException
      final errorCode = PurchasesErrorHelper.getErrorCode(e);
      if (errorCode == PurchasesErrorCode.purchaseCancelledError) {
        debugPrint('SubscriptionService: Purchase cancelled by user');
        return false; // Safe exit, no crash
      }
      
      // 4. Handle actual errors (network, invalid credentials, etc.)
      debugPrint('SubscriptionService: Purchase error: ${e.message}');
      rethrow;
    }
  }

  /// Sync entitlement status with Firestore Firestore
  Future<bool> _syncEntitlementStatus(CustomerInfo customerInfo) async {
    final isPremium = customerInfo.entitlements.all[AppConstants.premiumEntitlementId]?.isActive ?? false;
    
    final user = _auth.currentUser;
    if (user != null) {
      try {
        await _firestore.collection(AppConstants.usersCollection).doc(user.uid).update({
          'isPremium': isPremium,
        });
        debugPrint('SubscriptionService: Synced premium status ($isPremium) for user ${user.uid}');
      } catch (e) {
        debugPrint('SubscriptionService: Error syncing with Firestore: $e');
      }
    }
    
    return isPremium;
  }
}

/// Subscription Service Provider
final subscriptionServiceProvider = Provider<SubscriptionService>((ref) {
  return SubscriptionService();
});



========================================

FILE #28: E:\Vive\lib\core\services\transcription_service.dart

========================================


import 'dart:io';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http/http.dart' as http;
import 'package:path_provider/path_provider.dart';

import 'package:nock/core/constants/app_constants.dart';

/// Transcription Service - AI-powered Speech-to-Text
/// Converts voice messages to readable text using OpenAI Whisper API
class TranscriptionService {
  // Use centralized API key from AppConstants
  static const String _apiKey = AppConstants.openAiApiKey;
  static const String _whisperEndpoint = 'https://api.openai.com/v1/audio/transcriptions';

  /// Transcribe an audio file to text using OpenAI Whisper
  /// Returns the transcribed text or null if failed
  Future<String?> transcribeAudio(File audioFile) async {
    try {
      if (!await audioFile.exists()) {
        debugPrint('Audio file not found: ${audioFile.path}');
        return null;
      }

      // Whisper has a 25MB limit
      final fileSizeInMb = await audioFile.length() / (1024 * 1024);
      if (fileSizeInMb > 25) {
        debugPrint('Transcription failed: File too large (${fileSizeInMb.toStringAsFixed(2)}MB). Limit is 25MB.');
        return 'Audio too large (over 25MB) to transcribe.';
      }

      // Create multipart request
      final request = http.MultipartRequest('POST', Uri.parse(_whisperEndpoint));
      
      // Add authorization header
      request.headers['Authorization'] = 'Bearer $_apiKey';
      
      // Add the audio file (Whisper supports: mp3, mp4, mpeg, mpga, m4a, wav, webm)
      final String extension = audioFile.path.split('.').last.toLowerCase();
      request.files.add(await http.MultipartFile.fromPath(
        'file',
        audioFile.path,
        filename: 'vibe_media.$extension',
      ));
      
      // Specify the model
      request.fields['model'] = 'whisper-1';
      request.fields['language'] = 'en'; // Optional: auto-detect if removed
      request.fields['response_format'] = 'json';
      
      debugPrint('Sending transcription request...');
      
      // Send request
      final streamedResponse = await request.send();
      final response = await http.Response.fromStream(streamedResponse);
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        final transcribedText = jsonResponse['text'] as String?;
        debugPrint('Transcription successful: $transcribedText');
        return transcribedText;
      } else {
        debugPrint('Transcription failed: ${response.statusCode} - ${response.body}');
        return null;
      }
    } catch (e) {
      debugPrint('Transcription error: $e');
      return null;
    }
  }

  /// Transcribe a local audio/video file directly to OpenAI (Parallel Pipeline)
  /// This is an alias for transcribeAudio, used for the parallel fork pattern.
  Future<String?> transcribeFile(File audioFile) async {
    return await transcribeAudio(audioFile);
  }

  /// ðŸª 3-Word Hook Generator - Creates intriguing teasers for widget engagement
  /// Uses GPT-4o-mini ($0.00015/1K tokens) to convert full transcription into
  /// a high-curiosity 3-word hook that drives app opens.
  /// 
  /// Example: "Hey, I saw your ex at the mall today..." â†’ "Saw your ex..."
  Future<String?> generateWidgetHook(String transcription) async {
    if (transcription.isEmpty) return null;
    
    // For very short transcriptions (< 20 chars), just use them as-is
    if (transcription.length < 20) return transcription;
    
    try {
      final response = await http.post(
        Uri.parse('https://api.openai.com/v1/chat/completions'),
        headers: {
          'Authorization': 'Bearer $_apiKey',
          'Content-Type': 'application/json',
        },
        body: jsonEncode({
          'model': 'gpt-4o-mini',
          'messages': [
            {
              'role': 'system',
              'content': '''You are a hook generator for a social app widget. 
Create a 3-5 word intriguing teaser that makes the reader NEED to open the app.
Rules:
- Focus on emotion, secrets, urgency, or surprising elements
- Do NOT give away the ending or resolution
- End with "..." to create curiosity
- Keep it under 25 characters
- Use present tense when possible
Examples:
"I just saw your ex at the mall" â†’ "Saw your ex..."
"I need to tell you something important" â†’ "Need to tell you..."
"You won't believe what happened today" â†’ "Won't believe this..."
"I'm thinking about breaking up with him" â†’ "About to break up..."'''
            },
            {
              'role': 'user',
              'content': 'Create a hook for: "$transcription"'
            }
          ],
          'max_tokens': 30,
          'temperature': 0.7,
        }),
      );
      
      if (response.statusCode == 200) {
        final jsonResponse = jsonDecode(response.body);
        final hook = jsonResponse['choices'][0]['message']['content'] as String?;
        if (hook != null && hook.isNotEmpty) {
          // Clean up any quotes or extra formatting
          final cleanHook = hook.replaceAll('"', '').replaceAll("'", "").trim();
          debugPrint('ðŸª Hook generated: $cleanHook');
          return cleanHook;
        }
      } else {
        debugPrint('Hook generation failed: ${response.statusCode}');
      }
    } catch (e) {
      debugPrint('Hook generation error: $e');
    }
    
    // Fallback: Simple truncation with ellipsis
    return '${transcription.substring(0, transcription.length > 20 ? 20 : transcription.length)}...';
  }

  /// Transcribe from a URL (downloads first, then transcribes)
  Future<String?> transcribeFromUrl(String audioUrl) async {
    try {
      // Extract extension from URL to preserve format (m4a, mp4, etc.)
      String extension = 'm4a';
      try {
        final uri = Uri.parse(audioUrl);
        final path = uri.path;
        if (path.contains('.')) {
          extension = path.split('.').last.toLowerCase();
          // Cleanup Cloudinary parameters if any (e.g. .mp4?v=123)
          if (extension.contains('?')) {
            extension = extension.split('?').first;
          }
        }
      } catch (_) {}

      // Download to temp file with correct extension
      final tempDir = await getTemporaryDirectory();
      final tempFile = File('${tempDir.path}/temp_transcribe_${DateTime.now().millisecondsSinceEpoch}.$extension');
      
      final response = await http.get(Uri.parse(audioUrl));
      if (response.statusCode == 200) {
        await tempFile.writeAsBytes(response.bodyBytes);
        
        // Transcribe the downloaded file
        final result = await transcribeAudio(tempFile);
        
        // Clean up temp file safely
        try { if (await tempFile.exists()) await tempFile.delete(); } catch (_) {}
        
        return result;
      }
      return null;
    } catch (e) {
      debugPrint('Error transcribing from URL: $e');
      return null;
    }
  }
}

/// Transcription state for a single vibe
class TranscriptionState {
  final String? text;
  final bool isLoading;
  final String? error;

  const TranscriptionState({
    this.text,
    this.isLoading = false,
    this.error,
  });

  TranscriptionState copyWith({
    String? text,
    bool? isLoading,
    String? error,
  }) {
    return TranscriptionState(
      text: text ?? this.text,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

/// Transcription service provider
final transcriptionServiceProvider = Provider<TranscriptionService>((ref) {
  return TranscriptionService();
});

/// Transcription state notifier for managing transcription per vibe
class TranscriptionNotifier extends StateNotifier<Map<String, TranscriptionState>> {
  final TranscriptionService _service;

  TranscriptionNotifier(this._service) : super({});

  /// Get or load transcription for a vibe
  Future<void> loadTranscription(String vibeId, String audioUrl) async {
    // Check if already loaded
    if (state.containsKey(vibeId) && state[vibeId]?.text != null) {
      return;
    }

    // Set loading state
    state = {
      ...state,
      vibeId: const TranscriptionState(isLoading: true),
    };

    try {
      final text = await _service.transcribeFromUrl(audioUrl);
      state = {
        ...state,
        vibeId: TranscriptionState(text: text),
      };
    } catch (e) {
      state = {
        ...state,
        vibeId: TranscriptionState(error: e.toString()),
      };
    }
  }

  /// Get transcription for a vibe (returns null if not loaded)
  TranscriptionState? getTranscription(String vibeId) {
    return state[vibeId];
  }
}

/// Transcription state provider
final transcriptionStateProvider = 
    StateNotifierProvider<TranscriptionNotifier, Map<String, TranscriptionState>>((ref) {
  final service = ref.watch(transcriptionServiceProvider);
  return TranscriptionNotifier(service);
});



========================================

FILE #29: E:\Vive\lib\core\services\vibe_service.dart

========================================


import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import '../models/vibe_model.dart';
import '../models/user_model.dart';
import '../constants/app_constants.dart';
import 'auth_service.dart';
import 'transcription_service.dart';
import 'cloudinary_service.dart';  // â† Cloudinary for file storage (no credit card needed!)
import 'gatekeeper_service.dart'; // Local VAD Gatekeeper
import 'widget_update_service.dart';
import 'background_upload_service.dart';

/// Vibe Service Provider
final vibeServiceProvider = Provider<VibeService>((ref) {
  final authService = ref.watch(authServiceProvider);
  return VibeService(authService);
});

/// Recent vibes stream (last 24 hours for free users)
final recentVibesProvider = StreamProvider<List<VibeModel>>((ref) {
  final userAsync = ref.watch(currentUserProvider);
  return userAsync.when(
    data: (user) {
      if (user == null) return Stream.value([]);
      
      Query query = FirebaseFirestore.instance
          .collection(AppConstants.vibesCollection)
          .where('receiverId', isEqualTo: user.id);

      // HISTORY LIMIT REMOVED: Users see older vibes as "Locked" (Endowment Effect)

      return query
          .orderBy('createdAt', descending: true)
          .snapshots()
          .map((snapshot) {
            final vibes = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
            // Safety: Filter out blocked users (Guideline 1.2)
            if (user.blockedUserIds.isEmpty) return vibes;
            return vibes.where((vibe) => !user.blockedUserIds.contains(vibe.senderId)).toList();
          });
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
});

/// All vibes stream (for premium users - Vault)
final allVibesProvider = StreamProvider<List<VibeModel>>((ref) {
  final userAsync = ref.watch(currentUserProvider);
  return userAsync.when(
    data: (user) {
      if (user == null) return Stream.value([]);
      
      Query query = FirebaseFirestore.instance
          .collection(AppConstants.vibesCollection)
          .where('receiverId', isEqualTo: user.id);

      // HISTORY LIMIT REMOVED: Vault now shows older vibes as "Locked" to free users
      
      return query
          .orderBy('createdAt', descending: true)
          .limit(100)
          .snapshots()
          .map((snapshot) {
            final vibes = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
            // Safety: Filter out blocked users (Guideline 1.2)
            if (user.blockedUserIds.isEmpty) return vibes;
            return vibes.where((vibe) => !user.blockedUserIds.contains(vibe.senderId)).toList();
          });
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PAGINATED VIBES PROVIDER - Infinite scroll for Vault
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/// State for paginated vibes list
class PaginatedVibesState {
  final List<VibeModel> vibes;
  final bool isLoading;
  final bool hasMore;
  final String? error;
  
  const PaginatedVibesState({
    this.vibes = const [],
    this.isLoading = false,
    this.hasMore = true,
    this.error,
  });
  
  PaginatedVibesState copyWith({
    List<VibeModel>? vibes,
    bool? isLoading,
    bool? hasMore,
    String? error,
  }) {
    return PaginatedVibesState(
      vibes: vibes ?? this.vibes,
      isLoading: isLoading ?? this.isLoading,
      hasMore: hasMore ?? this.hasMore,
      error: error,
    );
  }
}

/// Notifier for paginated vibes with infinite scroll support
class PaginatedVibesNotifier extends StateNotifier<PaginatedVibesState> {
  final Ref _ref;
  final bool _isSent;
  DocumentSnapshot? _lastDocument;
  static const _pageSize = 20;
  
  PaginatedVibesNotifier(this._ref, {bool isSent = false}) 
      : _isSent = isSent, 
        super(const PaginatedVibesState()) {
    _loadFirstPage();
  }
  
  /// Load first page of vibes
  Future<void> _loadFirstPage() async {
    final userAsync = _ref.read(currentUserProvider);
    final user = userAsync.valueOrNull;
    if (user == null) return;
    
    state = state.copyWith(isLoading: true, error: null);
    
    try {
      Query query = FirebaseFirestore.instance
          .collection(AppConstants.vibesCollection)
          .where(_isSent ? 'senderId' : 'receiverId', isEqualTo: user.id);

      // HISTORY LIMIT REMOVED: Users can scroll to see locked history
      
      query = query.orderBy('createdAt', descending: true).limit(_pageSize);
      
      final snapshot = await query.get();
      if (!mounted) return;
      
      final vibesList = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
      
      // Safety: Filter out blocked users (unless viewing Sent vibes)
      final vibes = _isSent 
          ? vibesList 
          : vibesList.where((vibe) => !user.blockedUserIds.contains(vibe.senderId)).toList();
      
      _lastDocument = snapshot.docs.isNotEmpty ? snapshot.docs.last : null;
      
      state = PaginatedVibesState(
        vibes: vibes,
        isLoading: false,
        hasMore: snapshot.docs.length == _pageSize,
      );
    } catch (e) {
      if (!mounted) return;
      debugPrint('âŒ PaginatedVibes: Error loading first page: $e');
      // Surface more specific error info if possible
      final errorStr = e.toString();
      state = state.copyWith(isLoading: false, error: errorStr);
    }
  }
  
  /// Load next page of vibes (call when user scrolls near bottom)
  Future<void> loadMore() async {
    if (state.isLoading || !state.hasMore || _lastDocument == null) return;
    
    final userAsync = _ref.read(currentUserProvider);
    final user = userAsync.valueOrNull;
    if (user == null) return;
    
    state = state.copyWith(isLoading: true);
    
    try {
      Query query = FirebaseFirestore.instance
          .collection(AppConstants.vibesCollection)
          .where(_isSent ? 'senderId' : 'receiverId', isEqualTo: user.id);

      // HISTORY LIMIT REMOVED
      
      query = query
          .orderBy('createdAt', descending: true)
          .startAfterDocument(_lastDocument!)
          .limit(_pageSize);
      
      final snapshot = await query.get();
      if (!mounted) return;
      
      final vibesList = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
      
      // Safety: Filter out blocked users (unless viewing Sent vibes)
      final newVibes = _isSent 
          ? vibesList 
          : vibesList.where((vibe) => !user.blockedUserIds.contains(vibe.senderId)).toList();
      
      if (snapshot.docs.isNotEmpty) {
        _lastDocument = snapshot.docs.last;
      }
      
      state = state.copyWith(
        vibes: [...state.vibes, ...newVibes],
        isLoading: false,
        hasMore: newVibes.length == _pageSize,
      );
    } catch (e) {
      if (!mounted) return;
      debugPrint('âŒ PaginatedVibes: Error loading more: $e');
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }
  
  /// Refresh the entire list (pull-to-refresh)
  Future<void> refresh() async {
    _lastDocument = null;
    state = const PaginatedVibesState();
    await _loadFirstPage();
  }
}

/// Provider for paginated vibes
/// Family provider allows caching both Sent and Received lists independently
final paginatedVibesProvider = StateNotifierProvider.family<PaginatedVibesNotifier, PaginatedVibesState, bool>((ref, isSent) {
  return PaginatedVibesNotifier(ref, isSent: isSent);
});

/// Vibe Service - handles sending and receiving voice-photo messages
/// 
/// Uses Cloudinary for file storage (free tier, no credit card required!)
/// Firebase is only used for Firestore database (still free on Spark plan)
class VibeService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final CloudinaryService _cloudinary = CloudinaryService();  // â† Using Cloudinary now!
  final AuthService _authService;
  final _uuid = const Uuid();

  VibeService(this._authService);

  /// Get widget-safe thumbnail URL from original image URL
  /// 
  /// CRITICAL: iOS widgets have a 30MB memory limit.
  /// A 4K photo expands to 40MB+ in RAM when decoded.
  /// 
  /// FIX: Use Cloudinary's transformation API for guaranteed 300x300 resize
  /// This is safer than filename parsing which can fail
  static String getWidgetImageUrl(String? originalUrl) {
    if (originalUrl == null || originalUrl.isEmpty) return '';
    
    try {
      // FIX: iOS Widget OOM Prevention
      // Widgets have hard memory limits (~30MB). We MUST ensure the image is resized.
      // If we can't guarantee a small image, return empty to prevent widget crash.
      
      // Only Cloudinary URLs can be safely transformed
      if (originalUrl.contains('cloudinary.com') && originalUrl.contains('/upload/')) {
        // Insert transformation parameters after /upload/
        return originalUrl.replaceAll(
          '/upload/',
          '/upload/w_300,h_300,c_fill,q_auto/',
        );
      }
      
      // FALLBACK: For non-Cloudinary URLs, return the original URL
      // WidgetUpdateService will handle the download and local downsampling
      // to prevent OOM crashes on iOS.
      debugPrint('VibeService: non-Cloudinary image detected, using fallback for widget.');
      return originalUrl;
    } catch (e) {
      debugPrint('Error transforming widget image URL: $e');
      return ''; // Safe fallback
    }
  }

  /// Send a new vibe (voice + optional photo/video)
  /// 
  /// For photo vibes: audioFile + imageFile
  /// For video vibes: videoFile (audio is embedded in video)
  Future<VibeModel?> sendVibe({
    required String receiverId,
    File? audioFile,  // Optional for video vibes (audio embedded in video)
    required int audioDuration,
    required List<double> waveformData,
    File? imageFile,
    File? videoFile,
    bool isVideo = false,
    bool isAudioOnly = false,  // Audio-only vibe with blurred profile background
    bool isFromGallery = false,
    DateTime? originalPhotoDate,
    String? replyToVibeId,
  }) async {
    String? bgTaskId;
    try {
      final senderId = _authService.currentUserId;
      if (senderId == null) return null;

      // Get sender info
      final senderDoc = await _firestore
          .collection(AppConstants.usersCollection)
          .doc(senderId)
          .get();
      final senderData = senderDoc.data();
      final senderName = senderData?['displayName'] ?? 'Unknown';
      final senderAvatar = senderData?['avatarUrl'];

      // ðŸ›¡ï¸ STEP 1: PREPARE VAD GATEKEEPER (Parallel Pipeline)
      // We no longer await this here. It will run in parallel with uploads.
      Future<File?>? extractedAudioFuture;
      final mediaFile = videoFile ?? audioFile;
      if (mediaFile != null) {
        debugPrint('ðŸ›¡ï¸ VibeService: VAD Gatekeeper queued for parallel execution...');
        extractedAudioFuture = GatekeeperService.instance.hasSpeech(mediaFile, isVideo: isVideo);
      }

      // ðŸ›¡ï¸ STEP 2: START BACKGROUND SURVIVAL TASK
      // This ensures the process lives for ~3 minutes even if swiped away.
      bgTaskId = await BackgroundUploadService.startTask(
          title: 'Sending Vibe to $senderName',
          subtitle: 'Uploading media...',
      );

      // Generate unique IDs
      final vibeId = _uuid.v4();
      final timestamp = DateTime.now();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // PARALLEL PIPELINE: Upload + Transcribe simultaneously
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      debugPrint('â˜ï¸ VibeService: Starting parallel pipeline with survival hook $bgTaskId...');
      
      String? audioUrl;
      String? imageUrl;
      String? videoUrl;
      String? transcription;

      // ðŸ›¡ï¸ 2026 GOLD STANDARD: Track overall progress for system-level prioritization
      double audioProgress = 0.0;
      double imageProgress = 0.0;
      double videoProgress = 0.0;

      void updateOverallProgress() {
        if (bgTaskId == null) return;
        int activeTasksCount = (audioFile != null ? 1 : 0) + 
                               (imageFile != null ? 1 : 0) + 
                               (videoFile != null ? 1 : 0);
        if (activeTasksCount == 0) return;
        
        double total = (audioProgress + imageProgress + videoProgress) / activeTasksCount;
        BackgroundUploadService.updateProgress(bgTaskId!, total, 'Uploading media (${(total * 100).toInt()}%)...');
      }
      
      // Create all parallel tasks
      final List<Future<dynamic>> parallelTasks = [];
      
      // Task A: Audio upload (for photo vibes)
      Future<String?>? audioFuture;
      if (audioFile != null && await audioFile.exists()) {
        final size = await audioFile.length();
        debugPrint('ðŸ” VibeService: Adding Audio upload task (size=$size bytes)...');
        audioFuture = _cloudinary.uploadAudio(
          audioFile, 
          onProgress: (p) { audioProgress = p; updateOverallProgress(); }
        );
        parallelTasks.add(audioFuture);
      } else {
        debugPrint('ðŸ” VibeService: No Audio file to upload (or missing).');
      }
      
      // Task B: Image upload
      Future<String?>? imageFuture;
      if (imageFile != null && await imageFile.exists()) {
        final size = await imageFile.length();
        debugPrint('ðŸ” VibeService: Adding Image upload task (size=$size bytes)...');
        imageFuture = _cloudinary.uploadImage(
          imageFile,
          onProgress: (p) { imageProgress = p; updateOverallProgress(); }
        );
        parallelTasks.add(imageFuture);
      } else {
        debugPrint('ðŸ” VibeService: No Image file to upload (or missing).');
      }
      
      // Task C: Video upload
      Future<String?>? videoFuture;
      if (videoFile != null && isVideo && await videoFile.exists()) {
        final size = await videoFile.length();
        debugPrint('ðŸ” VibeService: Adding Video upload task (size=$size bytes)...');
        videoFuture = _cloudinary.uploadVideo(
          videoFile,
          onProgress: (p) { videoProgress = p; updateOverallProgress(); }
        );
        parallelTasks.add(videoFuture);
      }
      
      // Task D: Gatekeeper VAD + Transcription
      Future<String?>? transcriptionTask;
      if (extractedAudioFuture != null) {
        transcriptionTask = extractedAudioFuture.then((file) async {
          if (file == null) return null;
          final transcriptionService = TranscriptionService();
          final text = await transcriptionService.transcribeFile(file);
          try { if (await file.exists()) await file.delete(); } catch (_) {}
          return text;
        });
        parallelTasks.add(transcriptionTask);
      }
      
      // Execute all tasks in parallel
      // ðŸ›¡ï¸ STABILITY FIX: Individual task error handling to prevent total pipeline failure
      await Future.wait(parallelTasks.map((task) => task.catchError((e) {
            debugPrint('âš ï¸ VibeService Task Error: $e');
            return null; // Fail-Safe: Let other tasks finish
          })));
      
      // Get the results (Futures are already completed)
      if (audioFuture != null) {
        audioUrl = await audioFuture.catchError((_) => null);
      }
      if (imageFuture != null) {
        imageUrl = await imageFuture.catchError((_) => null);
      }
      if (videoFuture != null) {
        videoUrl = await videoFuture.catchError((_) => null);
      }
      if (transcriptionTask != null) {
        transcription = await transcriptionTask.catchError((_) => null);
      }
      
      debugPrint('â˜ï¸ VibeService: Parallel pipeline complete!');
      debugPrint('â˜ï¸ VibeService: audioUrl=$audioUrl');
      debugPrint('â˜ï¸ VibeService: imageUrl=$imageUrl');
      debugPrint('â˜ï¸ VibeService: videoUrl=$videoUrl');
      debugPrint('ðŸ“ VibeService: transcription=${transcription?.substring(0, transcription.length > 50 ? 50 : transcription.length) ?? "none"}...');
      
      // ðŸª Generate 3-Word Hook for widget engagement (after transcription)
      String? widgetHook;
      if (transcription != null && transcription.isNotEmpty) {
        final transcriptionService = TranscriptionService();
        widgetHook = await transcriptionService.generateWidgetHook(transcription);
        debugPrint('ðŸª VibeService: Generated widget hook: $widgetHook');
      }
      
      // Note: extractedAudioFile cleanup moved inside transcriptionTask for reliability
      
      // Validate that we got at least one media file uploaded
      debugPrint('ðŸ” VibeService: Validation - audioUrlPresent=${audioUrl != null}, imageUrlPresent=${imageUrl != null}, videoUrlPresent=${videoUrl != null}');
      if (audioUrl == null && imageUrl == null && videoUrl == null) {
        debugPrint('âŒ VibeService: All media uploads failed (Null response from Cloudinary)');
        return null;
      }

      // Create vibe model WITH transcription AND hook already populated
      final vibe = VibeModel(
        id: vibeId,
        senderId: senderId,
        senderName: senderName,
        senderAvatar: senderAvatar,
        receiverId: receiverId,
        audioUrl: audioUrl ?? '',  // Empty for video vibes (audio embedded in video)
        imageUrl: imageUrl,
        videoUrl: videoUrl,
        isVideo: isVideo,
        isAudioOnly: isAudioOnly || (audioFile != null && imageFile == null && videoFile == null),
        audioDuration: audioDuration,
        waveformData: waveformData,
        createdAt: timestamp,
        isFromGallery: isFromGallery,
        originalPhotoDate: originalPhotoDate,
        transcription: transcription, // ALREADY POPULATED from parallel pipeline
        widgetHook: widgetHook, // ðŸª AI-generated engagement hook
        replyVibeId: replyToVibeId,
      );

      // Save to Firestore (transcription and hook already included!)
      await _firestore
          .collection(AppConstants.vibesCollection)
          .doc(vibeId)
          .set(vibe.toFirestore());

      // Update receiver's widget state (use widgetHook instead of truncated preview)
      await _updateReceiverWidgetState(receiverId, vibe, skipTranscription: true, precomputedTranscription: transcription, widgetHook: widgetHook);

      // Update friendship health
      await _updateFriendshipActivity(senderId, receiverId);

      // ðŸ”„ LOCAL SYNC: Update the sender's own widget immediately to reflect the "Sent" status
      // This makes the app feel "real-time" on your own device.
      WidgetUpdateService.refreshAllWidgets([vibe]);

      return vibe;
    } catch (e) {
      print('Error sending vibe: $e');
      return null;
    } finally {
      // ðŸ›¡ï¸ STEP 3: RELEASE BACKGROUND SURVIVAL TASK
      await BackgroundUploadService.stopTask(bgTaskId);
    }
  }

  /// Update receiver's widget state for instant widget updates
  /// ðŸ“ Now supports precomputed transcription from parallel pipeline
  /// ðŸª Prioritizes AI-generated widgetHook over truncated transcription
  Future<void> _updateReceiverWidgetState(
      String receiverId, VibeModel vibe, {bool skipTranscription = false, String? precomputedTranscription, String? widgetHook}) async {
    // ðŸª 3-Word Hook Strategy: Use AI hook for maximum engagement
    // Falls back to truncated transcription if hook generation failed
    String? transcriptionPreview;
    
    if (widgetHook != null && widgetHook.isNotEmpty) {
      // BEST: Use AI-generated hook for maximum curiosity gap
      transcriptionPreview = widgetHook;
      debugPrint('ðŸª VibeService: Using AI hook for widget: $widgetHook');
    } else if (precomputedTranscription != null && precomputedTranscription.isNotEmpty) {
      // FALLBACK: Use truncated transcription (no round-trip needed!)
      transcriptionPreview = precomputedTranscription.length > 50 
          ? '${precomputedTranscription.substring(0, 50)}...' 
          : precomputedTranscription;
      debugPrint('ðŸ“ VibeService: Using truncated transcription for widget.');
    } else if (!skipTranscription) {
      // LEGACY: URL-based transcription (only for old code paths)
      final String mediaUrlToTranscribe = vibe.audioUrl.isNotEmpty 
          ? vibe.audioUrl 
          : (vibe.videoUrl ?? '');

      if (mediaUrlToTranscribe.isNotEmpty) {
        try {
          final transcriptionService = TranscriptionService();
          final fullText = await transcriptionService.transcribeFromUrl(mediaUrlToTranscribe);
          if (fullText != null && fullText.isNotEmpty) {
            transcriptionPreview = fullText.length > 50 
                ? '${fullText.substring(0, 50)}...' 
                : fullText;
            
            // Save full transcription to the vibe doc
            await _firestore.collection(AppConstants.vibesCollection).doc(vibe.id).update({
              'transcription': fullText,
            }).catchError((e) => debugPrint('VibeService: Failed to save persistent transcription: $e'));
          }
        } catch (e) {
          print('VibeService: Transcription failed (non-critical): $e');
        }
      }
    }
    
    final widgetState = WidgetState(
      latestVibeId: vibe.id,
      latestAudioUrl: vibe.audioUrl,
      // ðŸ–¼ï¸ Use thumbnail for widget (prevents 30MB crash on iOS)
      latestImageUrl: getWidgetImageUrl(vibe.imageUrl),
      senderName: vibe.senderName,
      senderAvatar: vibe.senderAvatar,
      audioDuration: vibe.audioDuration,
      waveformData: vibe.waveformData,
      timestamp: vibe.createdAt,
      isPlayed: false,
      transcriptionPreview: transcriptionPreview, // ðŸª Now contains AI hook!
      // ðŸŽ¬ 4-State Widget Protocol: Content type flags
      isVideo: vibe.isVideo,
      isAudioOnly: vibe.isAudioOnly,
      videoUrl: vibe.videoUrl,
    );


    // FIX 4: Widget Privacy Security
    // Move widgetState to a private sub-collection so message previews aren't public
    // Matches path: users/{uid}/private/widget_data
    await _firestore
        .collection(AppConstants.usersCollection)
        .doc(receiverId)
        .collection('private')
        .doc('widget_data')
        .set({'widgetState': widgetState.toMap()});
        
    // Also clear the legacy public field if it exists
    await _firestore
        .collection(AppConstants.usersCollection)
        .doc(receiverId)
        .update({'widgetState': FieldValue.delete()}).catchError((_) {});
  }

  /// Update friendship activity for health tracking
  /// ðŸŒ± Uses Friendship Garden model - gardens thrive with activity
  Future<void> _updateFriendshipActivity(
      String senderId, String receiverId) async {
    // Find friendship document
    final friendshipQuery = await _firestore
        .collection(AppConstants.friendshipsCollection)
        .where('userId', isEqualTo: senderId)
        .where('friendId', isEqualTo: receiverId)
        .limit(1)
        .get();

    if (friendshipQuery.docs.isNotEmpty) {
      final doc = friendshipQuery.docs.first;

      await doc.reference.update({
        'lastVibeAt': Timestamp.now(),
        'health': 'thriving',  // ðŸŒ¸ Friendship Garden: thriving (not "healthy")
      });

      // SYNC TO WIDGET: Update the BFF widget data for this friend
      try {
        final receiverDoc = await _firestore
            .collection(AppConstants.usersCollection)
            .doc(receiverId)
            .get();
        
        if (receiverDoc.exists) {
          final receiverData = receiverDoc.data();
          await WidgetUpdateService.updateBFFWidget(
            friendId: receiverId,
            friendName: receiverData?['displayName'] ?? 'Friend',
            avatarUrl: receiverData?['avatarUrl'],
          );
        }
      } catch (e) {
        debugPrint('VibeService: Failed to update BFF widget: $e');
      }
    }
  }

  /// Mark vibe as played
  Future<void> markAsPlayed(String vibeId) async {
    await _firestore.collection(AppConstants.vibesCollection).doc(vibeId).update({
      'isPlayed': true,
      'playedAt': Timestamp.now(),
    });

    // Update widget state
    final userId = _authService.currentUserId;
    if (userId != null) {
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(userId)
          .collection('private')
          .doc('widget_data')
          .update({'widgetState.isPlayed': true});
    }
  }



  /// Reply to a vibe
  Future<VibeModel?> replyToVibe({
    required String originalVibeId,
    required String receiverId,
    required File audioFile,
    required int audioDuration,
    required List<double> waveformData,
  }) async {
    final vibe = await sendVibe(
      receiverId: receiverId,
      audioFile: audioFile,
      audioDuration: audioDuration,
      waveformData: waveformData,
      replyToVibeId: originalVibeId,
    );

    if (vibe != null) {
      // Link to original vibe
      await _firestore
          .collection(AppConstants.vibesCollection)
          .doc(vibe.id)
          .update({'replyVibeId': originalVibeId});
    }

    return vibe;
  }

  /// Get vibes grouped by date for Vault calendar view
  Future<Map<DateTime, List<VibeModel>>> getVibesByDate() async {
    final userId = _authService.currentUserId;
    if (userId == null) return {};

    final snapshot = await _firestore
        .collection(AppConstants.vibesCollection)
        .where('receiverId', isEqualTo: userId)
        .orderBy('createdAt', descending: true)
        .get();

    final vibes = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
    
    final Map<DateTime, List<VibeModel>> grouped = {};
    for (final vibe in vibes) {
      final date = DateTime(
        vibe.createdAt.year,
        vibe.createdAt.month,
        vibe.createdAt.day,
      );
      grouped[date] ??= [];
      grouped[date]!.add(vibe);
    }

    return grouped;
  }

  /// Block a user
  Future<void> blockUser(String userIdToBlock) async {
    final userId = _authService.currentUserId;
    if (userId == null) return;

    try {
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(userId)
          .update({
        'blockedUserIds': FieldValue.arrayUnion([userIdToBlock])
      });
      debugPrint('VibeService: User $userIdToBlock blocked by $userId');
    } catch (e) {
      debugPrint('VibeService: Error blocking user: $e');
      rethrow;
    }
  }

  /// Unblock a user
  Future<void> unblockUser(String userIdToUnblock) async {
    final userId = _authService.currentUserId;
    if (userId == null) return;

    try {
      await _firestore
          .collection(AppConstants.usersCollection)
          .doc(userId)
          .update({
        'blockedUserIds': FieldValue.arrayRemove([userIdToUnblock])
      });
      debugPrint('VibeService: User $userIdToUnblock unblocked by $userId');
    } catch (e) {
      debugPrint('VibeService: Error unblocking user: $e');
      rethrow;
    }
  }

  /// Report a vibe for Guideline 1.2 compliance
  Future<void> reportVibe({
    required String vibeId,
    required String reporterId,
    required String reason,
  }) async {
    try {
      await _firestore.collection('reports').add({
        'vibeId': vibeId,
        'reporterId': reporterId,
        'reason': reason,
        'createdAt': FieldValue.serverTimestamp(),
        'status': 'pending',
      });
      debugPrint('VibeService: Vibe $vibeId reported by $reporterId');
    } catch (e) {
      debugPrint('VibeService: Error reporting vibe: $e');
      rethrow;
    }
  }
  
  /// Get a single vibe by ID
  /// Used for widget click handling - when user taps widget, navigate to that specific vibe
  Future<VibeModel?> getVibeById(String vibeId) async {
    try {
      final doc = await _firestore
          .collection(AppConstants.vibesCollection)
          .doc(vibeId)
          .get();
      
      if (doc.exists) {
        return VibeModel.fromFirestore(doc);
      }
      return null;
    } catch (e) {
      return null;
    }
  }

  /// Add transcription to an existing vibe (for "Read-First" persistence)
  Future<void> saveTranscription(String vibeId, String text) async {
    await _firestore.collection(AppConstants.vibesCollection).doc(vibeId).update({
      'transcription': text,
    });
  }

  /// Add a text reply to a vibe (Visual Whispers)
  Future<void> sendTextReply(String vibeId, String text) async {
    final senderId = _authService.currentUserId;
    if (senderId == null) return;

    final senderDoc = await _firestore.collection(AppConstants.usersCollection).doc(senderId).get();
    final senderName = senderDoc.data()?['displayName'] ?? 'Unknown';

    final reply = TextReply(
      senderId: senderId,
      senderName: senderName,
      text: text,
      createdAt: DateTime.now(),
    );

    await _firestore.collection(AppConstants.vibesCollection).doc(vibeId).update({
      'textReplies': FieldValue.arrayUnion([reply.toMap()]),
    });
  }

  /// Add an emoji reaction to a vibe (Quick Reactions)
  Future<void> addReaction(String vibeId, String emoji) async {
    final userId = _authService.currentUserId;
    if (userId == null) return;

    final reaction = VibeReaction(
      userId: userId,
      emoji: emoji,
      createdAt: DateTime.now(),
    );

    await _firestore.collection(AppConstants.vibesCollection).doc(vibeId).update({
      'reactions': FieldValue.arrayUnion([reaction.toMap()]),
    });
  }
  
  /// Delete vibe for everyone (sender's right to erasure - GDPR Article 17)
  /// 
  /// CRITICAL: This allows the sender to delete their content from both:
  /// 1. Their own view
  /// 2. The receiver's view (including if receiver has Premium)
  /// 
  /// The sender's right to delete their data trumps the receiver's Premium Vault.
  Future<void> deleteVibeForEveryone(String vibeId) async {
    try {
      final userId = _authService.currentUserId;
      if (userId == null) {
        debugPrint('VibeService: Cannot delete vibe - user not authenticated');
        return;
      }
      
      // 1. Get vibe to verify sender and get media URLs
      final vibeDoc = await _firestore
          .collection(AppConstants.vibesCollection)
          .doc(vibeId)
          .get();
      
      if (!vibeDoc.exists) {
        debugPrint('VibeService: Vibe $vibeId not found');
        return;
      }
      
      final vibe = VibeModel.fromFirestore(vibeDoc);
      
      // 2. Verify current user is the sender
      if (vibe.senderId != userId) {
        debugPrint('VibeService: User $userId is not the sender of vibe $vibeId');
        throw Exception('You can only delete vibes you sent');
      }
      
      debugPrint('VibeService: Deleting vibe $vibeId sent by $userId');
      
      // 3. Delete media from Cloudinary (best effort - don't block on failure)
      final deleteFutures = <Future<bool>>[];
      
      if (vibe.imageUrl != null && vibe.imageUrl!.isNotEmpty) {
        deleteFutures.add(_cloudinary.deleteAsset(vibe.imageUrl!));
      }
      if (vibe.videoUrl != null && vibe.videoUrl!.isNotEmpty) {
        deleteFutures.add(_cloudinary.deleteAsset(vibe.videoUrl!));
      }
      if (vibe.audioUrl.isNotEmpty) {
        deleteFutures.add(_cloudinary.deleteAsset(vibe.audioUrl));
      }
      
      // Wait for deletions (with timeout)
      if (deleteFutures.isNotEmpty) {
        await Future.wait(deleteFutures).timeout(
          const Duration(seconds: 5),
          onTimeout: () {
            debugPrint('VibeService: Cloudinary deletions timed out (non-critical)');
            return [];
          },
        );
      }
      
      // 4. Mark vibe as deleted in Firestore (soft delete for audit trail)
      await _firestore.collection(AppConstants.vibesCollection).doc(vibeId).update({
        'isDeleted': true,
        'deletedAt': FieldValue.serverTimestamp(),
        'deletedBy': userId,
        // Clear media URLs to prevent access
        'imageUrl': null,
        'videoUrl': null,
        'audioUrl': '',
      });
      
      // 5. Update receiver's widget state if this was their latest vibe
      await _clearWidgetIfLatest(vibe.receiverId, vibeId);
      
      debugPrint('VibeService: Vibe $vibeId deleted successfully');
    } catch (e) {
      debugPrint('VibeService: Error deleting vibe: $e');
      rethrow;
    }
  }
  
  /// Clear receiver's widget if the deleted vibe was their latest one
  Future<void> _clearWidgetIfLatest(String receiverId, String deletedVibeId) async {
    try {
      final widgetDoc = await _firestore
          .collection(AppConstants.usersCollection)
          .doc(receiverId)
          .collection('private')
          .doc('widget_data')
          .get();
      
      if (!widgetDoc.exists) return;
      
      final widgetData = widgetDoc.data();
      final latestVibeId = widgetData?['widgetState']?['latestVibeId'];
      
      if (latestVibeId == deletedVibeId) {
        // Clear the widget - user will see "No recent vibes"
        await _firestore
            .collection(AppConstants.usersCollection)
            .doc(receiverId)
            .collection('private')
            .doc('widget_data')
            .delete();
        
        debugPrint('VibeService: Cleared widget for receiver $receiverId');
      }
    } catch (e) {
      debugPrint('VibeService: Error clearing widget: $e (non-critical)');
    }
  }
}



========================================

FILE #30: E:\Vive\lib\core\services\viral_video_service.dart

========================================


import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:ffmpeg_kit_flutter_new_https/ffmpeg_kit.dart';
import 'package:ffmpeg_kit_flutter_new_https/return_code.dart';
import 'package:ffmpeg_kit_flutter_new_https/ffmpeg_session.dart';
import 'package:appinio_social_share/appinio_social_share.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'package:http/http.dart' as http;
import 'package:permission_handler/permission_handler.dart';
import 'package:device_info_plus/device_info_plus.dart';

/// Viral Video Service - The "Share Your Aura" Engine
/// 
/// Generates TikTok/Instagram-ready MP4 videos from image + audio.
/// Uses FFmpeg to create a polished, 9:16 video with blurred background.
class ViralVideoService {
  final AppinioSocialShare _socialShare = AppinioSocialShare();

  /// Generate a viral-ready MP4 video
  Future<File?> generateViralVideo({
    required String imagePath,
    required String audioPath,
    void Function(double progress)? onProgress,
  }) async {
    try {
      final dir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final outputPath = '${dir.path}/vibe_viral_$timestamp.mp4';

      final file = File(outputPath);
      if (await file.exists()) await file.delete();

      onProgress?.call(0.1);

      final List<String> args = [
        '-y',
        '-hwaccel', 'auto',
        '-loop', '1',
        '-i', imagePath,
        '-hwaccel', 'auto',
        '-i', audioPath,
        
        // COMPLEX FILTERS: Blurred background + scaled foreground
        '-filter_complex',
        '[0:v]scale=1080:1920:force_original_aspect_ratio=increase,crop=1080:1920,boxblur=20[bg];'
        '[0:v]scale=1080:-1[fg];'
        '[bg][fg]overlay=(W-w)/2:(H-h)/2',
        
        // 1. FORCE FRAMERATE & KEYFRAMES (TikTok/IG stability)
        '-r', '30',
        '-g', '60',
        '-keyint_min', '60',
        '-pix_fmt', 'yuv420p',
        '-movflags', '+faststart',
        
        // 2. HARDWARE ENCODING (LGPL Compliant)
        '-c:v', Platform.isIOS ? 'h264_videotoolbox' : 'h264_mediacodec',
      ];

      if (Platform.isIOS) {
        args.addAll(['-b:v', '4M', '-profile:v', 'high']);
      } else {
        // h264_mediacodec for Android
        args.addAll(['-b:v', '4M', '-profile:v', 'high']);
      }

      args.addAll([
        '-c:a', 'aac',
        '-b:a', '192k',
        '-shortest',
        outputPath,
      ]);

      debugPrint('ViralVideo: Generating video with args: $args');
      onProgress?.call(0.2);

      // Async execution to prevent UI thread blocking
      final session = await FFmpegKit.executeWithArgumentsAsync(args);
      final returnCode = await session.getReturnCode();

      onProgress?.call(0.9);

      if (ReturnCode.isSuccess(returnCode)) {
        debugPrint('ViralVideo: SUCCESS - Video saved to $outputPath');
        onProgress?.call(1.0);
        return File(outputPath);
      } else {
        final logs = await session.getOutput();
        debugPrint('ViralVideo: FFmpeg Error: $logs');
        return null;
      }
    } catch (e) {
      debugPrint('ViralVideo: Error generating video: $e');
      return null;
    }
  }

  /// Generate video from URLs (downloads files first)
  Future<File?> generateFromUrls({
    required String imageUrl,
    required String audioUrl,
    void Function(double progress)? onProgress,
  }) async {
    try {
      final tempDir = await getTemporaryDirectory();
      
      onProgress?.call(0.05);
      
      debugPrint('ViralVideo: Downloading image...');
      final imageResponse = await http.get(Uri.parse(imageUrl));
      if (imageResponse.statusCode != 200) {
        debugPrint('ViralVideo: Failed to download image');
        return null;
      }
      final imagePath = '${tempDir.path}/viral_image_${DateTime.now().millisecondsSinceEpoch}.jpg';
      await File(imagePath).writeAsBytes(imageResponse.bodyBytes);
      
      onProgress?.call(0.2);
      
      debugPrint('ViralVideo: Downloading audio...');
      final audioResponse = await http.get(Uri.parse(audioUrl));
      if (audioResponse.statusCode != 200) {
        debugPrint('ViralVideo: Failed to download audio');
        return null;
      }
      final audioPath = '${tempDir.path}/viral_audio_${DateTime.now().millisecondsSinceEpoch}.m4a';
      await File(audioPath).writeAsBytes(audioResponse.bodyBytes);
      
      onProgress?.call(0.4);
      
      return await generateViralVideo(
        imagePath: imagePath,
        audioPath: audioPath,
        onProgress: (p) => onProgress?.call(0.4 + p * 0.6),
      );
    } catch (e) {
      debugPrint('ViralVideo: Error generating from URLs: $e');
      return null;
    }
  }

  /// Download an existing video file for sharing
  Future<File?> downloadVideo(String url, {void Function(double progress)? onProgress}) async {
    try {
      final tempDir = await getTemporaryDirectory();
      onProgress?.call(0.1);
      
      debugPrint('ViralVideo: Downloading existing video from $url');
      final response = await http.get(Uri.parse(url));
      onProgress?.call(0.8);
      
      if (response.statusCode != 200) {
        debugPrint('ViralVideo: Failed to download video (${response.statusCode})');
        return null;
      }
      
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final path = '${tempDir.path}/vibe_shared_video_$timestamp.mp4';
      final file = File(path);
      await file.writeAsBytes(response.bodyBytes);
      
      onProgress?.call(1.0);
      debugPrint('ViralVideo: Video downloaded to $path');
      return file;
    } catch (e) {
      debugPrint('ViralVideo: Error downloading video: $e');
      return null;
    }
  }

  /// Check if Instagram is installed
  Future<bool> isInstagramInstalled() async {
    try {
      final apps = await _socialShare.getInstalledApps();
      return apps['instagram'] == true;
    } catch (e) {
      return false;
    }
  }

  /// Check if TikTok is installed
  Future<bool> isTikTokInstalled() async {
    try {
      final apps = await _socialShare.getInstalledApps();
      return apps['tiktok'] == true;
    } catch (e) {
      return false;
    }
  }

  /// Get all installed sharing apps
  Future<Map<String, bool>> getInstalledApps() async {
    try {
      final result = await _socialShare.getInstalledApps();
      return Map<String, bool>.from(result);
    } catch (e) {
      return {};
    }
  }

  /// Check Android permissions based on SDK version
  Future<void> _checkAndroidPermissions() async {
    if (Platform.isAndroid) {
      final androidInfo = await DeviceInfoPlugin().androidInfo;
      if (androidInfo.version.sdkInt >= 33) {
        await Permission.photos.request();
        await Permission.videos.request();
      } else {
        await Permission.storage.request();
      }
    }
  }

  /// Share to Instagram Stories
  /// Android/iOS: shareToInstagramStory(String appId, {stickerImage, backgroundImage, backgroundVideo, ...})
  Future<String> shareToInstagramStories({
    required String videoPath,
    String? facebookAppId,
    String? attributionUrl,
  }) async {
    try {
      await _checkAndroidPermissions();

      String? result;
      final appId = facebookAppId ?? 'YOUR_FB_APP_ID';
      
      if (Platform.isAndroid) {
        // Android: shareToInstagramStory(appId, {stickerImage, backgroundImage, backgroundVideo, ...})
        result = await _socialShare.android.shareToInstagramStory(
          appId,  // First positional arg: appId
          backgroundVideo: videoPath,
          backgroundTopColor: '#000000',
          backgroundBottomColor: '#000000',
          attributionURL: attributionUrl ?? 'https://getvibe.app',
        );
      } else if (Platform.isIOS) {
        // iOS: shareToInstagramStory(appId, {stickerImage, backgroundImage, backgroundVideo, ...})
        result = await _socialShare.iOS.shareToInstagramStory(
          appId,  // First positional arg: appId
          backgroundVideo: videoPath,
          backgroundTopColor: '#000000',
          backgroundBottomColor: '#000000',
          attributionURL: attributionUrl ?? 'https://getvibe.app',
        );
      }

      debugPrint('ViralVideo: Instagram Stories share result: $result');
      return result ?? 'success';
    } catch (e) {
      debugPrint('ViralVideo: Error sharing to Instagram Stories: $e');
      return await shareToSystem(videoPath, 'Check out my Vibe! ðŸŽ¤');
    }
  }

  /// Share to Instagram Feed/Reels
  /// Android: shareToInstagramFeed(message, filePath) - 2 positional args
  /// iOS: shareToInstagramReels(videoPath) - 1 positional arg
  Future<String> shareToInstagramReels(String videoPath) async {
    try {
      await _checkAndroidPermissions();

      String? result;
      if (Platform.isAndroid) {
        // Android: shareToInstagramFeed(String message, String? filePath)
        result = await _socialShare.android.shareToInstagramFeed('', videoPath);
      } else if (Platform.isIOS) {
        // iOS: shareToInstagramReels(String videoPath)
        result = await _socialShare.iOS.shareToInstagramReels(videoPath);
      }
      
      return result ?? 'success';
    } catch (e) {
      debugPrint('ViralVideo: Error sharing to Instagram Reels: $e');
      return await shareToSystem(videoPath, 'Check out my Vibe! ðŸŽ¤');
    }
  }

  /// Share to TikTok
  /// Android: shareToTiktokStatus(List<String> filePaths)
  /// iOS: shareToTiktokPost(videoFile, redirectUrl, TiktokFileType) - requires TikTok SDK setup
  Future<String> shareToTikTok(String videoPath) async {
    try {
      if (Platform.isAndroid) {
        await _checkAndroidPermissions();
        
        // Android: shareToTiktokStatus(List<String> filePaths)
        final result = await _socialShare.android.shareToTiktokStatus([videoPath]);
        return result;
      } else {
        // iOS requires TikTok SDK setup - fallback to system share
        debugPrint('ViralVideo: iOS TikTok requires SDK setup, using system share');
        return await shareToSystem(videoPath, 'Check out my Vibe! ðŸŽ¤ #vibeapp');
      }
    } catch (e) {
      debugPrint('ViralVideo: Error sharing to TikTok: $e');
      return await shareToSystem(videoPath, 'Check out my Vibe! ðŸŽ¤ #vibeapp');
    }
  }

  /// Share to WhatsApp
  /// Android: shareToWhatsapp(message, filePath) - 2 positional args
  /// iOS: shareToWhatsapp(message) - only text supported
  Future<String> shareToWhatsApp(String videoPath, String message) async {
    try {
      String? result;
      if (Platform.isAndroid) {
        // Android: shareToWhatsapp(String message, String? filePath)
        result = await _socialShare.android.shareToWhatsapp(message, videoPath);
      } else if (Platform.isIOS) {
        // iOS only supports text - use system share for files
        return await shareToSystem(videoPath, message);
      }
      return result ?? 'success';
    } catch (e) {
      debugPrint('ViralVideo: Error sharing to WhatsApp: $e');
      return await shareToSystem(videoPath, message);
    }
  }

  /// Share to system share sheet (THE ULTIMATE FALLBACK)
  /// Uses share_plus which is rock-solid
  Future<String> shareToSystem(String videoPath, String message) async {
    try {
      final file = XFile(videoPath);
      await Share.shareXFiles(
        [file],
        text: message,
        subject: 'My Vibe',
      );
      return 'success';
    } catch (e) {
      debugPrint('ViralVideo: Error sharing to system: $e');
      return 'error: $e';
    }
  }
}

/// Provider for ViralVideoService
final viralVideoServiceProvider = Provider<ViralVideoService>((ref) {
  return ViralVideoService();
});

/// State for tracking video generation
class ViralVideoState {
  final bool isGenerating;
  final double progress;
  final File? outputFile;
  final String? error;

  const ViralVideoState({
    this.isGenerating = false,
    this.progress = 0.0,
    this.outputFile,
    this.error,
  });

  ViralVideoState copyWith({
    bool? isGenerating,
    double? progress,
    File? outputFile,
    String? error,
  }) {
    return ViralVideoState(
      isGenerating: isGenerating ?? this.isGenerating,
      progress: progress ?? this.progress,
      outputFile: outputFile ?? this.outputFile,
      error: error ?? this.error,
    );
  }
}

/// State notifier for viral video generation
class ViralVideoNotifier extends StateNotifier<ViralVideoState> {
  final ViralVideoService _service;

  ViralVideoNotifier(this._service) : super(const ViralVideoState());

  Future<File?> generateAndShare({
    required String imageUrl,
    required String audioUrl,
    String? platform,
    String? message,
  }) async {
    state = state.copyWith(isGenerating: true, progress: 0.0, error: null);

    try {
      final videoFile = await _service.generateFromUrls(
        imageUrl: imageUrl,
        audioUrl: audioUrl,
        onProgress: (p) => state = state.copyWith(progress: p * 0.8),
      );

      if (videoFile == null) {
        state = state.copyWith(
          isGenerating: false,
          error: 'Failed to generate video',
        );
        return null;
      }

      state = state.copyWith(progress: 0.9, outputFile: videoFile);

      if (platform != null) {
        switch (platform) {
          case 'instagram':
            await _service.shareToInstagramStories(videoPath: videoFile.path);
            break;
          case 'reels':
            await _service.shareToInstagramReels(videoFile.path);
            break;
          case 'tiktok':
            await _service.shareToTikTok(videoFile.path);
            break;
          case 'whatsapp':
            await _service.shareToWhatsApp(videoFile.path, message ?? '');
            break;
          default:
            await _service.shareToSystem(videoFile.path, message ?? '');
        }
      }

      state = state.copyWith(isGenerating: false, progress: 1.0);
      return videoFile;
    } catch (e) {
      state = state.copyWith(
        isGenerating: false,
        error: e.toString(),
      );
      return null;
    }
  }

  void reset() {
    state = const ViralVideoState();
  }
}

/// Provider for viral video state
final viralVideoStateProvider =
    StateNotifierProvider<ViralVideoNotifier, ViralVideoState>((ref) {
  final service = ref.watch(viralVideoServiceProvider);
  return ViralVideoNotifier(service);
});



========================================

FILE #31: E:\Vive\lib\core\services\widget_update_service.dart

========================================


import 'dart:convert';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:home_widget/home_widget.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'dart:typed_data';
import 'dart:isolate';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:image/image.dart' as img;
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import '../models/vibe_model.dart';

/// Widget Update Service
/// 
/// Handles the "Push-to-Update" pipeline for real-time widget synchronization.
/// This bridges the gap between Firebase updates and native widget refreshes.
class WidgetUpdateService {
  static const String androidWidgetName = 'NockWidgetProvider';
  static const String iOSWidgetName = 'VibeWidget';
  static const String appGroupId = 'group.com.nock.nock';  // MUST match iOS NockWidget.swift suiteName
  
  /// Helper to transform Cloudinary URLs to small thumbnails
  /// Prevents iOS Widget OOM (Out Of Memory) crashes by resizing 12MP images to ~300px
  static String _getThumbnailUrl(String url) {
    if (url.isEmpty) return '';
    if (!url.contains('cloudinary.com')) return url;
    
    // Inject transformation: width 300, quality 80
    // Replaces '/upload/' with '/upload/w_300,q_80/'
    return url.replaceAll('/upload/', '/upload/w_300,q_80/');
  }
  
  // Keys for pending read receipts (fixes "isPlayed" desync bug)
  static const String _pendingReadReceiptsKey = 'pending_read_receipts';

  WidgetUpdateService() {
    _initialize();
  }

  Future<void> _initialize() async {
    // Set the App Group ID for iOS
    if (Platform.isIOS) {
      await HomeWidget.setAppGroupId(appGroupId);
    }
  }
  
  /// CRITICAL FIX: Sync pending read receipts to Firestore
  /// 
  /// This fixes the "isPlayed" desynchronization bug where widgets mark vibes
  /// as played locally, but the status never syncs to Firestore.
  /// Called on app launch from main.dart.
  /// 
  /// IMPORTANT: On iOS, we MUST use HomeWidget to read the App Group container.
  /// SharedPreferences.getInstance() uses NSUserDefaults.standard (app sandbox),
  /// but the iOS widget writes to UserDefaults(suiteName: "group.com.vibe.vibe").
  /// These are DIFFERENT storage locations!
  static Future<void> syncPendingReadReceipts(String currentUserId) async {
    try {
      List<String> pendingReceipts = [];
      
      // PLATFORM-SPECIFIC FIX: Read from correct storage location
      // CRITICAL BUG FIX: On Android, Kotlin writes to "HomeWidgetPrefs" but
      // SharedPreferences.getInstance() reads from "FlutterSharedPreferences".
      // We MUST use HomeWidget.getWidgetData() to access the correct file!
      if (Platform.isIOS) {
        // iOS: Widget uses App Group, must read via HomeWidget
        await HomeWidget.setAppGroupId(appGroupId);
        final data = await HomeWidget.getWidgetData<String>('pending_read_receipts_json');
        if (data != null && data.isNotEmpty) {
          // iOS stores as JSON string for compatibility
          try {
            final List<dynamic> decoded = jsonDecode(data);
            pendingReceipts = decoded.map((e) => e.toString()).toList();
          } catch (_) {
            // Fallback: try comma-separated
            pendingReceipts = data.split(',').where((s) => s.isNotEmpty).toList();
          }
        }
      } else {
        // Android: CRITICAL FIX - Use HomeWidget to read from "HomeWidgetPrefs"
        // NOT SharedPreferences.getInstance() which reads from wrong file!
        // The Kotlin VibeWidgetProvider writes to getSharedPreferences("HomeWidgetPrefs", ...)
        // which is DIFFERENT from Flutter's default SharedPreferences location.
        
        // First try: Read as StringSet (how Kotlin stores it)
        final dataSet = await HomeWidget.getWidgetData<List<dynamic>>(_pendingReadReceiptsKey);
        if (dataSet != null && dataSet.isNotEmpty) {
          pendingReceipts = dataSet.map((e) => e.toString()).toList();
        } else {
          // Fallback: Try reading as JSON string
          final dataJson = await HomeWidget.getWidgetData<String>('pending_read_receipts_json');
          if (dataJson != null && dataJson.isNotEmpty) {
            try {
              final List<dynamic> decoded = jsonDecode(dataJson);
              pendingReceipts = decoded.map((e) => e.toString()).toList();
            } catch (_) {
              pendingReceipts = dataJson.split(',').where((s) => s.isNotEmpty).toList();
            }
          }
        }
      }
      
      if (pendingReceipts.isEmpty) return;
      
      debugPrint('WidgetUpdateService: Syncing ${pendingReceipts.length} pending read receipts');
      
      final batch = FirebaseFirestore.instance.batch();
      
      for (final vibeId in pendingReceipts) {
        if (vibeId.isEmpty) continue;
        
        final vibeRef = FirebaseFirestore.instance.collection('vibes').doc(vibeId);
        batch.update(vibeRef, {
          'isPlayed': true,
          'playedAt': FieldValue.serverTimestamp(),
        });
      }
      
      await batch.commit();
      
      // 5. ATOMIC CLEANUP: Re-read storage and merge (Fixes Race Condition)
      // Native code (iOS Widget) might have added new receipts during the async gap above.
      // We must only remove the ones we JUST successfully synced.
      
      if (Platform.isIOS) {
        final latestData = await HomeWidget.getWidgetData<String>('pending_read_receipts_json');
        List<String> latestReceipts = [];
        if (latestData != null && latestData.isNotEmpty) {
          try {
            final List<dynamic> decoded = jsonDecode(latestData);
            latestReceipts = decoded.map((e) => e.toString()).toList();
          } catch (_) {}
        }
        
        // Remove only the ones we synced
        latestReceipts.removeWhere((id) => pendingReceipts.contains(id));
        await HomeWidget.saveWidgetData('pending_read_receipts_json', jsonEncode(latestReceipts));
      } else {
        // Android Atomic Cleanup
        final latestDataSet = await HomeWidget.getWidgetData<List<dynamic>>(_pendingReadReceiptsKey);
        List<String> latestReceipts = [];
        if (latestDataSet != null) {
          latestReceipts = latestDataSet.map((e) => e.toString()).toList();
        }
        
        latestReceipts.removeWhere((id) => pendingReceipts.contains(id));
        
        // Save back as both types for compatibility
        await HomeWidget.saveWidgetData<String>('pending_read_receipts_json', jsonEncode(latestReceipts));
        await HomeWidget.saveWidgetData<String>(_pendingReadReceiptsKey, ''); // Clear old key
      }
      
      debugPrint('WidgetUpdateService: Read receipts synced successfully');
    } catch (e) {
      debugPrint('WidgetUpdateService: Error syncing read receipts: $e');
    }
  }
  
  /// Add a vibe ID to pending read receipts (called when played from widget)
  /// CRITICAL FIX: Must use HomeWidget to write to App Group, NOT SharedPreferences!
  /// SharedPreferences writes to app sandbox which iOS widget cannot access.
  static Future<void> addPendingReadReceipt(String vibeId) async {
    try {
      // Set App Group for iOS
      if (Platform.isIOS) {
        await HomeWidget.setAppGroupId(appGroupId);
      }
      
      // Read existing pending receipts from HomeWidget storage
      List<String> pendingReceipts = [];
      final existingData = await HomeWidget.getWidgetData<String>('pending_read_receipts_json');
      if (existingData != null && existingData.isNotEmpty) {
        try {
          final List<dynamic> decoded = jsonDecode(existingData);
          pendingReceipts = decoded.map((e) => e.toString()).toList();
        } catch (_) {
          // Fallback: try comma-separated
          pendingReceipts = existingData.split(',').where((s) => s.isNotEmpty).toList();
        }
      }
      
      // Add new receipt if not already present
      if (!pendingReceipts.contains(vibeId)) {
        pendingReceipts.add(vibeId);
        
        // Save back to HomeWidget storage (App Group on iOS, HomeWidgetPrefs on Android)
        await HomeWidget.saveWidgetData<String>(
          'pending_read_receipts_json',
          jsonEncode(pendingReceipts),
        );
        
        debugPrint('WidgetUpdateService: Added pending read receipt for $vibeId (total: ${pendingReceipts.length})');
      }
    } catch (e) {
      debugPrint('WidgetUpdateService: Error adding pending read receipt: $e');
    }
  }

  /// Update widget with new vibe data
  /// Called from FCM background handler when a silent push arrives
  /// 
  /// Supports 4-State Widget Protocol:
  /// 1. VIDEO: isVideo=true, imageUrl=thumbnail, videoUrl=mp4
  /// 2. AUDIO ONLY: isAudioOnly=true, imageUrl=avatar
  /// 3. IMAGE + AUDIO: isVideo=false, isAudioOnly=false, imageUrl=photo
  /// 4. IMAGE ONLY: audioUrl=null (not currently used in app)
  /// 
  /// ðŸš€ OPTIMIZED: Uses Future.wait() for parallel saves instead of sequential awaits
  /// This reduces background handler execution time from ~2s to ~200ms
  static Future<void> updateWidgetFromPush(Map<String, dynamic> data) async {
    try {
      debugPrint('WidgetUpdateService: Updating widget from push (optimized)');

      // Parse content type flags
      final bool isVideo = data['isVideo']?.toString().toLowerCase() == 'true';
      final bool isAudioOnly = data['isAudioOnly']?.toString().toLowerCase() == 'true';
      
      // CRITICAL: For video vibes, imageUrl should be the THUMBNAIL, not the video URL
      // The widget will try to decode the URL as an image. MP4s will crash/fail.
      String displayImageUrl = isAudioOnly 
          ? (data['senderAvatar'] ?? '') // Audio-only: Show sender avatar (usually small enough)
          : _getThumbnailUrl(data['imageUrl'] ?? '');    // Photo/Video: Transform to thumbnail

      // ðŸ“¥ CROSS-PLATFORM PRE-FETCH: Download image/avatar to local storage
      // This protects against OOM on iOS (Jetsam Limit) and Binder limits on Android.
      // We download, resize to <400px, and save locally.
      final vibeId = data['vibeId'] ?? '';
      
      if (displayImageUrl.isNotEmpty) {
        final localPath = await _downloadAndCache(
          url: displayImageUrl,
          // Use a consistent key so we can overwrite/clean up
          key: 'nock_image_${vibeId}', 
          description: 'Nock widget image'
        );
        
        // Critical: On iOS, the Widget reads from App Group using the key (bytes),
        // but we verify success here. On Android, we need the file path.
        if (localPath != null && !Platform.isIOS) {
          displayImageUrl = localPath;
        } else if (Platform.isIOS && localPath == null) {
          // If iOS download succeeded (returns null but saves bytes),
          // we should actually pass a flag or rely on the same logic.
          // However, iOS widget reads from App Group via key.
          // Wait, the Swift widget uses 'imageUrl' string to download URL if key missing.
          // We SHOULD pass the local key or path?
          // Actually, Swift VibeWidget.swift uses URL.
          // But if we save bytes to 'nock_image_$vibeId', does Swift read it?
          // Swift code check needed. Assuming strict report compliance:
          // Report says: "Download the image in the main app... pass the file path to the widget"
          // BUT HomeWidget on iOS only supports sharing file paths via App Group container sharing.
          // Let's stick to the reported fix: Enable the download cache logic.
          // The helper _downloadAndCache ALREADY handles iOS by saving to App Group key.
        }
      }

      // CRITICAL FIX: iOS widget expects a single JSON string at key 'vibeData'
      // Swift code: guard let jsonString = sharedDefaults?.string(forKey: "vibeData")
      // We must construct a JSON object and save it as a string
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final vibeData = {
        'senderName': data['senderName'] ?? 'Friend',
        'senderId': data['senderId'] ?? '',
        'audioUrl': data['audioUrl'] ?? '',
        'imageUrl': displayImageUrl,
        'videoUrl': isVideo ? (data['videoUrl'] ?? '') : '',
        'vibeId': vibeId,
        'timestamp': timestamp, // millisecondsSince1970 for Swift
        'isPlayed': false,
        'audioDuration': int.tryParse(data['audioDuration']?.toString() ?? '0') ?? 0,
        'distance': data['distance']?.toString() ?? '',
        // ðŸ“ Transcription-First: First 50 chars for glanceability
        // ðŸª Now contains AI-generated 3-word hook for maximum engagement
        'transcription': data['transcription']?.toString() ?? '',
        // ðŸŽ¬ NEW: Content type flags for 4-State Widget Protocol
        'isVideo': isVideo,
        'isAudioOnly': isAudioOnly,
      };
      
      // ðŸš€ PARALLEL BATCH: Execute all saves concurrently instead of sequentially
      // This is critical for background handler performance (Android ANR threshold is 10s)
      final List<Future<void>> saveFutures = [
        // iOS: Single JSON blob
        HomeWidget.saveWidgetData<String>('vibeData', jsonEncode(vibeData)),
        
        // Android: Individual keys (Android widget reads these directly)
        HomeWidget.saveWidgetData<String>('senderName', data['senderName'] ?? 'Friend'),
        HomeWidget.saveWidgetData<String>('senderId', data['senderId'] ?? ''),
        HomeWidget.saveWidgetData<String>('senderAvatar', data['senderAvatar'] ?? ''),
        HomeWidget.saveWidgetData<String>('audioUrl', data['audioUrl'] ?? ''),
        HomeWidget.saveWidgetData<String>('imageUrl', displayImageUrl),
        HomeWidget.saveWidgetData<String>('vibeId', vibeId),
        HomeWidget.saveWidgetData<int>('audioDuration', int.tryParse(data['audioDuration']?.toString() ?? '0') ?? 0),
        HomeWidget.saveWidgetData<bool>('isPlayed', false),
        HomeWidget.saveWidgetData<int>('timestamp', timestamp),
        HomeWidget.saveWidgetData<String>('distance', data['distance']?.toString() ?? ''),
        HomeWidget.saveWidgetData<String>('transcription', data['transcription']?.toString() ?? ''),
        HomeWidget.saveWidgetData<bool>('isVideo', isVideo),
        HomeWidget.saveWidgetData<bool>('isAudioOnly', isAudioOnly),
      ];
      
      // Add video URL only if needed
      if (isVideo) {
        saveFutures.add(
          HomeWidget.saveWidgetData<String>('videoUrl', data['videoUrl'] ?? '')
        );
      }
      
      // Execute all saves in parallel
      await Future.wait(saveFutures);

      // ðŸ’‰ BFF WIDGET SYNC: Update these so the specific-friend widget refreshes too
      // This bridges the "ghost friend" gap where BFF widgets stay stale.
      final senderId = data['senderId'];
      final senderAvatar = data['senderAvatar'];
      
      if (senderId != null) {
        await HomeWidget.saveWidgetData<String>('name_$senderId', data['senderName'] ?? 'Friend');
        
        if (senderAvatar != null && senderAvatar.isNotEmpty) {
           // Binary/Path cache in background (fire and forget)
           // Uses _cacheAvatarAsBinary which we should verify handles Android paths too
           // Actually _cacheAvatarAsBinary (line 586) only handles iOS binary.
           // We should use _downloadAndCache if we want to fix Android avatars here too.
           _downloadAndCache(
             url: senderAvatar,
             key: 'avatar_$senderId',
             description: 'BFF avatar $senderId (Push)'
           ).then((path) {
             if (path != null && !Platform.isIOS) {
               HomeWidget.saveWidgetData<String>('avatar_$senderId', path);
             }
           });
        }
      }

      // Force widget to reload its visuals
      await HomeWidget.updateWidget(
        name: androidWidgetName,
        iOSName: iOSWidgetName,
      );

      debugPrint('WidgetUpdateService: Widget updated successfully (isVideo=$isVideo, isAudioOnly=$isAudioOnly)');
    } catch (e) {
      debugPrint('WidgetUpdateService: Error updating widget: $e');
    }
  }


  /// Update widget when user sends a vibe (local update for sender)
  Future<void> updateWidgetForSender({
    required String receiverName,
    required String status, // e.g., "Sent to Sarah"
  }) async {
    try {
      await HomeWidget.saveWidgetData<String>('lastAction', 'sent');
      await HomeWidget.saveWidgetData<String>('statusText', status);
      await HomeWidget.saveWidgetData<int>('timestamp', DateTime.now().millisecondsSinceEpoch);
      
      await HomeWidget.updateWidget(
        name: androidWidgetName,
        iOSName: iOSWidgetName,
      );
    } catch (e) {
      debugPrint('WidgetUpdateService: Error updating sender widget: $e');
    }
  }

  /// Mark vibe as played (update NEW indicator)
  Future<void> markVibePlayed(String vibeId) async {
    try {
      await HomeWidget.saveWidgetData<bool>('isPlayed', true);
      await HomeWidget.saveWidgetData<String>('playedVibeId', vibeId);
      
      // CRITICAL FIX: Queue for Firestore sync
      await addPendingReadReceipt(vibeId);
      
      await HomeWidget.updateWidget(
        name: androidWidgetName,
        iOSName: iOSWidgetName,
      );
    } catch (e) {
      debugPrint('WidgetUpdateService: Error marking vibe played: $e');
    }
  }

  /// Clear widget (reset to empty state)
  Future<void> clearWidget() async {
    try {
      await HomeWidget.saveWidgetData<String>('senderName', '');
      await HomeWidget.saveWidgetData<String>('senderId', '');
      await HomeWidget.saveWidgetData<String>('audioUrl', '');
      await HomeWidget.saveWidgetData<String>('imageUrl', '');
      await HomeWidget.saveWidgetData<String>('vibeId', '');
      await HomeWidget.saveWidgetData<String>('distance', '');
      await HomeWidget.saveWidgetData<String>('transcription', '');
      await HomeWidget.saveWidgetData<bool>('isPlayed', true);
      
      await HomeWidget.updateWidget(
        name: androidWidgetName,
        iOSName: iOSWidgetName,
      );
    } catch (e) {
      debugPrint('WidgetUpdateService: Error clearing widget: $e');
    }
  }

  /// Check if widget is installed
  Future<bool> isWidgetInstalled() async {
    try {
      // This is platform-specific and may not be fully supported
      // For now, we assume it's installed after user completes setup
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Register widget click callback
  Future<void> registerWidgetCallback(Function(Uri?) callback) async {
    HomeWidget.widgetClicked.listen(callback);
  }

  /// REFRESH ALL WIDGETS: Standard sync method for both Squad and Nock widgets
  /// Called on app load, return from background, or after sending/receiving vibes.
  static Future<void> refreshAllWidgets(List<VibeModel> vibes) async {
    if (vibes.isEmpty) return;
    
    // Convert models to maps for the update logic
    final vibeMaps = vibes.map<Map<String, dynamic>>((v) => {
      'vibeId': v.id,
      'senderName': v.senderName,
      'senderId': v.senderId,
      'imageUrl': v.imageUrl ?? '',
      'isPlayed': v.isPlayed,
      'timestamp': v.createdAt.millisecondsSinceEpoch,
      'transcription': v.transcription ?? '',
    }).toList();

    await updateSquadWidget(vibeMaps);
  }
  
  /// Update Squad Widget with recent vibes list
  /// OPTIMIZED: Uses parallel execution to prevent iOS background task timeouts
  static Future<void> updateSquadWidget(List<Map<String, dynamic>> vibes) async {
    try {
      // Set App Group for iOS (Android ignores this)
      if (Platform.isIOS) {
        await HomeWidget.setAppGroupId(appGroupId);
      }
      
      // 1. Prepare Parallel Download Tasks
      // We start downloads immediately but capture results for Android paths
      final top3Vibes = vibes.take(3).toList();
      Map<String, String> localImagePaths = {};
      Map<String, String> localAvatarPaths = {};
      
      List<Future<void>> downloadTasks = [];

      for (final v in top3Vibes) {
        final vibeId = v['vibeId'] ?? v['id'] ?? '';
        final imageUrl = v['imageUrl'] ?? '';
        final senderId = v['senderId'] ?? '';
        final senderAvatar = v['senderAvatar'] ?? '';

        // Task A: Vibe Image
        if (imageUrl.isNotEmpty) {
          downloadTasks.add(_downloadAndCache(
            url: _getThumbnailUrl(imageUrl),
            key: 'vibe_image_$vibeId',
            description: 'vibe $vibeId',
          ).then((path) {
            if (path != null) localImagePaths[vibeId] = path;
          }));
        }

        // Task B: Friend Avatar (for BFF widget consistency)
        if (senderId.isNotEmpty && senderAvatar.isNotEmpty) {
           // We don't link avatar path to vibe JSON in SquadWidget, but we cache it
           downloadTasks.add(_downloadAndCache(
            url: senderAvatar,
            key: 'avatar_$senderId',
            description: 'avatar $senderId',
          ).then((path) {
             if (path != null) localAvatarPaths[senderId] = path;
          }));
        }
      }

      // 2. Execute ALL downloads
      if (downloadTasks.isNotEmpty) {
        await Future.wait(downloadTasks);
      }
      
      // 3. Construct JSON Data
      // For Android, we inject the LOCAL file path into 'imageUrl'
      // For iOS, the widget reads from App Group using ID, so path is irrelevant (but verified locally)
      final vibesJson = jsonEncode(top3Vibes.map((v) {
        final vibeId = v['vibeId'] ?? v['id'] ?? '';
        final originalUrl = _getThumbnailUrl(v['imageUrl'] ?? '');
        
        // Android-Push: Use local path if successfully downloaded, else original (fallback)
        final effectiveUrl = (!Platform.isIOS && localImagePaths.containsKey(vibeId))
            ? localImagePaths[vibeId]
            : originalUrl;
            
        return {
          'vibeId': vibeId,
          'senderName': v['senderName'] ?? '',
          'senderId': v['senderId'] ?? '',
          'imageUrl': effectiveUrl,
          'isPlayed': v['isPlayed'] ?? false,
          'timestamp': v['timestamp'] ?? DateTime.now().millisecondsSinceEpoch,
          'transcription': v['transcription'] ?? '',
        };
      }).toList());
      
      await HomeWidget.saveWidgetData<String>('recent_vibes', vibesJson);
      
      // 3.5 SYNC HERO VIBE: Update individual keys for the main NockWidget (Hero slot)
      if (top3Vibes.isNotEmpty) {
        final hero = top3Vibes.first;
        final heroId = hero['vibeId'] ?? hero['id'] ?? '';
        final heroImageUrl = (!Platform.isIOS && localImagePaths.containsKey(heroId))
            ? localImagePaths[heroId]!
            : _getThumbnailUrl(hero['imageUrl'] ?? '');

        await Future.wait([
          HomeWidget.saveWidgetData<String>('senderName', hero['senderName'] ?? 'Friend'),
          HomeWidget.saveWidgetData<String>('senderId', hero['senderId'] ?? ''),
          HomeWidget.saveWidgetData<String>('imageUrl', heroImageUrl),
          HomeWidget.saveWidgetData<String>('vibeId', heroId),
          HomeWidget.saveWidgetData<bool>('isPlayed', hero['isPlayed'] ?? false),
          HomeWidget.saveWidgetData<int>('timestamp', hero['timestamp'] ?? DateTime.now().millisecondsSinceEpoch),
          HomeWidget.saveWidgetData<String>('transcription', hero['transcription'] ?? ''),
        ]);
      }
      
      // 4. Trigger Widget Refresh
      await HomeWidget.updateWidget(
        name: 'SquadWidgetProvider',
        iOSName: 'SquadWidget',
      );
      
      // Also update the main NockWidget to keep them in sync
      await HomeWidget.updateWidget(
        name: androidWidgetName,
        iOSName: iOSWidgetName,
      );
      
      debugPrint('WidgetUpdateService: Squad widget updated with ${top3Vibes.length} vibes (Parallel)');
    } catch (e) {
      debugPrint('WidgetUpdateService: Error updating Squad widget: $e');
    }
  }


  /// Helper to handle individual downloads with error safety
  /// Returns the local file path (Android) or null (iOS/Error)
  static Future<String?> _downloadAndCache({
    required String url,
    required String key,
    required String description,
  }) async {
    try {
      // 1. Download bytes
      final response = await http.get(Uri.parse(url))
          .timeout(const Duration(seconds: 5));
          
      if (response.statusCode != 200) {
        debugPrint('WidgetUpdateService: Failed to download $description (Status ${response.statusCode})');
        return null;
      }

      Uint8List bytes = response.bodyBytes;

      // 2. Resize to safe dimensions (e.g., 400px)
      // This prevents "TransactionTooLargeException" on Android and saves memory on iOS
      Uint8List finalBytes = bytes;
      try {
        final downsampled = await Isolate.run(() {
          final image = img.decodeImage(bytes);
          if (image == null) return bytes;
          
          // If already small enough, return original
          if (image.width <= 400 && image.height <= 400) return bytes;
          
          // Resize preserving aspect ratio
          final resized = img.copyResize(
            image, 
            width: image.width > image.height ? 400 : null,
            height: image.height >= image.width ? 400 : null,
            interpolation: img.Interpolation.linear,
          );
          return Uint8List.fromList(img.encodeJpg(resized, quality: 75));
        });
        finalBytes = downsampled;
      } catch (e) {
        debugPrint('WidgetUpdateService: Image resizing failed: $e');
        // Fallback to original bytes (risky but better than crashing app logic)
      }

      // 3. Platform-specific saving
      if (Platform.isIOS) {
        // iOS: HomeWidget handles writing bytes to App Group
        await HomeWidget.saveWidgetData<Uint8List>(key, finalBytes);
        return null; // iOS widgets read from App Group via key
        
      } else {
        // Android: "Flutter-Push" Architecture
        // Save to local storage and return the absolute path
        try {
          final directory = await getApplicationDocumentsDirectory();
          final String fileName = '$key.png'; 
          final File file = File(p.join(directory.path, 'widget_images', fileName));
          
          if (!await file.parent.exists()) {
            await file.parent.create(recursive: true);
          }
          
          await file.writeAsBytes(finalBytes);
          debugPrint('WidgetUpdateService: Saved Android widget image to ${file.path}');
          return file.path;
          
        } catch (e) {
          debugPrint('WidgetUpdateService: Android save failed: $e');
          return null;
        }
      }
    } catch (e) {
      debugPrint('WidgetUpdateService: Failed to cache $description: $e');
      return null;
    }
  }

  /// Update data for the BFF (Best Friend) widget
  /// 
  /// CRITICAL DEAD CODE FIX:
  /// This writes the specific keys expected by BFFWidget.swift and BFFWidgetProvider.kt:
  /// - avatar_{friendId} (binary or path)
  static Future<void> updateBFFWidget({
    required String friendId,
    required String friendName,
    String? avatarUrl,
  }) async {
    try {
      // Set App Group for iOS
      if (Platform.isIOS) {
        await HomeWidget.setAppGroupId(appGroupId);
      } else {
        // Android: Ensure we are using the correct Prefs file
        // Note: Kotlin BFFWidgetProvider uses its own prefs, but we can sync here
        // to a global location if we update Kotlin later.
      }

      // 1. Save metadata
      await HomeWidget.saveWidgetData<String>('name_$friendId', friendName);
      
      // 2. Download and save avatar
      if (avatarUrl != null && avatarUrl.isNotEmpty) {
         final path = await _downloadAndCache(
           url: avatarUrl, 
           key: 'avatar_$friendId', 
           description: 'BFF avatar $friendId'
         );
         
         if (path != null && !Platform.isIOS) {
           // Android: Save the file path to the same key used for bytes on iOS
           // The Native provider will read this string.
           await HomeWidget.saveWidgetData<String>('avatar_$friendId', path);
           debugPrint('WidgetUpdateService: Saved BFF avatar path for Android: $path');
         }
      }

      // 3. Trigger BFF widget refresh
      // iOS: BFFWidget, Android: BFFWidgetProvider
      await HomeWidget.updateWidget(
        name: 'BFFWidgetProvider',
        iOSName: 'BFFWidget',
      );
      
      debugPrint('WidgetUpdateService: BFF widget metadata updated for $friendId');
    } catch (e) {
      debugPrint('WidgetUpdateService: Error updating BFF widget: $e');
    }
  }

  /// CRITICAL FIX: Sync friends list to shared storage for native BFF widgets
  /// 
  /// The native BFFConfigActivity needs a JSON list of friends to display
  /// for selection. We MUST use HomeWidget.saveWidgetData to write this
  /// to the standardized HomeWidgetPrefs (Android) or App Group (iOS).
  static Future<void> syncFriendsList(List<dynamic> friends) async {
    try {
      final List<Map<String, dynamic>> friendItems = friends.map((f) => {
        'id': f.id,
        'name': f.displayName,
        'avatarUrl': f.avatarUrl,
      }).toList();

      final String json = jsonEncode(friendItems);
      
      // Save to shared storage (HomeWidgetPrefs on Android, App Group on iOS)
      // HomeWidget plugin does NOT use "flutter." prefix by default
      await HomeWidget.saveWidgetData<String>('friends_list', json);
      
      debugPrint('WidgetUpdateService: Synced ${friendItems.length} friends to shared storage');
    } catch (e) {
      debugPrint('WidgetUpdateService: Error syncing friends list: $e');
    }
  }

}

/// FCM Background Message Handler
/// 
/// This MUST be a top-level function (outside any class).
/// It's called when the app is in background/terminated and receives a data message.
@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase (required for background execution)
  await Firebase.initializeApp();
  
  debugPrint('FCM Background: Received message - ${message.data}');
  
  final messageType = message.data['type'];
  
  switch (messageType) {
    case 'WIDGET_UPDATE':
      // Silent push to update widget with new vibe
      await WidgetUpdateService.updateWidgetFromPush(message.data);
      break;
      
    case 'NEW_VIBE':
      // Standard notification handled by FCM - no action needed
      debugPrint('FCM Background: New vibe notification');
      break;
      
      
    default:
      debugPrint('FCM Background: Unknown message type: $messageType');
  }
}

/// Provider for WidgetUpdateService
final widgetUpdateServiceProvider = Provider<WidgetUpdateService>((ref) {
  return WidgetUpdateService();
});




========================================

FILE #32: E:\Vive\lib\core\theme\app_colors.dart

========================================


import 'package:flutter/material.dart';
import 'package:home_widget/home_widget.dart';

/// Bioluminescent Noir Design System
/// 
/// A palette designed for high-intimacy social interactions among Gen Z.
/// Replaces the harsh Cyberpunk neons with organic, calming glows.
class AppColors {
  AppColors._();

  // --- Core Palette ---
  
  /// Bio-Lime: The primary action color. Organic, generative, and optimistic.
  static const Color bioLime = Color(0xFFD4F49C);
  
  /// Digital Lavender: Represents mental health, stability, and platonic love.
  static const Color digitalLavender = Color(0xFFE5D1FA);
  
  /// Void Navy: The restful, private background that reduces alert fatigue.
  /// UPDATED: Switched to Material Dark (#121212) per OLED optimization guidelines.
  static const Color voidNavy = Color(0xFF121212);
  
  /// Starlight: Softer alternative to pure white for text.
  static const Color starlight = Color(0xFFF0F2F5);

  // --- Backgrounds ---
  static const Color background = voidNavy;
  // Neutral dark variance for secondary backgrounds
  static const Color backgroundAlt = Color(0xFF1E1E1E); 
  // Slight elevation for cards (Material surface color)
  static const Color surface = Color(0xFF1E1E1E); 
  // Lighter surface for high elevation (Dialogs, Snackbars)
  static const Color surfaceLight = Color(0xFF2C2C2C);

  // --- Semantic Accents ---
  static const Color primaryAction = bioLime;
  static const Color secondaryAction = digitalLavender;
  static const Color success = bioLime;
  static const Color error = Color(0xFFFF6B6B); // Thermal Orange
  static const Color warning = Color(0xFFFFAA00);
  
  // --- Passive Layer ---
  static const Color textPrimary = starlight;
  static const Color textSecondary = Color(0xFFB0B0C5);
  static const Color textTertiary = Color(0xFF8489A1); // Lightened for WCAG AA (4.5:1)

  // --- Gradients ---
  static const LinearGradient primaryGradient = LinearGradient(
    begin: Alignment.topLeft,
    end: Alignment.bottomRight,
    colors: [bioLime, digitalLavender],
  );

  static const LinearGradient darkGradient = LinearGradient(
    begin: Alignment.topCenter,
    end: Alignment.bottomCenter,
    colors: [surface, background],
  );

  // --- Luminous Borders (Spatial Glass Architecture) ---
  
  /// Luminous border - top edge (light catch effect)
  /// Used to simulate overhead light source hitting glass edge
  static const Color luminousBorderTop = Color(0x99FFFFFF); // 60% white
  
  /// Luminous border - bottom edge (fade to transparent)
  /// Creates the rim light effect by fading out at bottom
  static const Color luminousBorderBottom = Color(0x1AFFFFFF); // 10% white
  
  /// Gradient for luminous borders (top-to-bottom light fade)
  /// Apply this to border strokes for the Spatial Glass effect
  static const LinearGradient luminousBorderGradient = LinearGradient(
    begin: Alignment.topCenter,
    end: Alignment.bottomCenter,
    colors: [luminousBorderTop, luminousBorderBottom],
  );
  
  /// Inner glow - light (for glass bevel effect)
  /// Simulates light bouncing inside the glass surface
  static const Color innerGlowLight = Color(0x4DFFFFFF); // 30% white
  
  /// Inner glow - dark (for depth and shadow)
  /// Adds subtle depth to create 3D glass appearance
  static const Color innerGlowDark = Color(0x1A000000); // 10% black

  // --- Theme Data ---
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      scaffoldBackgroundColor: background,
      primaryColor: bioLime,
      colorScheme: const ColorScheme.dark(
        primary: bioLime,
        secondary: digitalLavender,
        surface: surface,
        onSurface: starlight,
      ),
      textTheme: const TextTheme(
        headlineLarge: TextStyle(color: starlight, fontWeight: FontWeight.bold),
        bodyLarge: TextStyle(color: starlight),
        bodyMedium: TextStyle(color: starlight),
      ),
      appBarTheme: const AppBarTheme(
        backgroundColor: Colors.transparent,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: CardThemeData(
        color: surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(24),
        ),
      ),
    );
  }

  // --- Legacy / Compatibility Members ---
  static const Color glassBackground = Color(0x1A121212); // #121212 with 10% alpha
  static const Color glassBackgroundDark = Color(0x33121212); // #121212 with 20% alpha
  static const Color glassBorder = Color(0x4DD4F49C); // bioLime with ~30% alpha
  static const Color urgency = error;
  static const Color telemetry = digitalLavender;
  static const Color vibePrimary = bioLime;
  static const Color vibeSecondary = digitalLavender;
  static const Color vibeBackground = voidNavy;
  static const Color vibeAccent = digitalLavender;
  static const Color statusLive = bioLime;
  static const Color statusRecording = error;
  static const Color statusOffline = textTertiary;
  static const Color retroTagText = textSecondary;
  static const Color surfaceCard = surface;

  // Aura legacy colors
  static const Color auraHappy = bioLime;
  static const Color auraWarm = Color(0xFFFED766);
  static const Color auraCool = digitalLavender;
  static const Color auraSad = Color(0xFF637081);
  static const Color auraNeutral = starlight;

  static const LinearGradient auraGradient = primaryGradient;

  /// Syncs the current theme colors to native widgets.
  static Future<void> syncThemeWithWidgets() async {
    final List<Future<void>> futures = [
      HomeWidget.saveWidgetData<String>('theme_primary', 'D4F49C'),
      HomeWidget.saveWidgetData<String>('theme_secondary', 'E5D1FA'),
      HomeWidget.saveWidgetData<String>('theme_background', '121212'),
      HomeWidget.saveWidgetData<String>('theme_starlight', 'F0F2F5'),
    ];
    await Future.wait(futures);
  }
}



========================================

FILE #33: E:\Vive\lib\core\theme\app_theme.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'app_colors.dart';
import 'app_typography.dart';

/// Main Theme Configuration for Vibe App
/// Implements the "Cyberpunk Noir" design system
class AppTheme {
  AppTheme._();

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      scaffoldBackgroundColor: AppColors.background,
      primaryColor: AppColors.primaryAction,
      colorScheme: const ColorScheme.dark(
        primary: AppColors.primaryAction,
        secondary: AppColors.secondaryAction,
        surface: AppColors.surface,
        error: AppColors.error,
        onPrimary: AppColors.background,
        onSecondary: AppColors.background,
        onSurface: AppColors.textPrimary,
        onError: AppColors.textPrimary,
      ),
      appBarTheme: AppBarTheme(
        backgroundColor: Colors.transparent,
        elevation: 0,
        systemOverlayStyle: SystemUiOverlayStyle.light,
        titleTextStyle: AppTypography.headlineMedium,
        iconTheme: const IconThemeData(color: AppColors.textPrimary),
      ),
      bottomNavigationBarTheme: const BottomNavigationBarThemeData(
        backgroundColor: AppColors.background,
        selectedItemColor: AppColors.primaryAction,
        unselectedItemColor: AppColors.textTertiary,
      ),
      cardTheme: CardThemeData(
        color: AppColors.surfaceCard,
        elevation: 0,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16), // Softer corners for modern HUD
          side: const BorderSide(color: AppColors.glassBorder, width: 1.0),
        ),
      ),
      iconTheme: const IconThemeData(
        color: AppColors.textPrimary,
        size: 24,
      ),
      textTheme: TextTheme(
        displayLarge: AppTypography.displayLarge,
        displayMedium: AppTypography.displayMedium,
        displaySmall: AppTypography.displaySmall,
        headlineLarge: AppTypography.headlineLarge,
        headlineMedium: AppTypography.headlineMedium,
        headlineSmall: AppTypography.headlineSmall,
        bodyLarge: AppTypography.bodyLarge,
        bodyMedium: AppTypography.bodyMedium,
        bodySmall: AppTypography.bodySmall,
        labelLarge: AppTypography.labelLarge,
        labelMedium: AppTypography.labelMedium,
        labelSmall: AppTypography.labelSmall,
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.primaryAction,
          foregroundColor: AppColors.background,
          padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          textStyle: AppTypography.buttonText,
        ),
      ),
      outlinedButtonTheme: OutlinedButtonThemeData(
        style: OutlinedButton.styleFrom(
          foregroundColor: AppColors.primaryAction,
          side: const BorderSide(color: AppColors.primaryAction, width: 2),
          padding: const EdgeInsets.symmetric(horizontal: 32, vertical: 16),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          textStyle: AppTypography.buttonText.copyWith(
            color: AppColors.primaryAction,
          ),
        ),
      ),
      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: AppColors.primaryAction,
          textStyle: AppTypography.labelLarge,
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: AppColors.surfaceLight,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.glassBorder, width: 1),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.primaryAction, width: 2), // High contrast
        ),
        hintStyle: AppTypography.bodyMedium.copyWith(
          color: AppColors.textTertiary,
        ),
        contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
      ),
      dialogTheme: DialogThemeData(
        backgroundColor: AppColors.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
      ),
      snackBarTheme: SnackBarThemeData(
        backgroundColor: AppColors.surfaceLight,
        contentTextStyle: AppTypography.bodyMedium,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8),
          side: const BorderSide(color: AppColors.glassBorder, width: 1),
        ),
        behavior: SnackBarBehavior.floating,
      ),
      dividerTheme: const DividerThemeData(
        color: AppColors.glassBorder,
        thickness: 1,
      ),
      progressIndicatorTheme: const ProgressIndicatorThemeData(
        color: AppColors.primaryAction,
      ),
      sliderTheme: SliderThemeData(
        activeTrackColor: AppColors.primaryAction,
        inactiveTrackColor: AppColors.surfaceLight,
        thumbColor: AppColors.primaryAction,
        overlayColor: AppColors.primaryAction.withOpacity(0.2),
      ),
    );
  }
}



========================================

FILE #34: E:\Vive\lib\core\theme\app_typography.dart

========================================


import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'app_colors.dart';

/// Vibe App Typography System - 2025 Standards
/// 
/// Typography Pairing:
/// - HEADERS: SpaceMono (cyberpunk/tech aesthetic for branding)
/// - BODY: Inter (modern geometric sans-serif for readability)
/// - RETRO: SpaceMono (timestamps, tags, data displays)
class AppTypography {
  AppTypography._();

  // ============ DISPLAY STYLES (SpaceMono - Brand Identity) ============
  
  static TextStyle get displayLarge => GoogleFonts.spaceMono(
    fontSize: 48,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
    letterSpacing: -1,
  );

  static TextStyle get displayMedium => GoogleFonts.spaceMono(
    fontSize: 36,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
    letterSpacing: -0.5,
  );

  static TextStyle get displaySmall => GoogleFonts.spaceMono(
    fontSize: 28,
    fontWeight: FontWeight.bold,
    color: AppColors.textPrimary,
  );

  // ============ HEADLINE STYLES (SpaceMono - Section Headers) ============
  
  static TextStyle get headlineLarge => GoogleFonts.spaceMono(
    fontSize: 24,
    fontWeight: FontWeight.w600,
    color: AppColors.textPrimary,
  );

  static TextStyle get headlineMedium => GoogleFonts.spaceMono(
    fontSize: 20,
    fontWeight: FontWeight.w600,
    color: AppColors.textPrimary,
  );

  static TextStyle get headlineSmall => GoogleFonts.spaceMono(
    fontSize: 18,
    fontWeight: FontWeight.w600,
    color: AppColors.textPrimary,
  );

  // ============ BODY STYLES (Inter - Readable Content) ============
  
  static TextStyle get bodyLarge => GoogleFonts.inter(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
    height: 1.5,
  );

  static TextStyle get bodyMedium => GoogleFonts.inter(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
    height: 1.4,
  );

  static TextStyle get bodySmall => GoogleFonts.inter(
    fontSize: 12,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
    height: 1.4,
  );

  // ============ LABEL STYLES (Inter - UI Elements) ============
  
  static TextStyle get labelLarge => GoogleFonts.inter(
    fontSize: 14,
    fontWeight: FontWeight.w600,
    color: AppColors.textPrimary,
    letterSpacing: 0.3,
  );

  static TextStyle get labelMedium => GoogleFonts.inter(
    fontSize: 12,
    fontWeight: FontWeight.w500,
    color: AppColors.textSecondary,
    letterSpacing: 0.3,
  );

  static TextStyle get labelSmall => GoogleFonts.inter(
    fontSize: 10,
    fontWeight: FontWeight.w500,
    color: AppColors.textTertiary,
    letterSpacing: 0.3,
  );

  // ============ BUTTON STYLES (Inter - Call to Actions) ============
  
  static TextStyle get buttonText => GoogleFonts.inter(
    fontSize: 16,
    fontWeight: FontWeight.w700,
    color: AppColors.background,
    letterSpacing: 0.5,
  );

  static TextStyle get buttonTextSmall => GoogleFonts.inter(
    fontSize: 14,
    fontWeight: FontWeight.w600,
    color: AppColors.background,
    letterSpacing: 0.3,
  );

  // ============ SPECIAL STYLES (SpaceMono - Data/Retro) ============
  
  static TextStyle get accentText => GoogleFonts.spaceMono(
    fontSize: 14,
    fontWeight: FontWeight.bold,
    color: AppColors.primaryAction,
    letterSpacing: 0.5,
  );

  static TextStyle get retroTag => GoogleFonts.spaceMono(
    fontSize: 10,
    fontWeight: FontWeight.bold,
    color: AppColors.retroTagText,
    letterSpacing: 1.5,
  );

  static TextStyle get statusText => GoogleFonts.spaceMono(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    color: AppColors.statusLive,
  );

  static TextStyle get timestampText => GoogleFonts.spaceMono(
    fontSize: 10,
    fontWeight: FontWeight.normal,
    color: AppColors.textTertiary,
    letterSpacing: 0.5,
  );

  static TextStyle get dataText => GoogleFonts.spaceMono(
    fontSize: 12,
    fontWeight: FontWeight.w500,
    color: AppColors.textSecondary,
    letterSpacing: 0.5,
  );

  // ============ CAPTION STYLES (Inter - Descriptions) ============
  
  static TextStyle get caption => GoogleFonts.inter(
    fontSize: 12,
    fontWeight: FontWeight.normal,
    color: AppColors.textTertiary,
    height: 1.3,
  );

  static TextStyle get captionAccent => GoogleFonts.inter(
    fontSize: 12,
    fontWeight: FontWeight.w500,
    color: AppColors.primaryAction,
    height: 1.3,
  );

  // ============ HANDWRITTEN STYLES (Permanent Marker - Notes) ============
  
  static TextStyle get handwritten => GoogleFonts.permanentMarker(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
    letterSpacing: 0.5,
  );
}



========================================

FILE #35: E:\Vive\lib\features\auth\presentation\not_found_screen.dart

========================================


import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_routes.dart';

/// 404 / Error Screen
/// 
/// Replaces the dead-end error page with a branded recovery screen.
/// Provides a clear "Go Home" button to prevent user strand.
class NotFoundScreen extends StatelessWidget {
  final Uri uri;

  const NotFoundScreen({super.key, required this.uri});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: Container(
        padding: const EdgeInsets.symmetric(horizontal: 40),
        decoration: const BoxDecoration(
          gradient: AppColors.darkGradient,
        ),
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Branded Logo or Icon
              Container(
                width: 80,
                height: 80,
                decoration: BoxDecoration(
                  color: AppColors.primaryAction.withOpacity(0.1),
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: AppColors.primaryAction.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: const Icon(
                  Icons.explore_off_outlined,
                  size: 40,
                  color: AppColors.primaryAction,
                ),
              ),
              const SizedBox(height: 32),
              
              // Error Message
              Text(
                '404',
                style: AppTypography.displayLarge.copyWith(
                  color: AppColors.primaryAction,
                  fontSize: 64,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                'Page Not Found',
                style: AppTypography.headlineLarge,
              ),
              const SizedBox(height: 16),
              Text(
                'The link you followed might be broken or the page has been moved.',
                textAlign: TextAlign.center,
                style: AppTypography.bodyMedium.copyWith(
                  color: AppColors.textSecondary,
                ),
              ),
              const SizedBox(height: 8),
              Text(
                uri.toString(),
                textAlign: TextAlign.center,
                style: AppTypography.caption.copyWith(
                  color: AppColors.textTertiary,
                ),
                maxLines: 2,
                overflow: TextOverflow.ellipsis,
              ),
              const SizedBox(height: 48),
              
              // Recovery Action
              SizedBox(
                width: double.infinity,
                height: 56,
                child: ElevatedButton(
                  onPressed: () => context.go(AppRoutes.home),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primaryAction,
                    foregroundColor: AppColors.background,
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(16),
                    ),
                    elevation: 0,
                  ),
                  child: Text(
                    'Go Back Home',
                    style: AppTypography.buttonText,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



========================================

FILE #36: E:\Vive\lib\features\auth\presentation\welcome_screen.dart

========================================


import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/constants/app_routes.dart';

/// Welcome Screen with Multi-Method Authentication
/// 
/// Supports authentication methods:
/// 1. Apple Sign-In (iOS) / Google Sign-In - Fastest, 1-tap
/// 2. Google Sign-In (Android/iOS) - Most common
class WelcomeScreen extends ConsumerStatefulWidget {
  const WelcomeScreen({super.key});

  @override
  ConsumerState<WelcomeScreen> createState() => _WelcomeScreenState();
}

class _WelcomeScreenState extends ConsumerState<WelcomeScreen> {
  bool _isLoading = false;
  String? _errorMessage;
  
  // Progressive Disclosure: Show secondary auth options on Android
  bool _showMoreOptions = false;

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    super.dispose();
  }

  Future<void> _signInWithGoogle() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authService = ref.read(authServiceProvider);
      final result = await authService.signInWithGoogle();
      
      if (result != null && mounted) {
        HapticFeedback.mediumImpact();
      }
    } catch (e) {
      debugPrint('Google Sign-In Error: $e');
      if (mounted) {
        setState(() => _errorMessage = 'Google sign-in failed. Please try again.');
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _signInWithApple() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final authService = ref.read(authServiceProvider);
      final result = await authService.signInWithApple();
      
      if (result != null && mounted) {
        HapticFeedback.mediumImpact();
      }
    } catch (e) {
      setState(() => _errorMessage = 'Apple sign-in failed. Please try again.');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }



  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.vibeBackground,
      body: SafeArea(
        child: Stack(
          children: [
            // Animated background gradient
            Positioned.fill(
              child: Container(
                decoration: BoxDecoration(
                  gradient: RadialGradient(
                    center: Alignment.topCenter,
                    radius: 1.5,
                    colors: [
                      AppColors.vibePrimary.withOpacity(0.15),
                      AppColors.vibeBackground,
                    ],
                  ),
                ),
              ),
            ),
            
            // Main content
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 32),
              child: Column(
                children: [
                  const Spacer(flex: 2),
                  
                  // Logo and title (instant - no animation)
                  _buildHeader(),
                  
                  const Spacer(flex: 1),
                  
                  // Auth buttons (instant - no animation)
                  _buildAuthButtons(),
                  
                  const SizedBox(height: 24),
                  
                  // Error message
                  if (_errorMessage != null)
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.red.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        children: [
                          const Icon(Icons.error_outline, color: Colors.red, size: 20),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _errorMessage!,
                              style: const TextStyle(color: Colors.red, fontSize: 14),
                            ),
                          ),
                        ],
                      ),
                    ),
                  
                  const Spacer(flex: 1),
                  
                  // Terms and privacy
                  _buildFooter(),
                  
                  const SizedBox(height: 16),
                ],
              ),
            ),
            
            // Loading overlay
            if (_isLoading)
              Container(
                color: Colors.black54,
                child: const Center(
                  child: CircularProgressIndicator(
                    color: AppColors.vibePrimary,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Column(
      children: [
        // App icon/logo
        Container(
          width: 120,
          height: 120,
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                AppColors.vibePrimary,
                AppColors.vibeSecondary,
              ],
            ),
            shape: BoxShape.circle,
            boxShadow: [
              BoxShadow(
                color: AppColors.vibePrimary.withOpacity(0.4),
                blurRadius: 30,
                spreadRadius: 5,
              ),
            ],
          ),
          child: const Icon(
            Icons.waves_rounded,
            size: 64,
            color: Colors.white,
          ),
        ),
        const SizedBox(height: 32),
        
        // App name (KEEP)
        const Text(
          'Nock',
          style: TextStyle(
            fontSize: 48,
            fontWeight: FontWeight.bold,
            color: Colors.white,
            letterSpacing: -1,
          ),
        ),
        // Tagline removed (KILL - visual noise per UX protocol)
      ],
    );
  }

  Widget _buildAuthButtons() {
    return Column(
      children: [
        // Apple Sign-In (iOS only, shown first on iOS - KEEP)
        if (Platform.isIOS) ...[
          _buildAuthButton(
            label: 'Continue with Apple',
            icon: Icons.apple,
            backgroundColor: Colors.white,
            textColor: Colors.black,
            onTap: _signInWithApple,
          ),
          const SizedBox(height: 12),
        ],
        
        // Google Sign-In (Primary on Android - KEEP)
        _buildAuthButton(
          label: 'Continue with Google',
          icon: null,
          customIcon: _buildGoogleIcon(),
          backgroundColor: Colors.white,
          textColor: Colors.black87,
          onTap: _signInWithGoogle,
        ),
        
        // Progressive Disclosure: "More options" on Android (HIDE secondary auth)
        if (Platform.isAndroid) ...[
          const SizedBox(height: 16),
          if (_showMoreOptions) ...[
            // Revealed: Apple button
            _buildAuthButton(
              label: 'Continue with Apple',
              icon: Icons.apple,
              backgroundColor: Colors.white,
              textColor: Colors.black,
              onTap: _signInWithApple,
            ),
          ] else ...[
            // "More options" text button
            GestureDetector(
              onTap: () => setState(() => _showMoreOptions = true),
              child: Text(
                'More sign-in options',
                style: TextStyle(
                  color: Colors.white.withOpacity(0.5),
                  fontSize: 14,
                  decoration: TextDecoration.underline,
                  decorationColor: Colors.white.withOpacity(0.3),
                ),
              ),
            ),
          ],
        ],
      ],
    );
  }

  Widget _buildAuthButton({
    required String label,
    IconData? icon,
    Widget? customIcon,
    required Color backgroundColor,
    required Color textColor,
    Color? borderColor,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: _isLoading ? null : onTap,
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.symmetric(vertical: 16),
        decoration: BoxDecoration(
          color: backgroundColor,
          borderRadius: BorderRadius.circular(14),
          border: borderColor != null ? Border.all(color: borderColor) : null,
          boxShadow: backgroundColor != Colors.transparent
              ? [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.1),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ]
              : null,
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          mainAxisSize: MainAxisSize.min,  // Prevent overflow
          children: [
            if (customIcon != null) customIcon,
            if (icon != null) Icon(icon, color: textColor, size: 24),
            const SizedBox(width: 12),
            Flexible(
              child: Text(
                label,
                style: TextStyle(
                  color: textColor,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildGoogleIcon() {
    // Simple Google "G" icon
    return Container(
      width: 24,
      height: 24,
      decoration: const BoxDecoration(
        shape: BoxShape.circle,
      ),
      child: Center(
        child: Text(
          'G',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            foreground: Paint()
              ..shader = const LinearGradient(
                colors: [
                  Color(0xFF4285F4), // Blue
                  Color(0xFF34A853), // Green
                  Color(0xFFFBBC05), // Yellow
                  Color(0xFFEA4335), // Red
                ],
              ).createShader(const Rect.fromLTWH(0, 0, 24, 24)),
          ),
        ),
      ),
    );
  }

  Widget _buildFooter() {
    // Progressive Disclosure: Minimized footer - info icon reveals Terms/Privacy
    return GestureDetector(
      onTap: _showLegalBottomSheet,
      child: Icon(
        Icons.info_outline,
        color: Colors.white.withOpacity(0.25),
        size: 20,
      ),
    );
  }

  void _showLegalBottomSheet() {
    showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'Legal',
              style: TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 16),
            ListTile(
              leading: const Icon(Icons.description, color: Colors.white54),
              title: const Text('Terms of Service', style: TextStyle(color: Colors.white)),
              trailing: const Icon(Icons.chevron_right, color: Colors.white24),
              onTap: () {
                Navigator.pop(context);
                // TODO: Navigate to Terms
              },
            ),
            ListTile(
              leading: const Icon(Icons.privacy_tip, color: Colors.white54),
              title: const Text('Privacy Policy', style: TextStyle(color: Colors.white)),
              trailing: const Icon(Icons.chevron_right, color: Colors.white24),
              onTap: () {
                Navigator.pop(context);
                // TODO: Navigate to Privacy
              },
            ),
            const SizedBox(height: 16),
            Text(
              'By continuing, you agree to our Terms and Privacy Policy.',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.white.withOpacity(0.4),
                fontSize: 12,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



========================================

FILE #37: E:\Vive\lib\features\camera\domain\models\camera_models.dart

========================================


// Barrel file for camera domain models
// Import this single file to get all camera-related models

export 'drawing_stroke.dart';
export 'sticker_overlay.dart';
export 'text_overlay.dart';
export 'edit_mode.dart';



========================================

FILE #38: E:\Vive\lib\features\camera\domain\models\drawing_stroke.dart

========================================


import 'package:flutter/material.dart';

/// A drawing stroke with color and width
/// Used by the camera's drawing overlay system
/// 
/// IMPORTANT: [points] must be stored as normalized coordinates (0.0 to 1.0)
/// relative to the capture area width and height.
class DrawingStroke {
  final List<Offset> points;
  final Color color;
  final double strokeWidth;

  const DrawingStroke({
    required this.points,
    required this.color,
    this.strokeWidth = 5.0,
  });
  
  /// Create a copy with new points added
  DrawingStroke copyWithPoint(Offset point) {
    return DrawingStroke(
      points: [...points, point],
      color: color,
      strokeWidth: strokeWidth,
    );
  }
}



========================================

FILE #39: E:\Vive\lib\features\camera\domain\models\edit_mode.dart

========================================


/// Edit mode types for the camera screen
enum EditMode {
  none,
  draw,
  sticker,
  text,
  audio, // Voice note recording mode
}

extension EditModeExtension on EditMode {
  bool get isEditing => this != EditMode.none;
  
  String get label {
    switch (this) {
      case EditMode.none: return 'None';
      case EditMode.draw: return 'Draw';
      case EditMode.sticker: return 'Sticker';
      case EditMode.text: return 'Text';
      case EditMode.audio: return 'Voice';
    }
  }
}



========================================

FILE #40: E:\Vive\lib\features\camera\domain\models\sticker_overlay.dart

========================================


import 'package:flutter/material.dart';

/// A sticker overlay item
/// Represents an emoji sticker placed on the camera capture
/// 
/// IMPORTANT: [position] must be stored as normalized coordinates (0.0 to 1.0)
/// relative to the capture area width and height.
class StickerOverlay {
  String emoji;
  Offset position;
  double scale;
  double rotation;

  StickerOverlay({
    required this.emoji,
    required this.position,
    this.scale = 1.0,
    this.rotation = 0.0,
  });
  
  /// Create a copy with updated position
  StickerOverlay copyWith({
    String? emoji,
    Offset? position,
    double? scale,
    double? rotation,
  }) {
    return StickerOverlay(
      emoji: emoji ?? this.emoji,
      position: position ?? this.position,
      scale: scale ?? this.scale,
      rotation: rotation ?? this.rotation,
    );
  }
}



========================================

FILE #41: E:\Vive\lib\features\camera\domain\models\text_overlay.dart

========================================


import 'package:flutter/material.dart';
import '../../../../core/theme/app_typography.dart';

/// Font styles for NoteIt-style text editing
enum TextFontStyle {
  classic,    // Clean sans-serif
  handwritten, // Playful handwritten
  bold,       // Heavy impact
  retro,      // Monospace/retro
  neon,       // Glowing effect
}

extension TextFontStyleExtension on TextFontStyle {
  String get displayName {
    switch (this) {
      case TextFontStyle.classic: return 'Classic';
      case TextFontStyle.handwritten: return 'Script';
      case TextFontStyle.bold: return 'Bold';
      case TextFontStyle.retro: return 'Retro';
      case TextFontStyle.neon: return 'Neon';
    }
  }
  
  TextStyle getStyle(double fontSize, Color color) {
    switch (this) {
      case TextFontStyle.classic:
        return AppTypography.bodyMedium.copyWith(
          fontSize: fontSize,
          color: color,
          fontWeight: FontWeight.w500,
        );
      case TextFontStyle.handwritten:
        return AppTypography.handwritten.copyWith(
          fontSize: fontSize,
          color: color,
        );
      case TextFontStyle.bold:
        return AppTypography.bodyMedium.copyWith(
          fontSize: fontSize,
          color: color,
          fontWeight: FontWeight.w900,
        );
      case TextFontStyle.retro:
        return AppTypography.displayMedium.copyWith(
          fontSize: fontSize,
          color: color,
          fontWeight: FontWeight.w600,
        );
      case TextFontStyle.neon:
        return AppTypography.bodyMedium.copyWith(
          fontSize: fontSize,
          color: color,
          fontWeight: FontWeight.bold,
          shadows: [
            Shadow(color: color.withAlpha(179), blurRadius: 10),
            Shadow(color: color.withAlpha(128), blurRadius: 20),
          ],
        );
    }
  }
}

/// A text overlay item with font style support
/// 
/// IMPORTANT: [position] must be stored as normalized coordinates (0.0 to 1.0)
/// relative to the capture area width and height.
class TextOverlay {
  String text;
  Offset position;
  Color color;
  double fontSize;
  TextFontStyle fontStyle;
  double scale;
  double rotation;

  TextOverlay({
    required this.text,
    required this.position,
    this.color = Colors.white,
    this.fontSize = 32,
    this.fontStyle = TextFontStyle.classic,
    this.scale = 1.0,
    this.rotation = 0.0,
  });
  
  /// Create a copy with updated properties
  TextOverlay copyWith({
    String? text,
    Offset? position,
    Color? color,
    double? fontSize,
    TextFontStyle? fontStyle,
    double? scale,
    double? rotation,
  }) {
    return TextOverlay(
      text: text ?? this.text,
      position: position ?? this.position,
      color: color ?? this.color,
      fontSize: fontSize ?? this.fontSize,
      fontStyle: fontStyle ?? this.fontStyle,
      scale: scale ?? this.scale,
      rotation: rotation ?? this.rotation,
    );
  }
}



========================================

FILE #42: E:\Vive\lib\features\camera\domain\services\video_processing_service.dart

========================================


import 'dart:io';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:ffmpeg_kit_flutter_new_https/ffmpeg_kit.dart';
import 'package:ffmpeg_kit_flutter_new_https/ffprobe_kit.dart';
import 'package:ffmpeg_kit_flutter_new_https/return_code.dart';
import 'package:ffmpeg_kit_flutter_new_https/ffmpeg_kit_config.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'dart:isolate';
import 'dart:typed_data';
import 'package:image/image.dart' as img;
import 'package:nock/features/camera/domain/models/camera_models.dart';

/// Data class for overlay content to be composited onto video/images
class OverlayContent {
  final List<DrawingStroke> strokes;
  final List<StickerOverlay> stickers;
  final List<TextOverlay> textOverlays;

  const OverlayContent({
    required this.strokes,
    required this.stickers,
    required this.textOverlays,
  });

  bool get isEmpty => strokes.isEmpty && stickers.isEmpty && textOverlays.isEmpty;
  bool get isNotEmpty => !isEmpty;
}

/// Service for compositing overlays onto videos and images
/// 
/// This service handles:
/// - Creating transparent overlay images from drawings/stickers/text
/// - Compositing overlays onto videos using FFmpeg
/// - Extracting video thumbnails
/// - Smart resolution handling (downscale 4K to 1080p, no upscaling)
class VideoProcessingService {
  
  /// Extract first frame from video as JPEG thumbnail
  /// Used for widget preview and PlayerScreen fallback
  static Future<File?> extractVideoThumbnail(String videoPath) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final thumbnailPath = '${tempDir.path}/vibe_thumbnail_$timestamp.jpg';
      
      // FFmpeg command to extract first frame as JPEG
      // -ss 0: Seek to start (first frame)
      // -vframes 1: Extract only 1 frame
      // -q:v 2: High quality JPEG (2-5 is good, lower = better)
      final command = [
        '-y',
        '-hwaccel', 'auto',
        '-i', videoPath,
        '-ss', '0',
        '-vframes', '1',
        '-q:v', '2',
        '-pix_fmt', 'yuvj420p',
        thumbnailPath,
      ];
      
      debugPrint('FFmpeg: Extracting video thumbnail...');
      final session = await FFmpegKit.executeWithArguments(command);
      final returnCode = await session.getReturnCode();
      
      if (ReturnCode.isSuccess(returnCode)) {
        final thumbnailFile = File(thumbnailPath);
        if (await thumbnailFile.exists()) {
          debugPrint('FFmpeg: Thumbnail extracted to $thumbnailPath');
          return thumbnailFile;
        }
      }
      
      debugPrint('FFmpeg: Failed to extract thumbnail');
      return null;
    } catch (e) {
      debugPrint('Error extracting thumbnail: $e');
      return null;
    }
  }

  /// Extract audio track from video as m4a/aac
  /// Used to minimize bandwidth for transcription
  static Future<File?> extractAudio(String videoPath) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final audioPath = '${tempDir.path}/vibe_audio_extract_$timestamp.m4a';
      
      // FFmpeg command to extract audio without re-encoding (if possible)
      // -vn: Skip video
      // -acodec copy: Copy audio stream without re-encoding (super fast)
      final command = [
        '-y',
        '-hwaccel', 'auto',
        '-i', videoPath,
        '-vn',
        '-acodec', 'copy',
        audioPath,
      ];
      
      debugPrint('FFmpeg: Extracting audio from video...');
      final session = await FFmpegKit.executeWithArguments(command);
      final returnCode = await session.getReturnCode();
      
      if (ReturnCode.isSuccess(returnCode)) {
        final audioFile = File(audioPath);
        if (await audioFile.exists()) {
          debugPrint('FFmpeg: Audio extracted to $audioPath');
          return audioFile;
        }
      }
      
      // Fallback: If copy fails (e.g. incompatible container), try encoding to aac
      debugPrint('FFmpeg: Fast audio copy failed, trying AAC encode fallback...');
      final fallbackCommand = [
        '-y',
        '-hwaccel', 'auto',
        '-i', videoPath,
        '-vn',
        '-c:a', 'aac',
        '-b:a', '128k',
        audioPath,
      ];
      
      final fallbackSession = await FFmpegKit.executeWithArguments(fallbackCommand);
      final fallbackReturnCode = await fallbackSession.getReturnCode();
      
      if (ReturnCode.isSuccess(fallbackReturnCode)) {
        final audioFile = File(audioPath);
        if (await audioFile.exists()) {
          return audioFile;
        }
      }

      debugPrint('FFmpeg: Failed to extract audio');
      return null;
    } catch (e) {
      debugPrint('Error extracting audio: $e');
      return null;
    }
  }

  /// Calculate target resolution for video output
  /// 
  /// PORTAL PARADOX FIX: Force 1:1 aspect ratio to match UI portal
  /// The UI shows a 1:1 square portal (portalHeight = portalWidth)
  /// We MUST crop the video to this same ratio to prevent:
  /// - Privacy leaks (hidden top/bottom areas appearing in final video)
  /// - Floating overlays (drawings misaligned with cropped area)
  /// 
  /// Example: 1080x1920 source â†’ 1080x1080 output (1:1 square)
  static Size calculateTargetResolution(Size sourceSize, {double targetAspect = 1.0}) {
    // Max width is 720p for widget optimization/file size balance
    const double maxWidth = 720.0;
    
    // Use source width or cap at 1080p
    final double targetWidth = sourceSize.width > maxWidth ? maxWidth : sourceSize.width;
    
    // CRITICAL FIX: Calculate height based on UI portal aspect ratio (1:1 square)
    // NOT based on the camera source (9:16)
    // Height = Width / AspectRatio
    // Example: 1080 / 1 = 1080 pixels (square)
    final double targetHeight = targetWidth / targetAspect;
    
    return Size(targetWidth, targetHeight);
  }

  /// Create a transparent overlay PNG from drawings, stickers, and text
  /// 
  /// This properly maps screen coordinates to video coordinates,
  /// accounting for BoxFit.cover cropping in the camera preview.
  /// 
  /// [videoSize] - The target video dimensions
  /// [renderSize] - The screen render area dimensions (where user drew)
  /// [content] - The overlay content (strokes, stickers, text)
  /// [isFrontCamera] - UNUSED: FFmpeg already applies hflip to front camera video,
  ///                   so overlay coordinates map 1:1 without modification.
  static Future<File?> createOverlayImage({
    required Size videoSize,
    required Size renderSize,
    required OverlayContent content,
    bool isFrontCamera = false,  // Kept for API compatibility, but UNUSED
  }) async {
    try {
      // Create a picture recorder to draw overlays on transparent background
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      
      // FIX: Removed mirrorX() function entirely.
      // The FFmpeg command already applies hflip to front camera videos,
      // so overlay coordinates should map 1:1 without modification.
      // Previously, we were double-mirroring which caused overlays to
      // appear on the opposite side from where the user drew them.
      
      // ========== CRITICAL: Aspect Ratio Offset Calculation ==========
      // 
      // PROBLEM: The camera preview uses BoxFit.cover which CROPS the video
      // to fill the screen. Screen coordinate (0,0) does NOT map to video (0,0).
      //
      // SOLUTION: Calculate the crop offset and apply it to all coordinates.
      // 
      // UPDATE: We now use normalized coordinates (0.0 to 1.0) relative to renderSize.
      // ================================================================
      
      final renderAspect = renderSize.width / renderSize.height;
      final videoAspect = videoSize.width / videoSize.height;
      
      double scale;
      double offsetX = 0;
      double offsetY = 0;
      
      if (renderAspect > videoAspect) {
        // Screen is wider than video - video is cropped on top/bottom
        scale = videoSize.width / renderSize.width;
        final scaledHeight = renderSize.height * scale;
        offsetY = (videoSize.height - scaledHeight) / 2;
      } else {
        // Screen is taller than video - video is cropped on left/right
        scale = videoSize.height / renderSize.height;
        final scaledWidth = renderSize.width * scale;
        offsetX = (videoSize.width - scaledWidth) / 2;
      }
      
      // Coordinate mapping helpers
      double mapX(double normalizedX) => normalizedX * (renderSize.width * scale) + offsetX;
      double mapY(double normalizedY) => normalizedY * (renderSize.height * scale) + offsetY;

      // Base width for scaling (matches DrawingPainter strategy)
      final videoScaleFactor = videoSize.width / 360;
      
      debugPrint('Overlay: renderSize=$renderSize, videoSize=$videoSize, scale=$scale, offsetX=$offsetX, offsetY=$offsetY');
      
      // Draw strokes
      for (final stroke in content.strokes) {
        final paint = Paint()
          ..color = stroke.color
          ..strokeWidth = stroke.strokeWidth * videoScaleFactor
          ..strokeCap = StrokeCap.round
          ..style = PaintingStyle.stroke;
        
        if (stroke.points.length > 1) {
          final path = Path();
          path.moveTo(mapX(stroke.points.first.dx), mapY(stroke.points.first.dy));
          for (int i = 1; i < stroke.points.length; i++) {
            path.lineTo(mapX(stroke.points[i].dx), mapY(stroke.points[i].dy));
          }
          canvas.drawPath(path, paint);
        }
      }
      
      // Draw stickers
      for (final sticker in content.stickers) {
        final textPainter = TextPainter(
          text: TextSpan(
            text: sticker.emoji,
            style: TextStyle(fontSize: 48 * sticker.scale * videoScaleFactor),
          ),
          textDirection: TextDirection.ltr,
        );
        textPainter.layout();
        
        final centerX = mapX(sticker.position.dx) + textPainter.width / 2;
        final centerY = mapY(sticker.position.dy) + textPainter.height / 2;
        
        canvas.save();
        canvas.translate(centerX, centerY);
        canvas.rotate(sticker.rotation);
        canvas.translate(-textPainter.width / 2, -textPainter.height / 2);
        textPainter.paint(canvas, Offset.zero);
        canvas.restore();
      }
      
      // Draw text overlays
      for (final textItem in content.textOverlays) {
        if (textItem.text.isEmpty) continue;
        
        final style = textItem.fontStyle.getStyle(
          textItem.fontSize * videoScaleFactor, 
          textItem.color,
        ).copyWith(
          shadows: [
            Shadow(
              color: Colors.black54,
              offset: Offset(1 * videoScaleFactor, 1 * videoScaleFactor),
              blurRadius: 4 * videoScaleFactor,
            ),
          ],
        );
        
        final textPainter = TextPainter(
          text: TextSpan(text: textItem.text, style: style),
          textDirection: TextDirection.ltr,
        );
        textPainter.layout();
        
        textPainter.paint(canvas, Offset(mapX(textItem.position.dx), mapY(textItem.position.dy)));
      }
      
      // Create the image
      final picture = recorder.endRecording();
      final image = await picture.toImage(
        videoSize.width.toInt(),
        videoSize.height.toInt(),
      );
      
      // CRITICAL PERFORMANCE FIX: "Extract on Main, Encode on Worker"
      // 1. Extract raw RGBA bytes on UI thread (extremely fast, no compression)
      final byteData = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
      final int width = image.width;
      final int height = image.height;
      
      // Explicitly dispose of the GPU handle immediately
      image.dispose();
      
      if (byteData == null) return null;

      // 2. Offload heavy PNG compression to a background isolate
      final Uint8List pngBytes = await Isolate.run(() {
        final rawBytes = byteData.buffer.asUint8List();
        
        final imgImage = img.Image.fromBytes(
          width: width,
          height: height,
          bytes: rawBytes.buffer,
          numChannels: 4,
          format: img.Format.uint8,
          order: img.ChannelOrder.rgba,
        );
        
        return img.encodePng(imgImage);
      });
      
      final tempDir = await getTemporaryDirectory();
      final fileName = 'vibe_overlay_${DateTime.now().millisecondsSinceEpoch}.png';
      final file = File('${tempDir.path}/$fileName');
      await file.writeAsBytes(pngBytes);
      
      return file;
    } catch (e) {
      debugPrint('Error creating overlay image: $e');
      return null;
    }
  }

  /// Composite video with overlay using FFmpeg
  /// Burns drawings, stickers, and text onto the video
  ///
  /// Returns the composited video file, or null if failed
  static Future<File?> compositeVideoWithOverlay({
    required String videoPath,
    required File overlayImage,
    required Size targetSize,
    bool isFrontCamera = false, // NEW: Handle selfie mirroring
  }) async {
    try {
      // 1. PRE-CHECK: Does the video actually have audio?
      // This prevents the "Stream not found" crash.
      bool hasAudio = false;
      try {
        final probeSession = await FFprobeKit.getMediaInformation(videoPath);
        final mediaInfo = probeSession.getMediaInformation();
        if (mediaInfo != null) {
          final streams = mediaInfo.getStreams();
          hasAudio = streams.any((s) => s.getType() == 'audio');
        }
      } catch (e) {
        debugPrint('FFprobe error: $e');
        // Assume no audio if probe fails to be safe
        hasAudio = false;
      }

      debugPrint('FFmpeg: Input video has audio: $hasAudio');

      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final outputPath = '${tempDir.path}/vibe_video_overlay_$timestamp.mp4';

      // Delete existing output if any
      final outputFile = File(outputPath);
      if (await outputFile.exists()) await outputFile.delete();

      // RACE CONDITION FIX: Wait for overlay PNG to be fully written
      int retryCount = 0;
      const maxRetries = 10;
      const retryDelayMs = 100;

      while (retryCount < maxRetries) {
        final exists = await overlayImage.exists();
        final size = exists ? await overlayImage.length() : 0;

        if (exists && size > 0) {
          debugPrint('FFmpeg: Overlay PNG validated ($size bytes) after $retryCount retries');
          break;
        }

        debugPrint('FFmpeg: Waiting for overlay PNG to be written... (attempt ${retryCount + 1}/$maxRetries)');
        await Future.delayed(const Duration(milliseconds: retryDelayMs));
        retryCount++;
      }

      // Final validation after retries
      final overlaySize = await overlayImage.length();
      if (overlaySize == 0) {
        debugPrint('FFmpeg: CRITICAL - Overlay PNG is still empty after ${maxRetries * retryDelayMs}ms. Aborting.');
        return null;
      }

      final targetWidth = targetSize.width.toInt();
      final targetHeight = targetSize.height.toInt();

      // PORTAL PARADOX FIX: Center-crop to match UI portal
      // We use 'force_original_aspect_ratio=increase' to ensure the video COVERS the target square
      // Then crop the center square. This matches BoxFit.cover behavior in Flutter.
      final String scaleFilter = 'scale=$targetWidth:$targetHeight:force_original_aspect_ratio=increase';
      final String cropFilter = 'crop=$targetWidth:$targetHeight';

      final String videoFilter = isFrontCamera ? '[0:v]hflip,$scaleFilter,$cropFilter,fps=30[scaled]' : '[0:v]$scaleFilter,$cropFilter,fps=30[scaled]';

      // FIX: SELFIE OVERLAY PARADOX - Do NOT flip overlay for selfies
      // Although video is flipped, overlay is drawn relative to screen coordinates
      final String overlayFilter = '[1:v]scale=$targetWidth:$targetHeight[overlay]';

      // BUILD THE COMMAND DYNAMICALLY
      final List<String> command = [
        '-y',
        '-hwaccel', 'auto',
        '-i', videoPath, // Input 0: Video
        '-i', overlayImage.path, // Input 1: Transparent overlay PNG
      ];

      // LOGIC: If no audio, generate silence (Input 2)
      if (!hasAudio) {
        command.addAll([
          '-f',
          'lavfi',
          '-i',
          'anullsrc=channel_layout=mono:sample_rate=44100', // Input 2: Silence
        ]);
      }

      command.addAll([
        '-filter_complex',
        '$videoFilter;$overlayFilter;[scaled][overlay]overlay=0:0:format=auto',
        '-c:v', Platform.isIOS ? 'h264_videotoolbox' : 'h264_mediacodec',
      ]);

      if (Platform.isIOS) {
        // h264_videotoolbox specific settings (LGPL compliant)
        command.addAll([
          '-b:v', '2M',
          '-profile:v', 'high',
        ]);
      } else {
        // h264_mediacodec (Android) - USES HARDWARE ENCODER (LGPL compliant)
        command.addAll([
          '-b:v', '2M',
        ]);
      }

      // AUDIO MAPPING STRATEGY
      if (hasAudio) {
        // Scenario A: Source has audio. Process it normally.
        command.addAll([
          '-c:a', 'aac',
          '-b:a', '96k', // Lower bitrate
          '-ac', '1', // Mono audio
          '-ar', '44100',
          '-af', 'aresample=async=1', // Safe to use because we know audio exists
        ]);
      } else {
        // Scenario B: Source is silent. Map the generated silence (Input 2).
        command.addAll([
          '-map', '0:v', // Map Video from Input 0
          '-map', '2:a', // Map Audio from Input 2 (Silence)
          '-c:a', 'aac',
          '-shortest', // Stop silence when video ends
        ]);
      }

      command.addAll([
        '-fps_mode', 'cfr', // Constant frame rate

        // WEB OPTIMIZATION
        '-movflags', '+faststart', // Allows playback to start before download completes

        '-pix_fmt', 'yuv420p', // Required for iOS/QuickTime compatibility
        outputPath,
      ]);

      debugPrint('FFmpeg: Compositing video with overlays...');
      debugPrint('FFmpeg command: ${command.join(' ')}');

      final session = await FFmpegKit.executeWithArgumentsAsync(command);
      final returnCode = await session.getReturnCode();

      if (ReturnCode.isSuccess(returnCode)) {
        debugPrint('FFmpeg: SUCCESS - Video with overlays saved to $outputPath');
        // Clean up overlay image
        try { await overlayImage.delete(); } catch (_) {}
        return File(outputPath);
      } else {
        // HARDWARE ENCODER FALLBACK: If hardware encoder fails, retry with software libx264
        final logs = await session.getAllLogsAsString();
        debugPrint('FFmpeg: Hardware encoder failed. Logs: $logs');
        debugPrint('FFmpeg: Retrying with software encoder (libx264)...');
        
        // Command for software fallback
        final List<String> fallbackCommand = List.from(command);
        
        // Find and replace the encoder
        final encoderIdx = fallbackCommand.indexOf('-c:v');
        if (encoderIdx != -1 && encoderIdx + 1 < fallbackCommand.length) {
          fallbackCommand[encoderIdx + 1] = 'libx264';
          // libx264 specific tuning for mobile
          fallbackCommand.insertAll(encoderIdx + 2, ['-preset', 'ultrafast', '-crf', '23']);
        }
        
        final fallbackSession = await FFmpegKit.executeWithArgumentsAsync(fallbackCommand);
        final fallbackReturnCode = await fallbackSession.getReturnCode();
        
        // Clean up overlay image
        try { await overlayImage.delete(); } catch (_) {}
        
        if (ReturnCode.isSuccess(fallbackReturnCode)) {
          debugPrint('FFmpeg: SUCCESS (Software Fallback) - video saved to $outputPath');
          return File(outputPath);
        } else {
          final fallbackLogs = await fallbackSession.getAllLogsAsString();
          debugPrint('FFmpeg: CRITICAL - Software fallback also failed: $fallbackLogs');
          return null;
        }
      }
    } catch (e) {
      debugPrint('Error compositing video with overlays: $e');
      return null;
    }
  }
  /// Non-blocking video processing with callback (Optimistic UI support)
  /// 
  /// This runs the FFmpeg command asynchronously and triggers the callback
  /// when complete, allowing the UI to unblock immediately (Navigator.pop).
  static void processAndUpload({
    required String videoPath,
    required File overlayImage,
    required Size targetSize,
    required Function(File) onProcessed,
    required Function(String) onError,
    bool isFrontCamera = false,  // NEW: Handle selfie mirroring
  }) async {
    try {
      final tempDir = await getTemporaryDirectory();
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final outputPath = '${tempDir.path}/vibe_video_overlay_$timestamp.mp4';
      
      // SAFETY CHECK: Validate overlay PNG before FFmpeg (docs recommendation)
      if (!await overlayImage.exists()) {
        debugPrint('FFmpeg (Async): ERROR - Overlay PNG does not exist');
        onError('Overlay PNG does not exist');
        return;
      }
      final overlaySize = await overlayImage.length();
      if (overlaySize == 0) {
        debugPrint('FFmpeg (Async): ERROR - Overlay PNG is empty (0 bytes)');
        onError('Overlay PNG is empty');
        return;
      }
      debugPrint('FFmpeg (Async): Overlay PNG validated (${overlaySize} bytes)');
      
      // 1. PRE-CHECK: Does the video actually have audio? (Async version)
      bool hasAudio = false;
      try {
        final probeSession = await FFprobeKit.getMediaInformation(videoPath);
        final mediaInfo = probeSession.getMediaInformation();
        if (mediaInfo != null) {
          final streams = mediaInfo.getStreams();
          hasAudio = streams.any((s) => s.getType() == 'audio');
        }
      } catch (e) {
         debugPrint('FFprobe (Async) error: $e');
         hasAudio = false;
      }
      debugPrint('FFmpeg (Async): Input video has audio: $hasAudio');

      final targetWidth = targetSize.width.toInt();
      final targetHeight = targetSize.height.toInt();
      
      // PORTAL PARADOX FIX: Center-crop to match UI portal (same as compositeVideoWithOverlay)
      final String scaleFilter = 'scale=$targetWidth:$targetHeight:force_original_aspect_ratio=increase';
      final String cropFilter = 'crop=$targetWidth:$targetHeight';

      final String videoFilter = isFrontCamera
          ? '[0:v]hflip,$scaleFilter,$cropFilter,fps=30[scaled]'
          : '[0:v]$scaleFilter,$cropFilter,fps=30[scaled]';
      
      // FIX: SELFIE OVERLAY PARADOX - Do NOT flip overlay for selfies
      final String overlayFilter = '[1:v]scale=$targetWidth:$targetHeight[overlay]';
      
      // BUILD THE COMMAND DYNAMICALLY
      final List<String> command = [
        '-y',
        '-hwaccel', 'auto',
        '-i', videoPath,           
        '-i', overlayImage.path,   
      ];

      // LOGIC: If no audio, generate silence (Input 2)
      if (!hasAudio) {
        command.addAll([
          '-f', 'lavfi',
          '-i', 'anullsrc=channel_layout=mono:sample_rate=44100', // Input 2: Silence
        ]);
      }

      command.addAll([
        '-filter_complex',
        '$videoFilter;$overlayFilter;[scaled][overlay]overlay=0:0:format=auto',
        '-c:v', Platform.isIOS ? 'h264_videotoolbox' : 'h264_mediacodec',
      ]);

      if (Platform.isIOS) {
        // h264_videotoolbox specific settings (LGPL compliant)
        command.addAll([
          '-b:v', '2M',
          '-profile:v', 'high',
        ]);
      } else {
        // h264_mediacodec (Android) - USES HARDWARE ENCODER (LGPL compliant)
        command.addAll([
          '-b:v', '2M',
        ]);
      }

      // AUDIO MAPPING STRATEGY
      if (hasAudio) {
         command.addAll([
          '-c:a', 'aac',
          '-b:a', '96k',             // Lower bitrate
          '-ac', '1',                // Mono audio
          '-ar', '44100',
          '-af', 'aresample=async=1',
         ]);
      } else {
        command.addAll([
          '-map', '0:v', // Map Video from Input 0
          '-map', '2:a', // Map Audio from Input 2 (Silence)
          '-c:a', 'aac',
          '-shortest',   // Stop silence when video ends
        ]);
      }

      command.addAll([
        // FIX: FFmpeg 8.0 - Use fps_mode instead of deprecated vsync
        '-fps_mode', 'cfr',     // Constant frame rate
        
        // WEB OPTIMIZATION
        '-movflags', '+faststart',
        
        '-pix_fmt', 'yuv420p',     
        outputPath,
      ]);
      
      debugPrint('FFmpeg (Async): Starting execution...');
      
      FFmpegKit.executeWithArgumentsAsync(command, (session) async {
         final returnCode = await session.getReturnCode();
         final logs = await session.getAllLogsAsString();
         
         if (ReturnCode.isSuccess(returnCode)) {
             debugPrint('FFmpeg (Async): Success! Handoff to upload.');
             final outFile = File(outputPath);
             if (await outFile.exists()) {
                 onProcessed(outFile);
             } else {
                 onError('Output file not found after success');
             }
             // Cleanup overlay
             try { if (await overlayImage.exists()) await overlayImage.delete(); } catch (_) {}
         } else {
             // HARDWARE ENCODER FALLBACK
             debugPrint('FFmpeg (Async): Hardware encoder failed, retrying with libx264...');
             
             final List<String> fallbackCommand = List.from(command);
             final encoderIdx = fallbackCommand.indexOf('-c:v');
             if (encoderIdx != -1 && encoderIdx + 1 < fallbackCommand.length) {
               fallbackCommand[encoderIdx + 1] = 'libx264';
               fallbackCommand.insertAll(encoderIdx + 2, ['-preset', 'ultrafast', '-crf', '23']);
             }
             
             FFmpegKit.executeWithArgumentsAsync(fallbackCommand, (fallbackSession) async {
               final fallbackReturnCode = await fallbackSession.getReturnCode();
               
               if (ReturnCode.isSuccess(fallbackReturnCode)) {
                 debugPrint('FFmpeg (Async): Success (Software Fallback)!');
                 final outFile = File(outputPath);
                 onProcessed(outFile);
               } else {
                 final fallbackLogs = await fallbackSession.getAllLogsAsString();
                 debugPrint('FFmpeg (Async): CRITICAL - Software fallback also failed: $fallbackLogs');
                 onError('Video processing failed (HW and SW encoders failed)');
               }
               
               // Cleanup overlay
               try { if (await overlayImage.exists()) await overlayImage.delete(); } catch (_) {}
             });
         }
      });
    } catch (e) {
      debugPrint('Error starting async processing: $e');
      onError(e.toString());
    }
  }

  /// Public helper for Isolate-based PNG encoding.
  /// 
  /// This allows CameraScreenNew to reuse the same high-performance
  /// encoding path used for video overlay creation.
  /// 
  /// [rawBytes] - Raw RGBA pixel data from ui.Image.toByteData(format: rawRgba)
  /// [width] - Image width in pixels
  /// [height] - Image height in pixels
  static Future<Uint8List> encodeImageInIsolate(Uint8List rawBytes, int width, int height) async {
    return Isolate.run(() {
      final imgImage = img.Image.fromBytes(
        width: width,
        height: height,
        bytes: rawBytes.buffer,
        numChannels: 4,
        format: img.Format.uint8,
        order: img.ChannelOrder.rgba,
      );
      
      return img.encodePng(imgImage);
    });
  }
}

/// Provider for VideoProcessingService
final videoProcessingServiceProvider = Provider<VideoProcessingService>((ref) {
  return VideoProcessingService();
});



========================================

FILE #43: E:\Vive\lib\features\camera\presentation\camera_screen_new.dart

========================================


import 'dart:io';
import 'dart:async';
import 'dart:math' as math;
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter/services.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:camera/camera.dart';
import 'package:path_provider/path_provider.dart';
import 'package:video_player/video_player.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:photo_manager/photo_manager.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:photo_manager_image_provider/photo_manager_image_provider.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/services/media_service.dart';
import 'package:nock/core/services/audio_service.dart';
import 'package:nock/core/services/native_service_helper.dart';
import 'package:nock/core/services/auth_service.dart';  // For user avatar in audio-only mode
import 'package:nock/core/services/vibe_service.dart';  // For direct send
import 'package:nock/shared/widgets/aura_visualization.dart';  // For consistent audio visualization
import 'package:nock/shared/widgets/glass_container.dart' as glass;  // For CircularLuminousBorderPainter (prefixed to avoid conflict)
import 'package:nock/features/squad/presentation/squad_screen.dart';  // For friendsProvider
import 'package:nock/core/models/vibe_model.dart';  // For reply context
import 'package:nock/core/providers/vibe_upload_provider.dart';

// Extracted models, painters, services and widgets for better code organization
import 'package:nock/features/camera/domain/models/camera_models.dart';
import 'package:nock/features/camera/presentation/painters/camera_painters.dart';
import 'package:nock/features/camera/domain/services/video_processing_service.dart';
import 'package:nock/features/camera/presentation/widgets/camera_buttons.dart';
import 'package:nock/features/camera/presentation/widgets/waveform_visualizer.dart';

// NOTE: The following are now imported from camera_models.dart:
// - EditMode enum
// - DrawingStroke class  
// - StickerOverlay class
// - TextFontStyle enum + extension
// - TextOverlay class


/// NoteIt-style Camera Screen with INLINE editing
/// 
/// 2025 UX: 
/// - No duplicate buttons for navigation (gestures only)
/// - Vault/Memories accessible via bottom button -> modal sheet
/// - Settings via profile icon -> modal sheet
class CameraScreenNew extends ConsumerStatefulWidget {
  const CameraScreenNew({
    super.key,
    this.onOpenVault,
    this.onOpenSettings,
    this.onDrawingModeChanged,
    this.onCaptureStateChanged,
    this.isVisible = true,
    this.isAudioOnly = false,
    this.recipientId,
    this.replyTo,
  });

  final VibeModel? replyTo;
  final String? recipientId;
  final bool isAudioOnly;

  final VoidCallback? onOpenVault;
  final VoidCallback? onOpenSettings;
  final ValueChanged<bool>? onDrawingModeChanged;
  /// Called when capture state changes (recording, captured, or back to idle)
  /// True = active state (recording or captured), False = idle initial state
  final ValueChanged<bool>? onCaptureStateChanged;

  /// Visibility status from parent (e.g. PageView)
  final bool isVisible;

  @override
  ConsumerState<CameraScreenNew> createState() => _CameraScreenNewState();
}

class _CameraScreenNewState extends ConsumerState<CameraScreenNew>
    with WidgetsBindingObserver, TickerProviderStateMixin, AutomaticKeepAliveClientMixin {

  @override
  bool get wantKeepAlive => true; // ðŸ§­ CRITICAL: Prevent destruction on PageView swipe
  
  // Capture state
  File? _capturedImage;
  File? _capturedVideo;
  bool _isRecordingVideo = false;
  DateTime? _recordingActualStartTime; // Track valid capture duration
  
  // Ghost Recording Synchronization
  // Allows background tasks (like Direct Send) to wait for hardware to finish
  Completer<void>? _ghostRecordingCompleter;
  
  bool get _hasCaptured => _capturedImage != null || _capturedVideo != null || (_isAudioOnlyMode && _recordedAudioFile != null);
  
  // Video preview player
  VideoPlayerController? _videoPreviewController;
  bool _isVideoPreviewReady = false;
  
  // Front camera selfie tracking (for mirroring preview)
  bool _wasFrontCamera = false;
  
  // Inline editing state
  EditMode _currentEditMode = EditMode.none;
  final List<DrawingStroke> _drawingStrokes = [];
  // PERFORMANCE FIX: Use ValueNotifier to avoid full screen rebuilds on drag
  final ValueNotifier<List<Offset>> _currentStrokeNotifier = ValueNotifier([]);
  // PERFORMANCE FIX: Use ValueNotifier for Stickers
  final ValueNotifier<List<StickerOverlay>> _stickersNotifier = ValueNotifier([]);
  // PERFORMANCE FIX: Use ValueNotifier for Text Overlays
  final ValueNotifier<List<TextOverlay>> _textOverlaysNotifier = ValueNotifier([]);
  int? _selectedStickerIndex;
  int? _selectedTextIndex;
  
  // Drawing options
  Color _currentDrawColor = Colors.white;
  double _currentStrokeWidth = 5.0;
  
  // Audio recording state  
  File? _recordedAudioFile;
  int _audioDuration = 0;
  bool _isRecordingAudio = false;
  
  // Text editing
  final TextEditingController _textController = TextEditingController();
  final FocusNode _textFocusNode = FocusNode();
  bool _isEditingText = false;
  TextFontStyle _currentFontStyle = TextFontStyle.classic;
  double _currentTextSize = 32.0;

  // Curtain State (Fix 3: Hybrid Flash Prevention)
  bool _showCurtain = false;
  Timer? _curtainTimer;
  
  // Audio-Only Mode State
  bool _isAudioOnlyMode = false;
  bool _isMicPermissionGranted = true; // Default to true, will check in initState

  
  // Capture key for exporting
  // ðŸ§­ STABILITY FIX: Use LabeledGlobalKey for identifying the portal in the tree
  final GlobalKey _captureKey = LabeledGlobalKey('CameraPortalKey');
  
  // Gesture State (Listener-based for precise control)
  DateTime? _pointerDownTime;
  Timer? _longPressTimer;
  Timer? _preWarmTimer; // Selective pre-warm (150ms hold)
  static const Duration _tapThreshold = Duration(milliseconds: 500); // 500ms for deliberate tap
  
  // Zoom State (Snapchat Slide)
  double _dragStartY = 0;
  double _baseZoom = 1.0;
  double _initialScaleZoom = 1.0; // For pinch-to-zoom (Portal Scale)
  
  // State guards
  bool _isProcessingCapture = false;
  bool _isFromGallery = false;
  
  // HUD / Telemetry state
  Offset? _focusPoint;
  bool _showFocusReticle = false;
  Timer? _focusTimer;
  
  // Animation controllers
  late AnimationController _shutterController;
  late Animation<double> _shutterAnimation;
  late AnimationController _recordingProgressController;
  late AnimationController _pulseController;
  late Animation<double> _pulseAnimation;
  
  static const int maxRecordingDuration = 15;
  
  // Colors for UI (Luminescent - True Black)
  static const List<Color> _backgroundGradient = [
    AppColors.background,
    AppColors.background,
  ];
  
  // Drawing colors (Luminescent Palette)
  static const List<Color> _drawColors = [
    Color(0xFFF0F0F0), // Ghost White
    Color(0xFF39FF14), // Acid Green
    Color(0xFF00F0FF), // Electric Cyan
    Color(0xFFFF2A6D), // Glitch Red
    Color(0xFF00FF9F), // Spring Green
    Color(0xFF586069), // Gunmetal Grey
    Colors.black,
  ];
  
  // Sticker emoji sets
  static const List<String> _stickerEmojis = [
    'ðŸ˜€', 'ðŸ˜‚', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜Ž', 'ðŸ¥³', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜‡',
    'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ’•', 'ðŸ’–', 'ðŸ’',
    'ðŸ‘', 'ðŸ‘Ž', 'ðŸ‘Œ', 'âœŒï¸', 'ðŸ¤ž', 'ðŸ¤Ÿ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ’ª', 'ðŸ”¥',
    'â­', 'âœ¨', 'ðŸŒŸ', 'ðŸ’«', 'ðŸŽ‰', 'ðŸŽŠ', 'ðŸŽˆ', 'ðŸŽ', 'ðŸ†', 'ðŸ¥‡',
  ];

  /// Helper to switch modes and notify parent (Fix 1: Gesture Conflict)
  void _changeEditMode(EditMode mode) {
    setState(() => _currentEditMode = mode);
    
    // Notify parent to lock/unlock scrolling
    final bool isInteractive = mode == EditMode.draw || mode == EditMode.text;
    widget.onDrawingModeChanged?.call(isInteractive);

    if (mode == EditMode.text) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Tap anywhere on the photo to add text'),
          duration: Duration(seconds: 2),
          backgroundColor: Colors.black87,
        ),
      );
    }
  }
  
  /// Helper to notify HomeScreen about capture state for history indicator visibility
  /// isActive = true when actively recording or has captured content
  void _notifyCaptureState() {
    final isActive = _isRecordingVideo || _isRecordingAudio || _hasCaptured;
    widget.onCaptureStateChanged?.call(isActive);
  }

  /// Fix 2: Tap-to-Place Text Logic
  void _addTextAtPosition(Offset position) {
    final newText = TextOverlay(
      text: '',
      position: position,
      color: _currentDrawColor,
      fontStyle: _currentFontStyle,
      fontSize: _currentTextSize,
    );
    
    final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
    currentTexts.add(newText);
    _textOverlaysNotifier.value = currentTexts;

    setState(() {
      _selectedTextIndex = _textOverlaysNotifier.value.length - 1;
      _isEditingText = true;
      // Also ensure we are in text mode
      _currentEditMode = EditMode.text;
    });
    // Give focus immediately
    _textFocusNode.requestFocus();
  }

  @override
  void initState() {
    super.initState();
    _isAudioOnlyMode = widget.isAudioOnly;
    WidgetsBinding.instance.addObserver(this);
    
    // PERMISSION OPTIMIZATION: Only initialize camera if NOT in audio-only mode.
    // This follows App Store Guideline 5.1.1 by not requesting camera permission
    // for a feature that doesn't need it.
    if (widget.isVisible && !_isAudioOnlyMode) {
      _initializeCamera();
    } else if (_isAudioOnlyMode) {
      _checkMicPermission();
    }

    
    _shutterController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
    _shutterAnimation = Tween<double>(begin: 1.0, end: 0.85).animate(
      CurvedAnimation(parent: _shutterController, curve: Curves.easeInOut),
    );
    
    _recordingProgressController = AnimationController(
      duration: Duration(seconds: maxRecordingDuration),
      vsync: this,
    );
    _recordingProgressController.addStatusListener((status) {
      if (status == AnimationStatus.completed && _isRecordingVideo) {
        _stopVideoRecording();
      }
    });
    
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    );
    _pulseAnimation = Tween<double>(begin: 1.0, end: 1.15).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );
    
    // FIX Issue 1: Check for pending video from interrupted recording
    _recoverPendingVideo();
  }
  
  /// FIX Issue 1: Recover video if app was killed during backgrounding
  Future<void> _recoverPendingVideo() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final pendingPath = prefs.getString('pending_video_path');
      if (pendingPath != null && pendingPath.isNotEmpty) {
        final file = File(pendingPath);
        if (await file.exists()) {
          debugPrint('Recovered pending video: $pendingPath');
          if (mounted) {
            setState(() {
              _capturedVideo = file;
              _isRecordingVideo = false;
            });
            _initializeVideoPreview(pendingPath, ++_initGeneration);
          }
        }
        // Clear the pending path after recovery attempt
        await prefs.remove('pending_video_path');
      }
    } catch (e) {
      debugPrint('Error recovering pending video: $e');
    }
  }

  Future<void> _initializeCamera() async {
    // 1. RESOURCE ARBITRATION: Force stop the background service to free the Mic
    // This prevents the infinite "Starting Camera..." hang on Android.
    await NativeServiceHelper.stopBackgroundService();
    
    // 2. BUFFER: Wait for OS Kernel to release the hardware driver lock (Industry Standard)
    await Future.delayed(const Duration(milliseconds: 200));

    final success = await ref.read(cameraControllerProvider.notifier).initializeCamera();
    
    // IF PERMISSION MISSING: It will now fail with error 'Camera permission required'
    // We handle that in build() by checking cameraState.error
    
    if (success && mounted) {
      // 3. Lift curtain only when ready
      Future.delayed(const Duration(milliseconds: 150), () {
        if (mounted) setState(() => _showCurtain = false);
      });
    } else if (mounted) {
      // Even if failed, we assume it handled its state (error set)
      // We lift the curtain to show the error UI (Placeholder)
      setState(() => _showCurtain = false);
    }
  }

  Future<void> _checkMicPermission() async {
    final status = await Permission.microphone.status;
    if (mounted) {
      setState(() {
        _isMicPermissionGranted = status.isGranted;
      });
    }
  }


  /// Intelligent camera resumption logic
  /// Cold boots the camera if it was disposed (e.g. after backgrounding)
  /// or simply resumes the preview if it was paused.
  Future<void> _resumeCamera() async {
    final cameraState = ref.read(cameraControllerProvider);
    if (cameraState.controller == null || !cameraState.isInitialized) {
      debugPrint('ðŸ“¸ Camera was disposed/uninitialized, performing cold boot...');
      await _initializeCamera();
    } else {
      debugPrint('ðŸ“¸ Resuming active camera preview...');
      await cameraState.controller?.resumePreview();
    }
  }

  @override
  void didUpdateWidget(CameraScreenNew oldWidget) {
    super.didUpdateWidget(oldWidget);
    
    // ðŸ§­ DEFINITIVE FIX: Warm Boot Refactoring
    // Instead of killing the sensor (reset), we use Standby mode (pausePreview).
    if (widget.isVisible != oldWidget.isVisible) {
      if (widget.isVisible) {
        debugPrint('ðŸ“¸ Camera: Visibility restored. Checking mode...');
        if (!_isAudioOnlyMode) {
          _resumeCamera();
        } else {
          _checkMicPermission();
        }
      }
    }
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) async {
    // 1. App Paused or Inactive: Safe Lifecycle Management
    // Trigger on inactive (earlier) to gain extra milliseconds on iOS
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      if (mounted) setState(() => _showCurtain = true);
      
      // STOP PLAYBACK IMMEDIATELY to prevent "Zombie Audio"
      ref.read(audioServiceProvider).stop();
      
      final cameraState = ref.read(cameraControllerProvider);
      final controller = cameraState.controller;
      
      // TRACK AND RELEASE ALL HARDWARE CONCURRENTLY
      final List<Future<dynamic>> stopFutures = [];
      
      // A. Video Stop Future - with crash recovery save
      if (controller != null && controller.value.isInitialized && controller.value.isRecordingVideo) {
        final videoFuture = controller.stopVideoRecording().then((videoFile) async {
          // FIX Issue 1: Save to SharedPreferences IMMEDIATELY, before mounted check
          // This ensures the path persists even if OS kills the app mid-callback
          try {
            final prefs = await SharedPreferences.getInstance();
            await prefs.setString('pending_video_path', videoFile.path);
            debugPrint('Video path saved for recovery: ${videoFile.path}');
          } catch (e) {
            debugPrint('Error saving video path to prefs: $e');
          }
          
          // Then update UI state if still mounted
          if (mounted) {
            setState(() {
              _capturedVideo = File(videoFile.path);
              _isRecordingVideo = false;
            });
            debugPrint('Video saved during app pause: ${videoFile.path}');
          }
        }).catchError((e) {
          debugPrint('Error stopping video recording during pause: $e');
        });
        stopFutures.add(videoFuture);
      }
      
      // B. Audio Stop Future
      if (_isRecordingAudio) {
        final audioFuture = ref.read(recordingStateProvider.notifier).stopRecording().then((path) {
          if (mounted) {
            if (path != null) {
              final timerDuration = ref.read(recordingDurationProvider);
              setState(() {
                _isRecordingAudio = false;
                _recordedAudioFile = File(path);
                _audioDuration = timerDuration > 0 ? timerDuration : 1;
              });
              debugPrint('Audio recording SAVED during app pause: $path');
            } else {
              setState(() {
                _isRecordingAudio = false;
                _recordedAudioFile = null;
                _audioDuration = 0;
              });
            }
          }
        }).catchError((e) {
          debugPrint('Error stopping audio recording during pause: $e');
        });
        stopFutures.add(audioFuture);
      }
      
      // Fire both immediately; only await if they exist
      if (stopFutures.isNotEmpty) {
        await Future.wait(stopFutures);
      }
      
      // C. Safe state reset via notifier (handles disposal and cancellation)
      if (mounted) {
        ref.read(cameraControllerProvider.notifier).reset();
      }
    } 
    // 2. App Resumed: Init camera BEHIND curtain (ONLY if no capture exists)
    else if (state == AppLifecycleState.resumed) {
      // If we have a captured video from interruption, show preview
      if (_capturedVideo != null && !_isVideoPreviewReady) {
        _initializeVideoPreview(_capturedVideo!.path, ++_initGeneration);
      }
      
      if (!_hasCaptured && !_isAudioOnlyMode) {
        _initializeCamera();
      } else {
        // If we have a capture or are in audio-only mode, ensure curtain is lifted immediately
        if (mounted) {
          setState(() => _showCurtain = false);
        }
      }
    }
}

  @override
  void dispose() {
    _currentStrokeNotifier.dispose(); // Dispose notifier
    _stickersNotifier.dispose();
    _textOverlaysNotifier.dispose();
    WidgetsBinding.instance.removeObserver(this);
    _shutterController.dispose();
    _recordingProgressController.dispose();
    _pulseController.dispose();
    _textController.dispose();
    _textFocusNode.dispose();
    _curtainTimer?.cancel();
    _longPressTimer?.cancel();
    _disposeVideoPreview();
    
    // ðŸ§­ RELEASE HARDWARE: Only when navigating away from the screen entirely
    try {
      // Use a final check to avoid Bad state: Cannot use "ref" after the widget was disposed.
      // In some edge cases, disposal happens so fast that ref is gone before this line.
      if (mounted) {
        ref.read(cameraControllerProvider.notifier).reset();
      }
    } catch (e) {
       debugPrint('Camera: Hardware release bypassed (already disposed)');
    }
    
    super.dispose();
  }


  // ============ CAPTURE METHODS ============


  Future<void> _takePhoto() async {
    // PREVENT CONCURRENT CAPTURE
    if (_isProcessingCapture) return;
    
    // GESTURE SAFEGUARD: If we are recording a video, a tap should be ...
    if (_isRecordingVideo) {
      debugPrint('ðŸ“¸ _takePhoto blocked: Already recording video. Redirecting to stop.');
      _stopVideoRecording();
      return;
    }

    _isProcessingCapture = true;
    HapticFeedback.mediumImpact();
    _shutterController.forward().then((_) {
      if (mounted) _shutterController.reverse();
    });

    final cameraState = ref.read(cameraControllerProvider);
    final cameraNotifier = ref.read(cameraControllerProvider.notifier);
    
    try {
      final photo = await cameraNotifier.takePhoto();
      
      if (photo != null && mounted) {
        setState(() {
          _capturedImage = photo;
          _capturedVideo = null;
          _wasFrontCamera = cameraState.isFrontCamera; // Track camera for mirror
          _clearAllOverlays();
        });
        // Stop the sensor to kill the Green Dot when previewing capture
        await cameraState.controller?.pausePreview();
        
        _notifyCaptureState(); // Hide history indicator
      }
    } catch (e) {
      debugPrint('âŒ Photo capture error: $e');
    } finally {
      if (mounted) setState(() => _isProcessingCapture = false);
    }
  }

  Future<void> _startVideoRecording() async {
    if (_isProcessingCapture) {
      debugPrint('âš ï¸ _startVideoRecording blocked: Capture already in progress');
      return;
    }
    
    final cameraState = ref.read(cameraControllerProvider);
    if (cameraState.controller == null || !cameraState.isInitialized) {
      debugPrint('âš ï¸ Cannot record: Camera not initialized');
      if (mounted) setState(() => _isProcessingCapture = false);
      return;
    }
    
    // Prevent double start
    if (_isRecordingVideo || cameraState.controller!.value.isRecordingVideo) {
      debugPrint('âš ï¸ Already recording video, ignoring start request');
      if (mounted) setState(() => _isProcessingCapture = false);
      return;
    }
    
    _isProcessingCapture = true;
    HapticFeedback.heavyImpact();
    
    // FIX: Stop any active audio playback before starting video recording
    ref.read(audioServiceProvider).stop();
    
    setState(() => _isRecordingVideo = true);
    _notifyCaptureState(); // Hide history indicator
    
    _recordingProgressController.reset();
    _recordingProgressController.forward();
    _pulseController.repeat(reverse: true);
    
    try {
      debugPrint('ðŸŽ¥ Starting video recording...');
      
      // JIT MICROPHONE PERMISSION
      // 1. Check/Request Mic Permission
      var micStatus = await Permission.microphone.status;
      if (micStatus.isDenied || micStatus.isRestricted) {
         debugPrint('ðŸŽ¤ Requesting mic permission JIT...');
         
         // Pause preview/UI if needed (optional)
         micStatus = await Permission.microphone.request();
         if (!micStatus.isGranted) {
           if (mounted) {
             ScaffoldMessenger.of(context).showSnackBar(
               const SnackBar(content: Text('Microphone needed for video audio')),
             );
           }
         }
      }
      
      // 2. Re-initialize with Audio if granted
      if (micStatus.isGranted) {
        await ref.read(cameraControllerProvider.notifier).enableAudio();
      }
      
      // 3. IMPORTANT: Refresh cameraState to get the NEW controller after enableAudio()
      final freshState = ref.read(cameraControllerProvider);
      
      // Safety check: Ensure we still have a valid controller
      if (freshState.controller == null || !freshState.isInitialized) {
        debugPrint('âŒ Recording aborted: New camera controller failed to initialize');
        throw CameraException('InitializationFailure', 'New controller failed to initialize');
      }

      // Initialize ghost synchronization
      _ghostRecordingCompleter = Completer<void>();
      
      // Safety Check: If the user released their finger while we were async-initializing,
      // then _isRecordingVideo will have been set to false by _handlePointerUp.
      if (!_isRecordingVideo) {
        debugPrint('â¹ï¸ Recording aborted: User released finger during hardware init');
        if (mounted) setState(() => _isProcessingCapture = false);
        _ghostRecordingCompleter?.complete();
        return;
      }

      // 4. Start Recording on the NEW controller
      await freshState.controller!.startVideoRecording();
      _recordingActualStartTime = DateTime.now(); // Track when it actually starts
      debugPrint('âœ… Video recording started at $_recordingActualStartTime');
      
      // FIX: Check if stop was requested while we were starting
      if (!_isRecordingVideo) {
        debugPrint('â¹ï¸ Stop requested during start sequence - stopping hardware immediately');
        await _ghostStopHardware();
      }
    } catch (e) {
      debugPrint('âŒ Error starting video recording: $e');
      if (mounted) {
        setState(() {
          _isRecordingVideo = false;
          _isProcessingCapture = false;
        });
        _recordingProgressController.reset();
        _pulseController.stop();
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to start recording: ${e.toString().split(":").last}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  /// The "Ghost Thread": Finishes hardware recording in the background
  /// while the UI is already responsive and interactive.
  Future<void> _ghostStopHardware() async {
    if (_isStoppingVideo) return;
    _isStoppingVideo = true;
    
    debugPrint('ðŸ‘» Ghost Mode: Finalizing hardware recording...');
    
    final cameraState = ref.read(cameraControllerProvider);
    final controller = cameraState.controller;

    try {
      if (controller == null || !controller.value.isRecordingVideo) {
         debugPrint('ðŸ‘» Ghost Mode: Hardware not recording, skipping stop.');
         if (mounted) {
           setState(() {
             _isProcessingCapture = false;
             _isRecordingVideo = false;
           });
         }
         if (_ghostRecordingCompleter != null && !_ghostRecordingCompleter!.isCompleted) {
            _ghostRecordingCompleter?.complete();
         }
         return;
      }

      // 1. HARDWARE SAFETY BUFFER (Competitive baseline: 800ms)
      // MP4 headers on many Android/iOS hardware require a minimum bitstream
      if (_recordingActualStartTime != null) {
        final elapsed = DateTime.now().difference(_recordingActualStartTime!);
        if (elapsed < const Duration(milliseconds: 800)) {
          final pad = const Duration(milliseconds: 800) - elapsed;
          debugPrint('ðŸ‘» Ghost Padding hardware for ${pad.inMilliseconds}ms...');
          await Future.delayed(pad);
        }
      }

      // 2. STOP HARDWARE
      final XFile videoFile = await controller.stopVideoRecording();
      final videoPath = videoFile.path;
      final file = File(videoPath);
      
      // 3. VALIDATION
      if (!file.existsSync() || file.lengthSync() < 1000) {
         // Discard silently if it's garbage
         debugPrint('ðŸ‘» Ghost Discard: File too small or missing (${file.lengthSync()} bytes)');
         if (mounted) {
           ScaffoldMessenger.of(context).showSnackBar(
             const SnackBar(content: Text('Hold longer to record video')),
           );
         }
         throw Exception('Ghost clip too short');
      }

      debugPrint('âœ… Ghost Success: $videoPath (${file.lengthSync()} bytes)');

      if (mounted) {
        setState(() {
          _isProcessingCapture = false;
          _capturedVideo = file;
          _capturedImage = null;
          _wasFrontCamera = cameraState.isFrontCamera;
        });

        // Kill green dot sensor
        await controller.pausePreview();
        _notifyCaptureState();

        // 4. INITIALIZE PREVIEW (Generation check handles concurrency)
        _initGeneration++;
        await _initializeVideoPreview(videoPath, _initGeneration);
      }
    } catch (e) {
      debugPrint('âŒ Ghost Hardware Error: $e');
      if (mounted) {
        setState(() {
          _isProcessingCapture = false;
          _capturedVideo = null;
        });
      }
    } finally {
      _isStoppingVideo = false;
      if (_ghostRecordingCompleter != null && !_ghostRecordingCompleter!.isCompleted) {
        _ghostRecordingCompleter!.complete();
      }
    }
  }

  bool _isStoppingVideo = false;
  int _initGeneration = 0; // FIX: Prevent stale preview initializations

  Future<void> _stopVideoRecording() async {
    // Legacy wrapper for Ghost Mode
    if (_isRecordingVideo) {
      setState(() => _isRecordingVideo = false);
      _recordingProgressController.stop();
      _pulseController.stop();
    }
    
    await _ghostStopHardware();
  }
  
  /// Initialize video preview player for looping playback
  Future<void> _initializeVideoPreview(String path, int generation) async {
  // 1. Dispose existing if any
  await _videoPreviewController?.dispose();
  
  // 2. Create LOCALLY first
  final newController = VideoPlayerController.file(File(path));
  
  try {
    // 3. Initialize the LOCAL variable with timeout to prevent infinite hang
    await newController.initialize().timeout(
      const Duration(seconds: 10),
      onTimeout: () {
        throw Exception('Video initialization timed out');
      },
    );
    
    // 4. Critical Safety Check:
    // If widget was disposed or controller changed while we waited, abort.
    // ALSO check if generation matches to prevent stale init
    if (!mounted || _initGeneration != generation) {
      newController.dispose(); // Clean up the orphan
      return;
    }
    
    // FIX #2: Check if user tapped Retake while we were initializing
    // If _capturedVideo is now null, user discarded the video - abort
    if (_capturedVideo == null) {
      newController.dispose(); // Clean up the orphan
      debugPrint('Video preview aborted: user discarded video during init');
      return;
    }

    await newController.setLooping(true);
    await newController.setVolume(1.0); // Ensure sound is on
    
    // 5. Only now assign to state and play
    setState(() {
      _videoPreviewController = newController;
      _isVideoPreviewReady = true;
    });
    
    // 6. Final safety play - some Android devices need a frame delay
    // to initialize the surface before playback begins
    await Future.delayed(const Duration(milliseconds: 100));
    if (mounted && _videoPreviewController == newController) {
      await newController.play();
    }
    
  } catch (e) {
    debugPrint('Error initializing video preview: $e');
    // Important: Dispose the local controller on error to prevent leaks
    newController.dispose();
    
    // FIX: Prevent infinite "Preparing video..." spinner
    // Set _isVideoPreviewReady = true to exit loading state
    // The UI will show a fallback (video badge + tap to retry message)
    if (mounted && _capturedVideo != null) {
      setState(() {
        _videoPreviewController = null; // Ensure no broken controller
        _isVideoPreviewReady = true; // Exit loading state to show fallback
      });
      
      // Show error snackbar so user knows something went wrong
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Video preview failed. You can still send it.'),
          backgroundColor: Colors.orange,
          duration: const Duration(seconds: 3),
        ),
      );
    }
  }
}
  
  /// Dispose video preview player
  void _disposeVideoPreview() {
    _videoPreviewController?.dispose();
    _videoPreviewController = null;
    _isVideoPreviewReady = false;
  }

  void _clearAllOverlays() {
    _drawingStrokes.clear();
    _currentStrokeNotifier.value = [];
    _stickersNotifier.value = [];
    _textOverlaysNotifier.value = [];
    _selectedStickerIndex = null;
    _selectedTextIndex = null;
    _currentEditMode = EditMode.none;
  }

  void _discardCapture() {
    HapticFeedback.lightImpact();
    _disposeVideoPreview(); // Clean up video player
    
    // FIX: Stop any active audio playback when discarding
    ref.read(audioServiceProvider).stop();
    
    setState(() {
      _capturedImage = null;
      _capturedVideo = null;
      _recordedAudioFile = null; // Clear recorded audio
      _audioDuration = 0;
      _isRecordingAudio = false;
      _clearAllOverlays();
    });
    _notifyCaptureState(); // Show history indicator (back to idle)
    // Wake up the camera sensor for retake
    _resumeCamera();
  }

  /// TAP-TO-FOCUS: Standard camera feature
  /// Calculates normalized offset (0.0-1.0) and sets focus/exposure point
  void _handleTapToFocus(Offset localPosition, CameraState cameraState) {
    final controller = cameraState.controller;
    if (controller == null || !controller.value.isInitialized) return;
    
    // Get the render box to calculate relative position
    final RenderBox? renderBox = _captureKey.currentContext?.findRenderObject() as RenderBox?;
    if (renderBox == null) return;
    
    final size = renderBox.size;
    
    // Calculate normalized offset (0.0 to 1.0)
    final double x = (localPosition.dx / size.width).clamp(0.0, 1.0);
    final double y = (localPosition.dy / size.height).clamp(0.0, 1.0);
    final offset = Offset(x, y);
    
    // Visual feedback
    HapticFeedback.lightImpact();
    setState(() {
      _focusPoint = localPosition;
      _showFocusReticle = true;
    });
    
    _focusTimer?.cancel();
    _focusTimer = Timer(const Duration(seconds: 2), () {
      if (mounted) setState(() => _showFocusReticle = false);
    });
    
    // Set focus and exposure point
    try {
      controller.setFocusPoint(offset);
      controller.setExposurePoint(offset);
      debugPrint('Tap-to-focus: Set focus at ($x, $y)');
    } catch (e) {
      debugPrint('Tap-to-focus failed: $e');
    }
  }

  Widget _buildFocusReticle() {
    return Positioned(
      left: _focusPoint!.dx - 40,
      top: _focusPoint!.dy - 40,
      child: Container(
        width: 80,
        height: 80,
        child: CustomPaint(
          painter: FocusBracketPainter(color: AppColors.telemetry),
        ),
      ),
    );
  }

  Widget _buildHUDOverlay() {
    final cameraState = ref.watch(cameraControllerProvider);
    if (cameraState.zoomLevel <= 1.05 && !_isRecordingVideo) return const SizedBox.shrink();
    
    return Positioned(
      bottom: 20,
      left: 0, right: 0,
      child: Center(
        child: AnimatedOpacity(
          duration: const Duration(milliseconds: 200),
          opacity: (cameraState.zoomLevel > 1.05 || _isRecordingVideo) ? 1.0 : 0.0,
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
            decoration: BoxDecoration(
              color: Colors.black45,
              borderRadius: BorderRadius.circular(20),
              border: Border.all(color: Colors.white24),
            ),
            child: Text(
              '${cameraState.zoomLevel.toStringAsFixed(1)}x',
              style: const TextStyle(
                color: Colors.white,
                fontSize: 12,
                fontWeight: FontWeight.w900,
                letterSpacing: 1,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildHUDItem(String label, String value, {String? unit}) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: GoogleFonts.spaceMono(
            color: AppColors.telemetry.withOpacity(0.7),
            fontSize: 8,
            fontWeight: FontWeight.bold,
            letterSpacing: 1,
          ),
        ),
        Row(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.baseline,
          textBaseline: TextBaseline.alphabetic,
          children: [
            Text(
              value,
              style: GoogleFonts.spaceMono(
                color: AppColors.textPrimary,
                fontSize: 14,
                fontWeight: FontWeight.bold,
              ),
            ),
            if (unit != null)
              Padding(
                padding: const EdgeInsets.only(left: 2),
                child: Text(
                  unit,
                  style: GoogleFonts.spaceMono(
                    color: AppColors.telemetry.withOpacity(0.5),
                    fontSize: 8,
                  ),
                ),
              ),
          ],
        ),
      ],
    );
  }

  // ============ EDIT MODE METHODS ============

  void _setEditMode(EditMode mode) {
    HapticFeedback.selectionClick();
    
    // If clicking the same mode, toggle off
    if (_currentEditMode == mode) {
      setState(() {
        _currentEditMode = EditMode.none;
        _selectedStickerIndex = null;
        _selectedTextIndex = null;
        _isEditingText = false;
        _textFocusNode.unfocus();
      });
      return;
    }
    
    setState(() {
      _currentEditMode = mode;
      _selectedStickerIndex = null;
      _selectedTextIndex = null;
      
      // Update audio mode flag
      if (mode == EditMode.audio) {
        _isAudioOnlyMode = true;
      } else if (mode != EditMode.none) {
        // If switching to any visual mode, we are no longer in audio-only
        _isAudioOnlyMode = false;
        
        // JIT CAMERA INIT: If we were in audio mode and now need camera
        final cameraState = ref.read(cameraControllerProvider);
        if (!cameraState.isInitialized && cameraState.error == null) {
          _initializeCamera();
        }
      }
    });
    
    // NoteIt-style: Auto-action based on mode
    switch (mode) {
      case EditMode.text:
        // Immediately add text and open keyboard
        _addTextImmediate();
        break;
      case EditMode.sticker:
        // Show sticker picker in bottom sheet
        _showStickerBottomSheet();
        break;
      case EditMode.draw:
        // Draw mode just activates, user can start drawing
        break;
      case EditMode.audio:
        // Audio mode just activates, user holds mic to record
        break;
      case EditMode.none:
        break;
    }
  }

  // ============ DRAWING METHODS ============

  void _onPanStart(DragStartDetails details) {
    if (_currentEditMode == EditMode.draw) {
      final RenderBox? renderBox = _captureKey.currentContext?.findRenderObject() as RenderBox?;
      if (renderBox == null) return;
      
      final size = renderBox.size;
      final normalizedPoint = Offset(
        details.localPosition.dx / size.width,
        details.localPosition.dy / size.height,
      );

      setState(() {
        // Just prepare logic, but actual points are handled by notifier
        _currentStrokeNotifier.value = [normalizedPoint];
      });
    }
  }

  void _onPanUpdate(DragUpdateDetails details) {
    if (_currentEditMode == EditMode.draw) {
      final RenderBox? renderBox = _captureKey.currentContext?.findRenderObject() as RenderBox?;
      if (renderBox == null) return;
      
      final size = renderBox.size;
      final normalizedPoint = Offset(
        details.localPosition.dx / size.width,
        details.localPosition.dy / size.height,
      );

      // PERFORMANCE: Update notifier directly without setState
      final newPoints = List<Offset>.from(_currentStrokeNotifier.value)..add(normalizedPoint);
      _currentStrokeNotifier.value = newPoints;
    }
  }

  void _onPanEnd(DragEndDetails details) {
    if (_currentEditMode == EditMode.draw && _currentStrokeNotifier.value.isNotEmpty) {
      setState(() {
        _drawingStrokes.add(DrawingStroke(
          points: List.from(_currentStrokeNotifier.value),
          color: _currentDrawColor,
          strokeWidth: _currentStrokeWidth,
        ));
        _currentStrokeNotifier.value = [];
      });
    }
  }

  void _undoLastStroke() {
    if (_drawingStrokes.isNotEmpty) {
      HapticFeedback.lightImpact();
      setState(() {
        _drawingStrokes.removeLast();
      });
    }
  }

  // ============ STICKER METHODS ============

  void _addSticker(String emoji) {
    HapticFeedback.lightImpact();
    // Normalize: Center of the portal
    final newSticker = StickerOverlay(
      emoji: emoji,
      position: const Offset(0.5, 0.4), 
    );
    
    // Update Notifier
    final currentStickers = List<StickerOverlay>.from(_stickersNotifier.value);
    currentStickers.add(newSticker);
    _stickersNotifier.value = currentStickers;
    
    setState(() {
      _selectedStickerIndex = _stickersNotifier.value.length - 1;
    });
  }

  void _deleteSelectedSticker() {
    if (_selectedStickerIndex != null) {
      HapticFeedback.mediumImpact();
      final currentStickers = List<StickerOverlay>.from(_stickersNotifier.value);
      currentStickers.removeAt(_selectedStickerIndex!);
      _stickersNotifier.value = currentStickers;
      
      setState(() {
        _selectedStickerIndex = null;
      });
    }
  }

  // ============ TEXT METHODS ============

  /// NoteIt-style: Immediately add text and open keyboard
  void _addTextImmediate() {
    HapticFeedback.lightImpact();
    // Normalize: Center-ish position (0.1, 0.3)
    final newText = TextOverlay(
      text: '',
      position: const Offset(0.1, 0.3), 
      color: _currentDrawColor,
      fontSize: _currentTextSize,
      fontStyle: _currentFontStyle,
    );
    
    final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
    currentTexts.add(newText);
    _textOverlaysNotifier.value = currentTexts;
    
    setState(() {
      _selectedTextIndex = _textOverlaysNotifier.value.length - 1;
      _isEditingText = true;
      _textController.text = '';
    });
    
    // Small delay to ensure widget is built before focusing
    Future.delayed(const Duration(milliseconds: 100), () {
      _textFocusNode.requestFocus();
    });
  }

  void _addText() {
    _addTextImmediate();
  }

  void _finishTextEditing() {
    if (_selectedTextIndex != null && _textController.text.isNotEmpty) {
      // Logic for updating specific text item in notifier list
      final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
      currentTexts[_selectedTextIndex!].text = _textController.text;
      _textOverlaysNotifier.value = currentTexts; // Notify listeners
      
      setState(() {
        _isEditingText = false;
        _currentEditMode = EditMode.none;
      });
    } else if (_selectedTextIndex != null && _textController.text.isEmpty) {
      // Remove empty text overlay
      final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
      currentTexts.removeAt(_selectedTextIndex!);
      _textOverlaysNotifier.value = currentTexts;

      setState(() {
        _selectedTextIndex = null;
        _isEditingText = false;
        _currentEditMode = EditMode.none;
      });
    }
    _textFocusNode.unfocus();
  }

  void _deleteSelectedText() {
    if (_selectedTextIndex != null) {
      HapticFeedback.mediumImpact();
      final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
      currentTexts.removeAt(_selectedTextIndex!);
      _textOverlaysNotifier.value = currentTexts;
      
      setState(() {
        _selectedTextIndex = null;
        _isEditingText = false;
      });
    }
  }
  
  /// Update font style for selected text
  void _setFontStyle(TextFontStyle style) {
    if (_selectedTextIndex != null) {
      HapticFeedback.selectionClick();
      setState(() {
        _currentFontStyle = style;
        final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
        currentTexts[_selectedTextIndex!].fontStyle = style;
        _textOverlaysNotifier.value = currentTexts;
      });
    }
  }
  
  /// Update text size for selected text
  void _setTextSize(double size) {
    if (_selectedTextIndex != null) {
      setState(() {
        _currentTextSize = size;
        final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
        currentTexts[_selectedTextIndex!].fontSize = size;
        _textOverlaysNotifier.value = currentTexts;
      });
    }
  }
  
  // ============ STICKER BOTTOM SHEET ============
  
  void _showStickerBottomSheet() {
    showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.4,
        minChildSize: 0.3,
        maxChildSize: 0.6,
        expand: false,
        builder: (context, scrollController) => Column(
          children: [
            // Handle
            Container(
              margin: const EdgeInsets.symmetric(vertical: 12),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: AppColors.textTertiary,
                borderRadius: BorderRadius.circular(2),
              ),
            ),
            
            // Header
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Row(
                children: [
                  Text('Stickers', style: AppTypography.headlineSmall),
                  const Spacer(),
                  IconButton(
                    onPressed: () => Navigator.pop(context),
                    icon: const Icon(Icons.close, color: AppColors.textSecondary),
                  ),
                ],
              ),
            ),
            
            // Sticker grid
            Expanded(
              child: GridView.builder(
                controller: scrollController,
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 6,
                  mainAxisSpacing: 12,
                  crossAxisSpacing: 12,
                ),
                itemCount: _stickerEmojis.length,
                itemBuilder: (context, index) {
                  final emoji = _stickerEmojis[index];
                  return GestureDetector(
                    onTap: () {
                      Navigator.pop(context);
                      _addSticker(emoji);
                    },
                    child: Container(
                      decoration: BoxDecoration(
                        color: AppColors.surfaceLight,
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Center(
                        child: Text(emoji, style: const TextStyle(fontSize: 28)),
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  // ============ EXPORT & SEND ============

  Future<void> _sendVibe() async {
    HapticFeedback.mediumImpact();
    
    // 2025 Walkie-Talkie FIX: If we have a direct recipient (from Widget or Reply)
    // bypass the friend picker and send immediately.
    if (widget.recipientId != null) {
      if (_isAudioOnlyMode) {
        _performAudioOnlyDirectSend(widget.recipientId!);
      } else {
        _performDirectSend(widget.recipientId!);
      }
      return;
    }
    
    // Show friend picker immediately - no navigation to preview screen
    _showFriendPicker();
  }


  /// Show gallery picker directly (unified Photo + Video)
  void _showGalleryPicker() {
    HapticFeedback.selectionClick();
    _showAssetPickerSheet(RequestType.common);
  }

  /// Show the actual asset picker sheet
  void _showAssetPickerSheet(RequestType type) {
    // Update the provider to fetch requested type
    ref.read(galleryRequestTypeProvider.notifier).state = type;
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => DraggableScrollableSheet(
        initialChildSize: 0.7,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        expand: false,
        builder: (_, scrollController) => Consumer(
          builder: (ctx, ref, _) {
            final assetsAsync = ref.watch(galleryAssetsProvider);
            
            return Column(
              children: [
                const SizedBox(height: 12),
                Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.white24,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                const SizedBox(height: 16),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        'Recent ${type == RequestType.common ? 'Media' : type == RequestType.image ? 'Photos' : 'Videos'}',
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      IconButton(
                        onPressed: () => Navigator.pop(ctx),
                        icon: const Icon(Icons.close, color: Colors.white70),
                      ),
                    ],
                  ),
                ),
                const Divider(color: Colors.white10),
                Expanded(
                  child: assetsAsync.when(
                    data: (assets) {
                      if (assets.isEmpty) {
                        return const Center(
                          child: Text('No assets found', style: TextStyle(color: Colors.white54)),
                        );
                      }
                      
                      return GridView.builder(
                        controller: scrollController,
                        padding: const EdgeInsets.all(8),
                        gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 3,
                          crossAxisSpacing: 8,
                          mainAxisSpacing: 8,
                        ),
                        itemCount: assets.length,
                        itemBuilder: (ctx, index) {
                          final asset = assets[index];
                          return GestureDetector(
                            onTap: () {
                              Navigator.pop(ctx);
                              _handleAssetSelection(asset);
                            },
                            child: Stack(
                              fit: StackFit.expand,
                              children: [
                                AssetEntityImage(
                                  asset,
                                  isOriginal: false,
                                  thumbnailSize: const ThumbnailSize.square(200),
                                  fit: BoxFit.cover,
                                  errorBuilder: (_, __, ___) => Container(
                                    color: Colors.grey[900],
                                    child: const Icon(Icons.broken_image, color: Colors.white24),
                                  ),
                                ),
                                if (asset.type == AssetType.video)
                                  Positioned(
                                    bottom: 4,
                                    right: 4,
                                    child: Container(
                                      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                                      decoration: BoxDecoration(
                                        color: Colors.black54,
                                        borderRadius: BorderRadius.circular(4),
                                      ),
                                      child: Text(
                                        _formatAssetDuration(asset.videoDuration),
                                        style: const TextStyle(color: Colors.white, fontSize: 10),
                                      ),
                                    ),
                                  ),
                              ],
                            ),
                          );
                        },
                      );
                    },
                    loading: () => const Center(
                      child: CircularProgressIndicator(color: AppColors.primaryAction),
                    ),
                    error: (err, _) => Center(
                      child: Text('Error: $err', style: const TextStyle(color: Colors.red)),
                    ),
                  ),
                ),
              ],
            );
          },
        ),
      ),
    );
  }

  String _formatAssetDuration(Duration duration) {
    final mins = duration.inMinutes;
    final secs = duration.inSeconds % 60;
    return '$mins:${secs.toString().padLeft(2, '0')}';
  }

  /// Handle selection of an asset from gallery
  Future<void> _handleAssetSelection(AssetEntity asset) async {
    // Check duration limits
    if (asset.type == AssetType.video && asset.videoDuration.inSeconds > 15) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Video must be 15s or less')),
      );
      return;
    }
    if (asset.type == AssetType.audio) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please record audio vibes in real-time')),
      );
      return;
    }

    final file = await asset.file;
    if (file == null) return;

    setState(() {
      _isFromGallery = true;
      if (asset.type == AssetType.image) {
        _capturedImage = file;
        _capturedVideo = null;
        _recordedAudioFile = null;
        _isAudioOnlyMode = false;
      } else if (asset.type == AssetType.video) {
        _capturedVideo = file;
        _capturedImage = null;
        _recordedAudioFile = null;
        _isAudioOnlyMode = false;
        _initializeVideoPreview(file.path, ++_initGeneration);
      }
      _clearAllOverlays();
    });
    
    _notifyCaptureState(); // Update global state
  }


  /// Show friend picker bottom sheet directly
  void _showFriendPicker() {
    showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => Consumer(
        builder: (ctx, ref, _) {
          final friendsAsync = ref.watch(friendsProvider);
          
          return Container(
            padding: const EdgeInsets.all(24),
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(ctx).size.height * 0.6,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Send to...',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                
                Expanded(
                  child: friendsAsync.when(
                    data: (friends) {
                      if (friends.isEmpty) {
                        return Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              const Icon(Icons.people_outline, color: Colors.grey, size: 48),
                              const SizedBox(height: 16),
                              const Text(
                                'No friends yet',
                                style: TextStyle(color: Colors.white),
                              ),
                              const SizedBox(height: 8),
                              TextButton(
                                onPressed: () {
                                  Navigator.pop(ctx);
                                  context.push('/add-friends');
                                },
                                child: const Text('Add Friends'),
                              ),
                            ],
                          ),
                        );
                      }
                      
                      return ListView.separated(
                        itemCount: friends.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 12),
                        itemBuilder: (context, index) {
                          final friend = friends[index];
                          return ListTile(
                            contentPadding: EdgeInsets.zero,
                            leading: CircleAvatar(
                              radius: 24,
                              backgroundImage: friend.avatarUrl != null
                                  ? NetworkImage(friend.avatarUrl!)
                                  : null,
                              backgroundColor: Colors.grey[800],
                              child: friend.avatarUrl == null
                                  ? Text(friend.displayName[0].toUpperCase())
                                  : null,
                            ),
                            title: Text(
                              friend.displayName,
                              style: const TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            trailing: Container(
                              padding: const EdgeInsets.all(8),
                              decoration: const BoxDecoration(
                                color: Color(0xFF00F0FF),
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(Icons.send, color: Colors.black, size: 20),
                            ),
                            onTap: () {
                              // FIX: Call the correct send method based on mode
                              if (_isAudioOnlyMode) {
                                _performAudioOnlyDirectSend(friend.id);
                              } else {
                                _performDirectSend(friend.id);
                              }
                            },
                          );
                        },
                      );
                    },
                    loading: () => const Center(
                      child: CircularProgressIndicator(color: Color(0xFF00F0FF)),
                    ),
                    error: (_, __) => const Center(
                      child: Text('Error loading friends', style: TextStyle(color: Colors.red)),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  /// Perform direct send without going through preview screen
  Future<void> _performDirectSend(String receiverId) async {
    // 1. Close picker details first
    if (mounted && Navigator.canPop(context)) {
      Navigator.pop(context); 
    }
    
    // 2. Safety check: Ensure widget is still active before finding Scaffold
    if (!mounted) return;

    // Show initial feedback
  ScaffoldMessenger.of(context).showSnackBar(
    const SnackBar(
      content: Text('Processing vibe...'),
      duration: Duration(seconds: 2),
    ),
  );
  
  try {
    // 0. GHOST SYNC: If we are in Walkie-Talkie mode and the ghost is still recording,
    // wait for it to finish hardware capture before we can start uploading.
    if (_ghostRecordingCompleter != null) {
      debugPrint('â³ Direct Send waiting for Ghost Recording to finish...');
      await _ghostRecordingCompleter!.future;
    }

    // 1. Capture Metadata
      int duration = 5;
      if (_videoPreviewController != null && _isVideoPreviewReady) {
        duration = _videoPreviewController!.value.duration.inSeconds;
        if (duration <= 0) duration = _audioDuration > 0 ? _audioDuration : 5;
      } else if (_recordedAudioFile != null && _audioDuration > 0) {
        duration = _audioDuration;
      }
      
      final waveform = ref.read(waveformDataProvider);
      
      // 2. Prepare Files (CRITICAL: Must happen before navigation while context is valid)
      File? audioFile = _recordedAudioFile;
      File? imageFile;
      File? videoFile;
      bool isVideo = false;
      
      if (_capturedVideo != null) {
        isVideo = true;
        videoFile = _capturedVideo;
        
        // IMPORTANT: For video, we need to create the overlay PNG first 
        // while the RepaintBoundary is still in the tree!
        // This is fast (<100ms). The slow FFmpeg part happens in the background.
        final videoSize = Size(
          _videoPreviewController?.value.size.width ?? 1080,
          _videoPreviewController?.value.size.height ?? 1920,
        );
        final targetSize = VideoProcessingService.calculateTargetResolution(videoSize);
        final overlayImage = await _createOverlayImage(targetSize, isFrontCamera: _wasFrontCamera);
        
        if (overlayImage == null) {
           debugPrint('Warning: Video overlay creation failed');
           // We might want to block or continue. The original code blocked.
           // But since we want "Optimistic", maybe we just continue with raw?
           // No, Privacy says: do not send raw video.
        }

        // Trigger background upload with processing!
        debugPrint('ðŸ“¤ [CameraScreen] Triggering background upload (video)');
        await ref.read(vibeUploadProvider.notifier).addUpload(
          receiverId: receiverId,
          audioPath: audioFile?.path,
          audioDuration: duration,
          waveformData: waveform,
          imagePath: null, // Will be extracted from video after processing
          videoPath: videoFile?.path, // Raw video
          overlayPath: overlayImage?.path,
          isVideo: true,
          isAudioOnly: _isAudioOnlyMode,
          isFromGallery: _isFromGallery,
          replyToVibeId: widget.replyTo?.id,
        );
      } else if (_capturedImage != null) {
        // PHOTO: Composite immediately (RepaintBoundary capture is fast)
        imageFile = await _compositeImageWithOverlays();
        if (imageFile == null) imageFile = _capturedImage;
        
        debugPrint('ðŸ“¤ [CameraScreen] Triggering background upload (photo)');
        await ref.read(vibeUploadProvider.notifier).addUpload(
          receiverId: receiverId,
          audioPath: audioFile?.path,
          audioDuration: duration,
          waveformData: waveform,
          imagePath: imageFile?.path,
          videoPath: null,
          isVideo: false,
          isAudioOnly: _isAudioOnlyMode,
          isFromGallery: _isFromGallery,
          replyToVibeId: widget.replyTo?.id,
        );
      }

      // 3. OPTIMISTIC NAVIGATION
      if (mounted) {
        _discardCapture();
        _isFromGallery = false; // Reset for next capture
        context.go('/');
        _askForNotificationsContextually();
      }
    } catch (e) {
      debugPrint('Error initiating send: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }

  /// Ask for notification permission contextually after user sends first vibe
  /// This is the "magic moment" - user just sent a message and wants to know when reply comes
  /// Much higher opt-in rate than asking during app launch or onboarding
  Future<void> _askForNotificationsContextually() async {
    // Only ask if we haven't already granted
    final status = await Permission.notification.status;
    if (status.isDenied) {
      // Small delay so user sees "Vibe sent!" first
      await Future.delayed(const Duration(milliseconds: 1500));
      await Permission.notification.request();
    }
  }

  bool get _hasOverlays => _drawingStrokes.isNotEmpty || _stickersNotifier.value.isNotEmpty || _textOverlaysNotifier.value.isNotEmpty;

  /// Extract first frame from video as thumbnail
  /// Now delegated to VideoProcessingService
  Future<File?> _extractVideoThumbnail(String videoPath) async {
    return VideoProcessingService.extractVideoThumbnail(videoPath);
  }

  /// Get safe pixel ratio to prevent OOM crashes on high-end devices
  /// 
  /// CRITICAL OOM FIX: Lowered from 4096px to 2048px.
  /// 4096x4096px = 64MB (Exceeds 30MB iOS Widget limit).
  /// 2048x2048px = 16MB (Safe for iOS Widgets).
  double _getSafePixelRatio(BuildContext context) {
    final size = MediaQuery.of(context).size;
    const double maxTextureDimension = 2048.0;
    
    final double maxRatioWidth = maxTextureDimension / size.width;
    final double maxRatioHeight = maxTextureDimension / size.height;
    
    // Use device ratio but strictly capped at GPU/Memory limits
    final double nativeRatio = MediaQuery.of(context).devicePixelRatio;
    return math.min(nativeRatio, math.min(maxRatioWidth, maxRatioHeight));
  }

  /// 2026 FIX: Isolate-based image export to prevent UI thread freeze.
  /// Captures raw bytes on UI thread (fast), then offloads PNG encoding
  /// to a background Isolate matching the VideoProcessingService pattern.
   Future<File?> _compositeImageWithOverlays() async {
    debugPrint('ðŸ” [CameraScreen] Starting aura/image composition...');
    try {
      // Hide selections for clean capture
      setState(() {
        _selectedStickerIndex = null;
        _selectedTextIndex = null;
      });
      
      await Future.delayed(const Duration(milliseconds: 50));
      
      final boundary = _captureKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) {
        debugPrint('âŒ [CameraScreen] Composition failed: RenderRepaintBoundary is null');
        return null;
      }
      
      // FIX: Use safe pixel ratio to prevent OOM on high-end devices
      final double safeRatio = _getSafePixelRatio(context);
      debugPrint('ðŸ” [CameraScreen] Capturing image with ratio: $safeRatio');
      final image = await boundary.toImage(pixelRatio: safeRatio);
      
      // CRITICAL 2026 FIX: Extract raw RGBA bytes (fast GPU readback)
      // This avoids the expensive PNG compression on the UI thread
      final byteData = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
      final int width = image.width;
      final int height = image.height;
      debugPrint('ðŸ” [CameraScreen] Raw RGBA extracted: ${width}x${height}');
      
      // Explicitly dispose of the GPU handle immediately
      image.dispose();
      
      if (byteData == null) {
        debugPrint('âŒ [CameraScreen] Composition failed: ByteData is null');
        return null;
      }
      
      // HEAVY LIFTING: Offload PNG encoding to Background Isolate
      // This prevents the 300-800ms "Jank" during save
      debugPrint('ðŸ” [CameraScreen] Offloading PNG encoding to Isolate...');
      final pngBytes = await VideoProcessingService.encodeImageInIsolate(
        byteData.buffer.asUint8List(),
        width,
        height,
      );
      
      final tempDir = await getTemporaryDirectory();
      final fileName = 'vibe_edited_${DateTime.now().millisecondsSinceEpoch}.png';
      final file = File('${tempDir.path}/$fileName');
      await file.writeAsBytes(pngBytes);
      debugPrint('ðŸ” [CameraScreen] Composition complete: ${file.path}');
      
      return file;
    } catch (e) {
      debugPrint('âŒ [CameraScreen] Error compositing image: $e');
      return null;
    }
  }

  /// Create a transparent overlay image for video compositing
  /// Now delegated to VideoProcessingService
  Future<File?> _createOverlayImage(Size videoSize, {bool isFrontCamera = false}) async {
    // Hide selections for clean capture
    setState(() {
      _selectedStickerIndex = null;
      _selectedTextIndex = null;
    });
    
    await Future.delayed(const Duration(milliseconds: 50));
    
    // Get the render box to understand the layout
    final boundary = _captureKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
    if (boundary == null) return null;
    
    final renderSize = boundary.size;
    
    // Create overlay content from current state
    final content = OverlayContent(
      strokes: _drawingStrokes,
      stickers: _stickersNotifier.value,
      textOverlays: _textOverlaysNotifier.value,
    );
    
    return VideoProcessingService.createOverlayImage(
      videoSize: videoSize,
      renderSize: renderSize,
      content: content,
      isFrontCamera: isFrontCamera,  // Pass through for selfie mirror alignment
    );
  }

  /// Composite video with overlay using FFmpeg
  /// Burns drawings, stickers, and text onto the video
  Future<File?> _compositeVideoWithOverlays() async {
    if (_capturedVideo == null) return null;
    
    try {
      // Show processing indicator
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Row(
              children: [
                SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    color: Colors.white,
                  ),
                ),
                SizedBox(width: 12),
                Text('Processing video with overlays...'),
              ],
            ),
            duration: Duration(seconds: 30),
          ),
        );
      }
      
      // Get video dimensions
      Size videoSize = const Size(1080, 1920); // Default 9:16 portrait
      if (_videoPreviewController != null && _isVideoPreviewReady) {
        final videoValue = _videoPreviewController!.value;
        if (videoValue.size.width > 0 && videoValue.size.height > 0) {
          videoSize = videoValue.size;
        }
      }
      
      // Calculate smart target resolution (downscale 4K to 1080p, no upscaling)
      final targetSize = VideoProcessingService.calculateTargetResolution(videoSize);
      
      debugPrint('Video: ${videoSize.width}x${videoSize.height} â†’ ${targetSize.width}x${targetSize.height}');
      
      // Get camera state to check for front camera (for selfie mirroring)
      // MUST be fetched BEFORE creating overlay so we can flip the overlay canvas
      final cameraState = ref.read(cameraControllerProvider);
      final isFrontCamera = cameraState.isFrontCamera;
      
      // Create overlay at target resolution
      // SELFIE FIX: Pass isFrontCamera so stickers/drawings are flipped to align with hflipped video
      final overlayImage = await _createOverlayImage(targetSize, isFrontCamera: isFrontCamera);
      if (overlayImage == null) {
        debugPrint('Failed to create overlay image');
        _hideProcessingIndicator();
        return null;
      }
      
      // Composite using VideoProcessingService
      // PORTAL PARADOX FIX: Pass isFrontCamera for selfie mirroring (hflip)
      final result = await VideoProcessingService.compositeVideoWithOverlay(
        videoPath: _capturedVideo!.path,
        overlayImage: overlayImage,
        targetSize: targetSize,
        isFrontCamera: isFrontCamera,  // FIX: Pass for selfie mirroring
      );
      
      _hideProcessingIndicator();
      
      if (result == null && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Failed to add overlays to video. Sending original.'),
            backgroundColor: Colors.orange,
          ),
        );
      }
      
      return result;
    } catch (e) {
      debugPrint('Error compositing video with overlays: $e');
      _hideProcessingIndicator();
      return null;
    }
  }
  
  void _hideProcessingIndicator() {
    if (mounted) {
      ScaffoldMessenger.of(context).hideCurrentSnackBar();
    }
  }

  // ============ BUILD METHODS ============

  @override
  Widget build(BuildContext context) {
    super.build(context); // Required by AutomaticKeepAliveClientMixin
    final cameraState = ref.watch(cameraControllerProvider);
    final topPadding = MediaQuery.of(context).padding.top;

    // UI SYNC: Listen for auto-stop from service (e.g. 15s limit)
    ref.listen<RecordingState>(recordingStateProvider, (previous, next) {
      if (next == RecordingState.stopped && _isRecordingAudio) {
        debugPrint('ðŸ›‘ UI Sync: Service stopped recording (Auto-stop or manual)');
        final notifier = ref.read(recordingStateProvider.notifier);
        final path = notifier.currentPath;
        final duration = ref.read(recordingDurationProvider);
        
        if (path != null && mounted) {
           setState(() {
             _isRecordingAudio = false;
             _recordedAudioFile = File(path);
             _audioDuration = duration > 0 ? duration : 1;
             // _hasCaptured will now be true
           });
           
           // If in audio-only mode, we stay there but show the review controls
           // If in camera mode (holding mic button), we just show the review controls
           _notifyCaptureState();
        }
      }
    });
    
    // 2025 FIX: Flex-based layout (Column + Expanded)
    // No more manual pixel math or 0.68 multipliers.
    // The layout engine handles responsiveness for us.

    return Scaffold(
      resizeToAvoidBottomInset: false,
      backgroundColor: AppColors.background, // Fallback color
      body: Stack(
        children: [
          // 1. Background (Gradient) - Fills entire screen
          Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topLeft,
                end: Alignment.bottomRight,
                colors: _backgroundGradient,
              ),
            ),
          ),
          _buildBackgroundDecorations(),
          
          // 2. Main Flex Layout
          Column(
            children: [
              // A. Top Bar (Title + Buttons)
              // We use a fixed height container that respects safe area
              Container(
                height: topPadding + kToolbarHeight + 12, // Sufficient space for top controls
                width: double.infinity,
                padding: EdgeInsets.only(top: topPadding),
                child: Stack(
                  children: [
                    // We pass 0 because the padding is handled by the Container
                    _buildAppTitle(0), 
                    _buildTopLeftButton(0),
                    _buildTopRightButton(0),
                  ],
                ),
              ),
              
              // B. Camera Frame - "PORTAL VIEW" (Widget-First Framing)
              // Uses fixed 1:1 aspect ratio with rounded corners to match widget
              // This ensures WYSIWYG: What You See Is What You Get
              Expanded(
                child: Container(
                  // Removed black surround - let gradient background show through
                  child: LayoutBuilder(
                    builder: (context, constraints) {
                      // NoteIt-style camera: FULL WIDTH, 1:1 aspect ratio (square)
                      // Width = full screen width with small margin for rounded corners
                      // Height = Width Ã— 3/4 (so width > height, like NoteIt)
                      
                      // NEW (Full Screen Width)
final portalWidth = constraints.maxWidth;
                      
                      // 1:1 aspect ratio (TESTING)
                      // Square - height equals width, but limited by available height to prevent overlap
                      final portalHeight = math.min(portalWidth, constraints.maxHeight);
                      
                      // Note: Audio mode now uses the same portal style as camera
                      // for visual consistency (removed the full-screen bypass)
                      
                      // Position CENTERED (not top-aligned)
                      return Align(
                        alignment: Alignment.center,
                        child: Container(
                            width: portalWidth,
                            height: portalHeight,
                            decoration: BoxDecoration(
                              color: AppColors.surface, // FIXED: Use Surface color for contrast against background
                              borderRadius: BorderRadius.circular(24), // Locket-style corners
                              boxShadow: [
                                BoxShadow(
                                  color: Colors.black.withOpacity(0.5),
                                  blurRadius: 30,
                                  spreadRadius: 5,
                                ),
                              ],
                            ),
                            child: ClipRRect(
                              borderRadius: BorderRadius.circular(24),
                              child: RepaintBoundary(
                                key: _captureKey,
                                child: Stack(
                                  fit: StackFit.expand,
                                  children: [
                                    // 1. Camera/Content Layer
                                    _buildCameraOrCapturedContent(cameraState),
                                    
                                    // 2. Edit Layers (Drawing Overlays)
                                    // PERFORMANCE: Use ValueListenableBuilder to rebuild only the drawing layer
                                    if (_drawingStrokes.isNotEmpty || _currentEditMode == EditMode.draw)
                                      Positioned.fill(
                                        child: RepaintBoundary(
                                          child: ValueListenableBuilder<List<Offset>>(
                                            valueListenable: _currentStrokeNotifier,
                                            builder: (context, currentPoints, child) {
                                              return CustomPaint(
                                                painter: DrawingPainter(
                                                  strokes: _drawingStrokes,
                                                  currentStroke: currentPoints,
                                                  currentColor: _currentDrawColor,
                                                  currentStrokeWidth: _currentStrokeWidth,
                                                ),
                                              );
                                            },
                                          ),
                                        ),
                                      ),
                                        
                                    // 3. Interaction Layer (Taps, Focus, Drawing)
                                    // ðŸ§­ PERMISSION FIX: Disable interaction layer if camera is not initialized 
                                    // and we have no content. This ensures the "Allow Access" button is clickable.
                                    if (_hasCaptured || (cameraState.error == null && cameraState.isInitialized))
                                      Positioned.fill(
                                        child: GestureDetector(
                                          // 2026 FIX: Dynamic HitTestBehavior based on mode
                                          // OPAQUE when drawing (capture all touches for strokes)
                                          // TRANSLUCENT otherwise (allow touches to reach stickers/text above)
                                          behavior: _currentEditMode == EditMode.draw 
                                              ? HitTestBehavior.opaque 
                                              : HitTestBehavior.translucent,
                                          
                                          // UNIFIED GESTURE HANDLING (Best Practice)
                                          // Pan is just specific Scale (1.0). Consolidate logic here.
                                          
                                          onScaleStart: (details) {
                                             if (_currentEditMode == EditMode.draw) {
                                                // DRAWING: Start stroke (Pan logic)
                                                // Manually map Scale details to Pan logic
                                                _onPanStart(DragStartDetails(
                                                  globalPosition: details.focalPoint,
                                                  localPosition: details.localFocalPoint,
                                                ));
                                             } else if (!_hasCaptured && _currentEditMode == EditMode.none) {
                                                // INTERACTION: Start Zoom (Scale logic)
                                                _initialScaleZoom = cameraState.zoomLevel;
                                             }
                                          },
                                          
                                          onScaleUpdate: (details) {
                                             if (_currentEditMode == EditMode.draw) {
                                                // DRAWING: Update stroke (Pan logic)
                                                _onPanUpdate(DragUpdateDetails(
                                                  globalPosition: details.focalPoint,
                                                  localPosition: details.localFocalPoint,
                                                  delta: details.focalPointDelta, 
                                                ));
                                             } else if (!_hasCaptured && _currentEditMode == EditMode.none && details.pointerCount > 1) {
                                                // INTERACTION: Update Zoom (Scale logic)
                                                // Only zoom if 2 pointers (pinch) to check intent
                                                final cameraNotifier = ref.read(cameraControllerProvider.notifier);
                                                final maxZoom = cameraState.isFrontCamera ? 3.0 : cameraState.maxZoom;
                                                final newZoom = (_initialScaleZoom * details.scale).clamp(cameraState.minZoom, maxZoom);
                                                cameraNotifier.setZoomLevel(newZoom);
                                             }
                                          },
                                          
                                          onScaleEnd: (details) {
                                             if (_currentEditMode == EditMode.draw) {
                                                // DRAWING: End stroke
                                                _onPanEnd(DragEndDetails(velocity: details.velocity));
                                             }
                                             // INTERACTION: No specific end logic needed for zoom usually
                                          },
                                          
                                          // TAP HANDLING (Remains separate as it's distinct from continuous gestures)
                                          onTapUp: (details) {
                                             if (_currentEditMode != EditMode.draw) {
                                               // Deselect stickers/text
                                               setState(() {
                                                 _selectedStickerIndex = null;
                                                 _selectedTextIndex = null;
                                               });
                                             }
                                             
                                             // TAP-TO-FOCUS
                                             if (!_hasCaptured && _currentEditMode == EditMode.none) {
                                               _handleTapToFocus(details.localPosition, cameraState);
                                             }
                                          },
                                        ),
                                      ),

                                    // 4. Sticker Layer (RepaintBoundary)
                                    // 2026 FIX: IgnorePointer when in Draw Mode to allow drawing OVER stickers
                                    Positioned.fill(
                                      child: IgnorePointer(
                                        ignoring: _currentEditMode == EditMode.draw,
                                        child: RepaintBoundary(
                                          child: ValueListenableBuilder<List<StickerOverlay>>(
                                            valueListenable: _stickersNotifier,
                                            builder: (context, stickers, _) {
                                              if (stickers.isEmpty) return const SizedBox.shrink();
                                              return Stack(
                                                children: _buildStickerWidgetsFromList(stickers, portalWidth, portalHeight),
                                              );
                                            },
                                          ),
                                        ),
                                      ),
                                    ),

                                    // 5. Text Layer (RepaintBoundary)
                                    // 2026 FIX: IgnorePointer when in Draw Mode to allow drawing OVER text
                                    Positioned.fill(
                                      child: IgnorePointer(
                                        ignoring: _currentEditMode == EditMode.draw,
                                        child: RepaintBoundary(
                                          child: ValueListenableBuilder<List<TextOverlay>>(
                                            valueListenable: _textOverlaysNotifier,
                                            builder: (context, textOverlays, _) {
                                              if (textOverlays.isEmpty) return const SizedBox.shrink();
                                              return Stack(
                                                children: _buildTextWidgetsFromList(textOverlays, portalWidth, portalHeight),
                                              );
                                            },
                                          ),
                                        ),
                                      ),
                                    ),

                                    // 6. HUD Layer
                                    if (!_hasCaptured && !_isAudioOnlyMode)
                                      _buildHUDOverlay(),


                                    // 7. Feedback Layers (Focus Reticle, Recording Progress)
                                    if (_showFocusReticle && _focusPoint != null)
                                      _buildFocusReticle(),
                                    
                                    if (_isRecordingVideo) ...[
                                      _buildRecordingIndicator(),
                                      Positioned.fill(
                                        child: AnimatedBuilder(
                                          animation: _recordingProgressController,
                                          builder: (context, child) {
                                            return CustomPaint(
                                              painter: CornerProgressPainter(
                                                progress: _recordingProgressController.value,
                                                color: AppColors.error,
                                                strokeWidth: 6,
                                                cornerRadius: 24, // Match portal corners
                                              ),
                                            );
                                          },
                                        ),
                                      ),
                                    ],
                                  ],
                                ),
                              ),
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ),
              
              
              // C. Bottom Controls (Anchored to bottom)
              SafeArea(
                top: false,
                child: Container(
                  width: double.infinity,
                  // Extra bottom padding to make room for History indicator overlay
                  // DYNAMIC: Respect MediaQuery for different device screens
                  padding: EdgeInsets.only(
                    top: 8, 
                    // FIXED: Removed redundant MediaQuery bottom padding inside SafeArea
                    // Use a static value (90) to maintain gap from History indicator
                    bottom: 90,
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                       // 1. Toolbar (Colors/Sliders)
                       if (_hasCaptured && _currentEditMode != EditMode.none && !_isEditingText)
                          Padding(
                            padding: const EdgeInsets.only(bottom: 8),
                            child: _buildEditModeToolbar(),
                          ),
                          
                       // 2. Camera Controls (Flash/Flip) - before capture only
                       if (!_hasCaptured)
                         Visibility(
                           visible: !_isAudioOnlyMode,
                           maintainSize: true,
                           maintainAnimation: true,
                           maintainState: true,
                           child: Padding(
                             padding: const EdgeInsets.only(bottom: 16),
                             child: _buildCameraControls(),
                           ),
                         ),
                          
                       // 3. Edit Mode Buttons (Draw/Sticker) - after capture only
                       // HIDE when editing text to follow user request "keyboard should coverAll editing option"
                       if (_hasCaptured && !_isEditingText)
                          Padding(
                            padding: const EdgeInsets.only(bottom: 16),
                            child: _buildEditOptions(),
                          ),
                          
                       // 4. Main Action Buttons (Shutter / Retake&Send)
                       // HIDE when editing text to prevent layout shifts and focus user on typing
                       if (!_hasCaptured)
                         _buildMainBottomControls()
                       else if (!_isEditingText)
                         _buildCapturedBottomControls(),
                    ],
                  ),
                ),
              ),
            ],
          ),
          // Top Camera Controls REMOVED - now shown in bottom area before capture

          // 4. Text Input Overlay (Root Stack, z-index top)
          if (_isEditingText)
            _buildTextInputField(),
        ],
      ),
    );
  }

  Widget _buildBackgroundDecorations() {
    return Stack(
      children: [
        Positioned(
          top: -50,
          right: -50,
          child: Container(
            width: 200,
            height: 200,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: AppColors.glassBackground, // Was alpha 25
            ),
          ),
        ),
        Positioned(
          bottom: 100,
          left: -80,
          child: Container(
            width: 180,
            height: 180,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: AppColors.glassBackgroundDark, // Was alpha 20
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildAppTitle(double statusBarHeight) {
    // Hide title during recording or in Audio Mode or when captured or when editing text
    if (_isRecordingVideo || _isRecordingAudio || _isAudioOnlyMode || _hasCaptured || _isEditingText) {
      return const SizedBox.shrink();
    }
    
    return Positioned(
      top: statusBarHeight + 16,
      left: 0,
      right: 0,
      child: Center(
        child: Text(
          'vibe',
          style: AppTypography.displaySmall.copyWith(
            color: AppColors.textPrimary, // Ghost White
            fontWeight: FontWeight.w800,
            letterSpacing: 2,
            shadows: [
              Shadow(
                color: AppColors.primaryAction.withOpacity(0.5),
                blurRadius: 10,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildTopLeftButton(double statusBarHeight) {
    // Hide during recording or text editing for focus
    if (_isRecordingVideo || _isRecordingAudio || _isEditingText) {
      return const SizedBox.shrink();
    }
    
    // When drawing, show undo button
    if (_currentEditMode == EditMode.draw && _drawingStrokes.isNotEmpty) {
      return Positioned(
        top: statusBarHeight + 12,
        left: 16,
        child: GlassButton(
          icon: Icons.undo,
          onPressed: _undoLastStroke,
        ),
      );
    }
    
    // Default: Show profile/settings avatar
    return Positioned(
      top: statusBarHeight + 12,
      left: 16,
      child: GestureDetector(
        onTap: () {
          HapticFeedback.mediumImpact();
          if (widget.onOpenSettings != null) {
            widget.onOpenSettings!();
          }
        },
        child: Container(
          width: 44,
          height: 44,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: AppColors.glassBackground, // Was Colors.white.withAlpha(25)
            border: Border.all(color: AppColors.glassBorder, width: 1), // Was 51
          ),
          child: const Icon(Icons.person_rounded, color: Colors.white, size: 22),
        ),
      ),
    );
  }

  Widget _buildTopRightButton(double statusBarHeight) {
    // Hide during recording or text editing for focus
    if (_isRecordingVideo || _isRecordingAudio || _isEditingText) {
      return const SizedBox.shrink();
    }
    
    if (_selectedStickerIndex != null) {
      return Positioned(
        top: statusBarHeight + 12,
        right: 16,
        child: GlassButton(
          icon: Icons.delete,
          onPressed: _deleteSelectedSticker,
          color: AppColors.error,
        ),
      );
    }
    if (_selectedTextIndex != null) {
      return Positioned(
        top: statusBarHeight + 12,
        right: 16,
        child: GlassButton(
          icon: Icons.delete,
          onPressed: _deleteSelectedText,
          color: AppColors.error,
        ),
      );
    }
    if (_hasCaptured) {
      return Positioned(
        top: statusBarHeight + 12,
        right: 16,
        child: GlassButton(
          icon: Icons.close,
          onPressed: _discardCapture,
        ),
      );
    }
    return Positioned(
      top: statusBarHeight + 12,
      right: 16,
      child: GlassButton(
        icon: Icons.more_vert,
        onPressed: () {},
      ),
    );
  }

  Widget _buildPortalLoadingState(String message) {
    return Positioned.fill(
      child: RepaintBoundary(
        child: Container(
          color: AppColors.surface,
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                CircularProgressIndicator(color: AppColors.primaryAction, strokeWidth: 3),
                const SizedBox(height: 16),
                Text(
                  message,
                  style: AppTypography.bodySmall.copyWith(color: Colors.white54),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildCameraOrCapturedContent(CameraState cameraState) {
    if (_showCurtain) {
      return _buildPortalLoadingState('Starting camera...');
    }
    
    // PERMISSION PLACEHOLDER: Show if permission required
    // This allows users to enable camera access JIT from the portal
    // FIX: Only show if NOT in audio-only mode (Compliance with Guideline 5.1.1)
    if (!_isAudioOnlyMode && 
        (cameraState.error == 'Camera permission required' || 
         cameraState.error == 'Camera permission denied')) {
      return _buildPermissionPlaceholder();
    }
    
    // PORTAL CONTENT: Logic must return a Positioned.fill(...) widget 
    // to be used as a direct child of the portal Stack.
    
    // CASE 1: Captured Image (Review Mode)
    if (_capturedImage != null) {
      Widget imageWidget = Image.file(_capturedImage!, fit: BoxFit.cover);
      
      // SELFIE MIRROR FIX: Flip preview horizontally for front camera
      if (_wasFrontCamera) {
        imageWidget = Transform(
          alignment: Alignment.center,
          transform: Matrix4.rotationY(math.pi), 
          child: imageWidget,
        );
      }
      
      return Positioned.fill(
        child: RepaintBoundary(child: imageWidget),
      );
    }
    
    // CASE 2: Captured Video (Review Mode)
    if (_capturedVideo != null) {
      if (_isVideoPreviewReady && _videoPreviewController != null) {
        Widget videoWidget = FittedBox(
          fit: BoxFit.cover,
          child: SizedBox(
            width: _videoPreviewController!.value.size.width,
            height: _videoPreviewController!.value.size.height,
            child: VideoPlayer(_videoPreviewController!),
          ),
        );
        
        if (_wasFrontCamera) {
          videoWidget = Transform(
            alignment: Alignment.center,
            transform: Matrix4.rotationY(math.pi),
            child: videoWidget,
          );
        }
        
        return Positioned.fill(
          child: RepaintBoundary(
            child: GestureDetector(
              onTap: () {
                setState(() {
                  if (_videoPreviewController!.value.isPlaying) {
                    _videoPreviewController!.pause();
                  } else {
                    _videoPreviewController!.play();
                  }
                });
              },
              child: Stack(
                fit: StackFit.expand,
                children: [
                  videoWidget,
                  if (!_videoPreviewController!.value.isPlaying)
                    Center(
                      child: Container(
                        padding: const EdgeInsets.all(16),
                        decoration: const BoxDecoration(
                          color: Colors.black54,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(Icons.play_arrow, color: Colors.white, size: 48),
                      ),
                    ),
                  Positioned(
                    top: 12,
                    right: 12,
                    child: Container(
                      padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                      decoration: BoxDecoration(
                        color: AppColors.secondaryAction.withAlpha(204),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: const Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(Icons.videocam, color: Colors.white, size: 14),
                          SizedBox(width: 4),
                          Text(
                            'VIDEO',
                            style: TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      } else if (!_isVideoPreviewReady) {
        return Positioned.fill(
          child: RepaintBoundary(
            child: Container(
              color: AppColors.surface,
              child: Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const CircularProgressIndicator(color: AppColors.primaryAction),
                    const SizedBox(height: 16),
                    Text(
                      'Preparing video...',
                      style: AppTypography.bodySmall.copyWith(color: Colors.white54),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      } else {
        // Fallback for failed video preview init
        return Positioned.fill(
          child: RepaintBoundary(
            child: GestureDetector(
              onTap: () {
                if (_capturedVideo != null) {
                  setState(() => _isVideoPreviewReady = false);
                  _initializeVideoPreview(_capturedVideo!.path, ++_initGeneration);
                }
              },
              child: Container(
                color: AppColors.surface,
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Container(
                            padding: const EdgeInsets.all(16),
                            decoration: const BoxDecoration(color: Colors.white24, shape: BoxShape.circle),
                            child: const Icon(Icons.videocam, color: Colors.white, size: 48),
                          ),
                          const SizedBox(height: 16),
                          Text('Tap to retry preview', style: AppTypography.bodySmall.copyWith(color: Colors.white54)),
                        ],
                      ),
                    ),
                    Positioned(
                      top: 12, right: 12,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                        decoration: BoxDecoration(
                          color: AppColors.secondaryAction.withAlpha(204),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: const Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Icon(Icons.videocam, color: Colors.white, size: 14),
                            SizedBox(width: 4),
                            Text('VIDEO', style: TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)),
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      }
    }
    
    // CASE 3: Audio-Only (Hardware Agnostic)
    // This mode does NOT require camera initialization (Compliance Fix)
    if (_isAudioOnlyMode) {
      if (!_isMicPermissionGranted) {
        return _buildMicPermissionPlaceholder();
      }
      return Positioned.fill(
        child: RepaintBoundary(
          child: _buildAudioOnlyModeBackground(),
        ),
      );
    }


    // CASE 4: Live Camera Preview
    if (cameraState.isInitialized && cameraState.controller != null) {
      final size = cameraState.controller!.value.previewSize!;
      
      // Default: Live Camera Preview
      return Positioned.fill(
        child: RepaintBoundary(
          child: Stack(
            fit: StackFit.expand,
            children: [
              FittedBox(
                fit: BoxFit.cover,
                child: SizedBox(
                  width: size.height, // Swapped for portrait
                  height: size.width,
                  child: CameraPreview(cameraState.controller!),
                ),
              ),
                
              // Reply Context Overlay
              if (widget.replyTo != null)
                Positioned(
                  top: 24, right: 24,
                  child: Hero(
                    tag: 'vibe_avatar_${widget.replyTo!.id}',
                    child: Container(
                      width: 72, height: 72,
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(16),
                        border: Border.all(color: Colors.white.withOpacity(0.5), width: 2),
                        boxShadow: const [BoxShadow(color: Colors.black26, blurRadius: 10, spreadRadius: 2)],
                      ),
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(14),
                        child: CachedNetworkImage(
                          imageUrl: widget.replyTo!.imageUrl ?? widget.replyTo!.senderAvatar ?? '',
                          fit: BoxFit.cover,
                        ),
                      ),
                    ),
                  ),
                ),

              // Tap-to-Place Area for Text Mode
              if (_currentEditMode == EditMode.text)
                Positioned.fill(
                  child: GestureDetector(
                    behavior: HitTestBehavior.translucent,
                    onTapUp: (details) => _addTextAtPosition(details.localPosition),
                  ),
                ),
            ],
          ),
        ),
      );
    }
    
    // CASE 4: Errors (Permissions, initialization failure)
    // FIX: Only show if NOT in audio-only mode
    if (!_isAudioOnlyMode && cameraState.error != null) {
      return Positioned.fill(
        child: Container(
          color: AppColors.surface,
          padding: const EdgeInsets.all(32),
          child: Center(
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    padding: const EdgeInsets.all(20),
                    decoration: BoxDecoration(color: AppColors.error.withAlpha(40), shape: BoxShape.circle),
                    child: Icon(
                      cameraState.error!.contains('permission') ? Icons.camera_alt_outlined : Icons.error_outline,
                      color: AppColors.error,
                      size: 48,
                    ),
                  ),
                  const SizedBox(height: 24),
                  Text(
                    cameraState.error!.contains('permission') ? 'Camera Access Required' : 'Camera Error',
                    style: AppTypography.headlineSmall.copyWith(color: Colors.white, fontWeight: FontWeight.bold),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 12),
                  Text(
                    cameraState.error!.contains('permission')
                        ? 'Nock needs camera access to capture photos and videos. Please enable it in Settings.'
                        : cameraState.error!,
                    style: AppTypography.bodyMedium.copyWith(color: Colors.white70),
                    textAlign: TextAlign.center,
                  ),
                  const SizedBox(height: 32),
                  Wrap(
                    alignment: WrapAlignment.center,
                    spacing: 16, runSpacing: 12,
                    children: [
                      OutlinedButton.icon(
                        onPressed: () => ref.read(cameraControllerProvider.notifier).initializeCamera(),
                        icon: const Icon(Icons.refresh, size: 20),
                        label: const Text('Retry'),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: Colors.white,
                          side: const BorderSide(color: Colors.white38),
                          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                        ),
                      ),
                      ElevatedButton.icon(
                        onPressed: () async {
                          await openAppSettings();
                        },
                        icon: const Icon(Icons.settings, size: 20),
                        label: const Text('Open Settings'),
                        style: ElevatedButton.styleFrom(
                          backgroundColor: AppColors.primaryAction,
                          foregroundColor: Colors.black,
                          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }
    
    // Default loading
    return _buildPortalLoadingState('Starting camera...');
  }

  List<Widget> _buildStickerWidgetsFromList(List<StickerOverlay> stickers, double portalWidth, double portalHeight) {
    return stickers.asMap().entries.map((entry) {
      final index = entry.key;
      final sticker = entry.value;
      
      // Use local variables to track scale/rotation during a gesture
      double _startScale = 1.0;
      double _startRotation = 0.0;

      return Positioned(
        left: sticker.position.dx * portalWidth,
        top: sticker.position.dy * portalHeight,
        child: Semantics(
          label: 'Sticker: ${sticker.emoji}',
          selected: index == _selectedStickerIndex,
          child: RepaintBoundary(
            child: GestureDetector(
              onTap: () {
                HapticFeedback.selectionClick();
                setState(() => _selectedStickerIndex = index);
              },
              onScaleStart: (details) {
                _startScale = sticker.scale;
                _startRotation = sticker.rotation;
                setState(() => _selectedStickerIndex = index);
              },
              onScaleUpdate: (details) {
                // Simultaneous Pan, Scale, and Rotate
                sticker.position += Offset(
                  details.focalPointDelta.dx / portalWidth,
                  details.focalPointDelta.dy / portalHeight,
                );
                
                if (details.scale != 1.0) {
                  sticker.scale = (_startScale * details.scale).clamp(0.5, 4.0);
                }
                
                if (details.rotation != 0.0) {
                  sticker.rotation = _startRotation + details.rotation;
                }
                
                // PERFORMANCE: Update notifier to trigger repaint of THIS layer only
                _stickersNotifier.value = List.from(stickers);
              },
              child: Transform.translate(
                offset: const Offset(-24, -24), // Center the pivot point (emoji is ~48px)
                child: Transform.rotate(
                  angle: sticker.rotation,
                  child: Transform.scale(
                    scale: sticker.scale,
                    child: Container(
                      padding: const EdgeInsets.all(4),
                      decoration: index == _selectedStickerIndex && !_isEditingText
                          ? BoxDecoration(
                              border: Border.all(color: AppColors.primaryAction.withOpacity(0.5), width: 1),
                              borderRadius: BorderRadius.circular(8),
                            )
                          : null,
                      child: Text(
                        sticker.emoji, 
                        style: const TextStyle(fontSize: 48)
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      );
    }).toList();
  }

  List<Widget> _buildTextWidgetsFromList(List<TextOverlay> textOverlays, double portalWidth, double portalHeight) {
    return textOverlays.asMap().entries.map((entry) {
      final index = entry.key;
      final textItem = entry.value;
      final isSelected = index == _selectedTextIndex;
      
      // Don't show empty text (being edited) OR the currently selected text item
      // because it's being rendered by the _buildTextInputField layer.
      if ((textItem.text.isEmpty && !isSelected) || (isSelected && _isEditingText)) {
        return const SizedBox.shrink();
      }
      
      double _startScale = 1.0;
      double _startRotation = 0.0;

      return Positioned(
        left: textItem.position.dx * portalWidth,
        top: textItem.position.dy * portalHeight,
        child: Semantics(
          label: 'Text: ${textItem.text}',
          selected: isSelected,
          child: RepaintBoundary(
            child: GestureDetector(
              onTap: () {
                HapticFeedback.selectionClick();
                setState(() {
                  _selectedTextIndex = index;
                  _textController.text = textItem.text;
                  _currentFontStyle = textItem.fontStyle;
                  _currentTextSize = textItem.fontSize;
                  _currentDrawColor = textItem.color;
                  _isEditingText = true;
                  _currentEditMode = EditMode.text;
                  _textOverlaysNotifier.value = List.from(textOverlays);
                });
                _textFocusNode.requestFocus();
              },
              onScaleStart: (details) {
                _startScale = textItem.scale;
                _startRotation = textItem.rotation;
                setState(() {
                  _selectedTextIndex = index;
                  _textOverlaysNotifier.value = List.from(textOverlays);
                });
              },
              onScaleUpdate: (details) {
                textItem.position += Offset(
                  details.focalPointDelta.dx / portalWidth,
                  details.focalPointDelta.dy / portalHeight,
                );
                
                if (details.scale != 1.0) {
                  textItem.scale = (_startScale * details.scale).clamp(0.5, 5.0);
                }
                
                if (details.rotation != 0.0) {
                  textItem.rotation = _startRotation + details.rotation;
                }
                
                _textOverlaysNotifier.value = List.from(textOverlays);
              },
              child: Transform.rotate(
                angle: textItem.rotation,
                child: Transform.scale(
                  scale: textItem.scale,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    decoration: isSelected && !_isEditingText
                        ? BoxDecoration(
                            border: Border.all(color: AppColors.primaryAction.withOpacity(0.5), width: 1),
                            borderRadius: BorderRadius.circular(8),
                          )
                        : null,
                    child: Text(
                      textItem.text.isEmpty ? ' ' : textItem.text,
                      style: textItem.fontStyle.getStyle(textItem.fontSize, textItem.color).copyWith(
                        shadows: [
                          Shadow(
                            color: Colors.black54,
                            offset: const Offset(1, 1),
                            blurRadius: 4,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      );
    }).toList();
  }

  Widget _buildRecordingIndicator() {
    return Positioned(
      top: 16,
      left: 0,
      right: 0,
      child: Center(
        child: Container(
          width: 12, height: 12,
          decoration: const BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
          ),
        ),
      ),
    );
  }

  Widget _buildEditModeToolbar() {
    switch (_currentEditMode) {
      case EditMode.draw:
        return _buildDrawToolbar();
      case EditMode.sticker:
        return _buildStickerPicker();
      case EditMode.text:
        return _buildTextToolbar();
      default:
        return const SizedBox();
    }
  }

  Widget _buildDrawToolbar() {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Row(
        children: [
          // Stroke width
          ToolbarIconButton(
            icon: _currentStrokeWidth < 10 ? Icons.lens : Icons.circle,
            iconSize: _currentStrokeWidth.clamp(12, 24),
            onTap: () {
              setState(() {
                _currentStrokeWidth = _currentStrokeWidth >= 15 ? 3 : _currentStrokeWidth + 4;
              });
            },
          ),
          const SizedBox(width: 8),
          // Colors
          ..._drawColors.map((color) {
            final isSelected = color == _currentDrawColor;
            return GestureDetector(
              onTap: () => setState(() => _currentDrawColor = color),
              child: Container(
                width: 32, height: 32,
                margin: const EdgeInsets.symmetric(horizontal: 4),
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: isSelected ? AppColors.primaryAction : Colors.white38,
                    width: isSelected ? 3 : 1,
                  ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }

  Widget _buildStickerPicker() {
    // Bottom sheet already opens when sticker mode is selected in _setEditMode
    // No inline picker needed
    return const SizedBox.shrink();
  }

  Widget _buildTextToolbar() {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Row(
        children: [

          // Colors
          ..._drawColors.map((color) {
            final isSelected = color == _currentDrawColor;
            return GestureDetector(
              onTap: () {
                setState(() {
                  _currentDrawColor = color;
                  if (_selectedTextIndex != null) {
                    final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
                    currentTexts[_selectedTextIndex!].color = color;
                    _textOverlaysNotifier.value = currentTexts; // Notify
                  }
                });
              },
              child: Container(
                width: 32, height: 32,
                margin: const EdgeInsets.symmetric(horizontal: 4),
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: isSelected ? AppColors.primaryAction : Colors.white38,
                    width: isSelected ? 3 : 1,
                  ),
                ),
              ),
            );
          }),
        ],
      ),
    );
  }

  Widget _buildTextInputField() {
    final keyboardHeight = MediaQuery.of(context).viewInsets.bottom;
    final topPadding = MediaQuery.of(context).padding.top;
    
    return Material(
      color: Colors.transparent, // User requested: remove bg color
      child: GestureDetector(
        onTap: _finishTextEditing,
        behavior: HitTestBehavior.translucent, // Capture taps on empty space to dismiss
        child: Stack(
          fit: StackFit.expand,
          children: [
            // 1. Centered Inline Input (NoteIt-style)
            Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 32),
                child: IntrinsicWidth(
                  child: TextField(
                    controller: _textController,
                    focusNode: _textFocusNode,
                    autofocus: true,
                    style: _currentFontStyle.getStyle(_currentTextSize, _currentDrawColor),
                    textAlign: TextAlign.center,
                    maxLines: null,
                    decoration: const InputDecoration(
                      filled: false,
                      fillColor: Colors.transparent,
                      border: InputBorder.none,
                      enabledBorder: InputBorder.none,
                      focusedBorder: InputBorder.none,
                      errorBorder: InputBorder.none,
                      disabledBorder: InputBorder.none,
                      contentPadding: EdgeInsets.zero,
                      hintText: 'Type...',
                      hintStyle: TextStyle(color: Colors.white30),
                    ),
                    cursorColor: Colors.white,
                    onChanged: (value) {
                      if (_selectedTextIndex != null) {
                        // Update text in notifier without setState rebuild
                        final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
                        currentTexts[_selectedTextIndex!].text = value;
                        // Avoid notifying on every keystroke if it causes lag, 
                        // but usually it's fine with RepaintBoundary
                        _textOverlaysNotifier.value = currentTexts;
                      }
                    },
                  ),
                ),
              ),
            ),

            // 2. Styling Toolbar (docked to keyboard)
            Positioned(
              bottom: keyboardHeight,
              left: 0,
              right: 0,
              child: GestureDetector(
                onTap: () {}, // INTERCEPT: Prevent tap-to-dismiss when interacting with toolbar
                behavior: HitTestBehavior.opaque,
                child: Container(
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  decoration: BoxDecoration(
                    color: Colors.black.withOpacity(0.8),
                    borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                       // Size slider (mini version)
                       Padding(
                         padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
                         child: Row(
                           children: [
                             const Icon(Icons.text_format, color: Colors.white, size: 14),
                             Expanded(
                               child: Slider(
                                 value: _currentTextSize,
                                 min: 16, max: 64,
                                 onChanged: (v) => _setTextSize(v),
                                 activeColor: AppColors.primaryAction,
                               ),
                             ),
                             const Icon(Icons.text_format, color: Colors.white, size: 24),
                           ],
                         ),
                       ),
                       // Font styles
                       SizedBox(
                         height: 40,
                         child: ListView(
                           scrollDirection: Axis.horizontal,
                           padding: const EdgeInsets.symmetric(horizontal: 16),
                           children: TextFontStyle.values.map((style) => _buildFontStyleChip(style)).toList(),
                         ),
                       ),
                       const SizedBox(height: 12),
                       // Colors
                       SingleChildScrollView(
                         scrollDirection: Axis.horizontal,
                         padding: const EdgeInsets.symmetric(horizontal: 16),
                         child: Row(
                           children: _drawColors.map((color) {
                             final isSelected = color == _currentDrawColor;
                             return GestureDetector(
                               onTap: () {
                                 setState(() {
                                   _currentDrawColor = color;
                                   if (_selectedTextIndex != null) {
                    final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
                    currentTexts[_selectedTextIndex!].color = color;
                    _textOverlaysNotifier.value = currentTexts;
                                   }
                                 });
                               },
                               child: Container(
                                 width: 32, height: 32,
                                 margin: const EdgeInsets.symmetric(horizontal: 4),
                                 decoration: BoxDecoration(
                                   color: color,
                                   shape: BoxShape.circle,
                                   border: Border.all(
                                     color: isSelected ? AppColors.primaryAction : Colors.white38,
                                     width: isSelected ? 3 : 1,
                                   ),
                                 ),
                               ),
                             );
                           }).toList(),
                         ),
                       ),
                    ],
                  ),
                ),
              ),
            ),

            // 3. DONE Button (Top Right)
            Positioned(
              top: topPadding + 12,
              right: 16,
              child: TextButton(
                onPressed: _finishTextEditing,
                child: const Text('DONE', style: TextStyle(color: AppColors.primaryAction, fontWeight: FontWeight.bold, fontSize: 18)),
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildFontStyleChip(TextFontStyle style) {
    final isSelected = _currentFontStyle == style;
    
    return GestureDetector(
      onTap: () => _setFontStyle(style),
      child: Container(
        margin: const EdgeInsets.only(right: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: isSelected ? AppColors.primaryAction : AppColors.surfaceLight,
          borderRadius: BorderRadius.circular(20),
        ),
        child: Text(
          style.displayName,
          style: style.getStyle(
            14, 
            isSelected ? Colors.black : AppColors.textSecondary,
          ).copyWith(fontSize: 14),
        ),
      ),
    );
  }
  
  void _showTextColorPicker() {
    HapticFeedback.selectionClick();
    showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Text Color', style: AppTypography.headlineSmall),
            const SizedBox(height: 20),
            Wrap(
              spacing: 12,
              runSpacing: 12,
              children: _drawColors.map((color) {
                final isSelected = _currentDrawColor == color;
                return GestureDetector(
                  onTap: () {
                    setState(() {
                      _currentDrawColor = color;
                      if (_selectedTextIndex != null) {
                        final currentTexts = List<TextOverlay>.from(_textOverlaysNotifier.value);
                        currentTexts[_selectedTextIndex!].color = color;
                        _textOverlaysNotifier.value = currentTexts;
                      }
                    });
                    Navigator.pop(context);
                  },
                  child: Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      color: color,
                      shape: BoxShape.circle,
                      border: Border.all(
                        color: isSelected ? AppColors.primaryAction : Colors.white24,
                        width: isSelected ? 3 : 1,
                      ),
                    ),
                  ),
                );
              }).toList(),
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  Widget _buildCameraControls() {
  final cameraState = ref.watch(cameraControllerProvider);
  
  return Row(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      // FLASH: Only show for Back Camera (Hardware limitation on front)
      if (!cameraState.isFrontCamera) ...[
        MiniPillButton(
          icon: _getFlashIcon(cameraState.flashMode),
          label: 'Flash',
          onTap: () {
            HapticFeedback.selectionClick();
            ref.read(cameraControllerProvider.notifier).toggleFlash();
          },
        ),
        const SizedBox(width: 12),
      ],
      
      MiniPillButton(
        icon: Icons.flip_camera_ios,
        label: 'Flip',
        onTap: () async {
          HapticFeedback.selectionClick();
          // Show curtain immediately for smooth transition
          if (mounted) setState(() => _showCurtain = true);
          
          await ref.read(cameraControllerProvider.notifier).switchCamera();
          
          // Lift curtain with a small delay to ensure new frame is ready
          _curtainTimer?.cancel();
          _curtainTimer = Timer(const Duration(milliseconds: 300), () {
            if (mounted) setState(() => _showCurtain = false);
          });
        },
      ),
    ],
  );
}

IconData _getFlashIcon(FlashMode mode) {
  switch (mode) {
    case FlashMode.off:
      return Icons.flash_off;
    case FlashMode.auto:
      return Icons.flash_auto;
    case FlashMode.always:
      return Icons.flash_on;
    case FlashMode.torch:
      return Icons.highlight;
    default:
      return Icons.flash_off;
  }
}

  Widget _buildEditOptions() {
    // When audio is recorded (photo+audio OR audio-only), show audio controller bar
    if (_recordedAudioFile != null && (_capturedImage != null || _isAudioOnlyMode)) {
      return _buildAudioControllerBar();
    }
    
    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        EditModeButton(
          icon: Icons.brush,
          label: 'Draw',
          isActive: _currentEditMode == EditMode.draw,
          gradient: const LinearGradient(colors: [Color(0xFFFF6B6B), Color(0xFFFFE66D)]),
          onTap: () => _setEditMode(EditMode.draw),
        ),
        const SizedBox(width: 12),
        EditModeButton(
          icon: Icons.emoji_emotions_outlined,
          label: 'Sticker',
          isActive: _currentEditMode == EditMode.sticker,
          gradient: const LinearGradient(colors: [Color(0xFF4ECDC4), Color(0xFF44A08D)]),
          onTap: () => _setEditMode(EditMode.sticker),
        ),
        const SizedBox(width: 12),
        EditModeButton(
          icon: Icons.text_fields,
          label: 'Text',
          isActive: _currentEditMode == EditMode.text,
          gradient: const LinearGradient(colors: [Color(0xFF667EEA), Color(0xFF764BA2)]),
          onTap: () => _setEditMode(EditMode.text),
        ),
        // Audio button - only show for photos (videos already have audio)
        if (_capturedImage != null) ...[
          const SizedBox(width: 12),
          EditModeButton(
            icon: Icons.mic_none_rounded,
            label: 'Voice',
            isActive: _currentEditMode == EditMode.audio,
            gradient: const LinearGradient(colors: [Color(0xFF00F0FF), Color(0xFF0055FF)]),
            onTap: () => _setEditMode(EditMode.audio),
          ),
        ],
      ],
    );
  }
  
  /// Audio controller bar shown when audio is recorded (matches reference design)
  /// Shows: Delete | Play | Waveform | Duration (no send icon - already have send button below)
  Widget _buildAudioControllerBar() {
    final playbackState = ref.watch(playbackStateProvider);
    final isPlaying = playbackState == PlaybackState.playing;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: Colors.black.withOpacity(0.6),
        borderRadius: BorderRadius.circular(30),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Delete button
          GestureDetector(
            onTap: () {
              HapticFeedback.lightImpact();
              ref.read(audioServiceProvider).stop();
              setState(() {
                _recordedAudioFile = null;
                _audioDuration = 0;
              });
            },
            child: Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.white.withOpacity(0.1),
              ),
              child: const Icon(Icons.delete_outline, color: Colors.white, size: 22),
            ),
          ),
          
          const SizedBox(width: 12),
          
          // Play/Pause button (Real State)
          GestureDetector(
            onTap: () {
              HapticFeedback.selectionClick();
              final service = ref.read(audioServiceProvider);
              if (isPlaying) {
                service.pause();
              } else {
                if (_recordedAudioFile != null) {
                   service.playFromFile(_recordedAudioFile!.path);
                }
              }
            },
            child: Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: isPlaying ? AppColors.primaryAction : Colors.white.withOpacity(0.2),
              ),
              child: Icon(
                isPlaying ? Icons.pause : Icons.play_arrow,
                color: Colors.white,
                size: 24,
              ),
            ),
          ),
          
          const SizedBox(width: 16),
          
          // âš¡ ISOLATED REPAINT: Waveform updates here will NOT rebuild the Camera Screen
          const WaveformVisualizer(
            barCount: 10,
            height: 24,
          ),
          
          const SizedBox(width: 12),
          
          // Duration
          Text(
            '${(_audioDuration ~/ 60).toString().padLeft(1, '0')}:${(_audioDuration % 60).toString().padLeft(2, '0')}',
            style: const TextStyle(
              color: Colors.white,
              fontSize: 14,
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMainBottomControls() {
    // FIX #1 & #4: Audio-Only mode now has symmetric 3-button layout matching Camera mode
    // This keeps the user's thumb in the same "Action Zone" for consistency
    if (_isAudioOnlyMode) {
      // During audio recording, only show mic button (centered) for clean UI
      if (_isRecordingAudio) {
        return Center(
          child: _buildMicCaptureButton(),
        );
      }
      
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 40),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            // LEFT: Gallery (for uploading old audio)
            BottomNavButton(
              icon: Icons.photo_library_rounded,
              label: 'Gallery',
              onTap: () => _showGalleryPicker(),
            ),
            
            // CENTER: Mic Shutter Button (matches camera shutter position)
            _buildMicCaptureButton(),
            
            // RIGHT: Back to Camera
            BottomNavButton(
              icon: Icons.camera_alt_rounded,
              label: 'Camera',
              onTap: () {
                HapticFeedback.selectionClick();
                // Cancel any in-progress recording
                if (_isRecordingAudio) {
                  ref.read(recordingStateProvider.notifier).stopRecording();
                  setState(() => _isRecordingAudio = false);
                }
                setState(() => _isAudioOnlyMode = false);
                // Bring Green Dot back for Camera Mode (re-init if needed)
                _resumeCamera();
                _notifyCaptureState(); // Show history indicator
              },
            ),
          ],
        ),
      );
    }
    
    // Normal Photo/Video mode
    // During video recording, only show the shutter button (centered)
    if (_isRecordingVideo) {
      return Center(
        child: _buildCaptureButton(),
      );
    }
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 40),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: [
          // LEFT: Gallery / Vault
          BottomNavButton(
            icon: Icons.photo_library_rounded,
            label: 'Gallery',
            onTap: () => _showGalleryPicker(),
          ),
          
          // CENTER: Capture Button
          _buildCaptureButton(),
          
          // RIGHT: Audio Mode Toggle
          BottomNavButton(
            icon: Icons.mic,
            label: 'Audio',
            onTap: () {
              HapticFeedback.selectionClick();
              setState(() {
                _isAudioOnlyMode = !_isAudioOnlyMode;
              });
              
              if (_isAudioOnlyMode) {
                _checkMicPermission();
              }
              
              // Toggle camera sensor based on mode
              final controller = ref.read(cameraControllerProvider).controller;
              if (_isAudioOnlyMode) {
                controller?.pausePreview(); // Kill Green Dot in Audio Mode
              } else {
                _resumeCamera(); // Bring Green Dot back for Camera (re-init if needed)
              }
              
              _notifyCaptureState(); // Hide/show history indicator
            },
          ),
        ],
      ),
    );
  }
  
  /// Start audio-only recording with Tap-to-Start/Stop pattern
  void _startAudioOnlyRecording() async {
    HapticFeedback.heavyImpact();
    setState(() => _isRecordingAudio = true);
    _notifyCaptureState(); // Hide history indicator
    
    // FIX: Stop any active audio playback before starting new recording
    ref.read(audioServiceProvider).stop();
    
    final success = await ref.read(recordingStateProvider.notifier).startRecording();
    if (!success && mounted) {
      setState(() {
        _isRecordingAudio = false;
        _isMicPermissionGranted = false;
      });
      _notifyCaptureState(); // Restore history indicator
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Microphone permission required'),
          backgroundColor: Colors.orange,
        ),
      );
    }
  }
  
  /// Stop audio-only recording and show friend picker (consistent with Photo/Video)
  void _stopAudioOnlyRecording() async {
    HapticFeedback.mediumImpact();
    final path = await ref.read(recordingStateProvider.notifier).stopRecording();
    
    if (path != null && mounted) {
      final timerDuration = ref.read(recordingDurationProvider);
      final actualDuration = timerDuration > 0 ? timerDuration : 1;
      
      // NOTE: We NO LONGER clear duration/waveform here 
      // because AudioService now handles clearing at the START of next recording.
      // This allows us to use the data for sending!
      
      // Store the recorded audio file - UI will show audio controller bar
      // User can preview/delete audio before tapping send button
      setState(() {
        _recordedAudioFile = File(path);
        _audioDuration = actualDuration;
        _isRecordingAudio = false;
        // _hasCaptured getter now includes audio-only mode condition
      });
      
      // NOTE: Friend picker is now triggered by the send button (checkmark)
      // This matches the reference UI design with audio controller bar
    } else {
      setState(() => _isRecordingAudio = false);
    }
  }
  
  /// Show friend picker for Audio-Only mode (consistent with Photo/Video flow)
  void _showAudioOnlyFriendPicker() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF1A1A1A),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (ctx) => Consumer(
        builder: (ctx, ref, _) {
          final friendsAsync = ref.watch(friendsProvider);
          
          return Container(
            padding: const EdgeInsets.all(24),
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(ctx).size.height * 0.6,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    const Icon(Icons.mic, color: Color(0xFF00F0FF)),
                    const SizedBox(width: 8),
                    Text(
                      'Send Audio Vibe (${_audioDuration}s)',
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                
                Expanded(
                  child: friendsAsync.when(
                    data: (friends) {
                      if (friends.isEmpty) {
                        return Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              const Icon(Icons.people_outline, color: Colors.grey, size: 48),
                              const SizedBox(height: 16),
                              const Text(
                                'No friends yet',
                                style: TextStyle(color: Colors.white),
                              ),
                              const SizedBox(height: 8),
                              TextButton(
                                onPressed: () {
                                  Navigator.pop(ctx);
                                  context.push('/add-friends');
                                },
                                child: const Text('Add Friends'),
                              ),
                            ],
                          ),
                        );
                      }
                      
                      return ListView.separated(
                        itemCount: friends.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 12),
                        itemBuilder: (context, index) {
                          final friend = friends[index];
                          return ListTile(
                            contentPadding: EdgeInsets.zero,
                            leading: CircleAvatar(
                              radius: 24,
                              backgroundImage: friend.avatarUrl != null
                                  ? NetworkImage(friend.avatarUrl!)
                                  : null,
                              backgroundColor: Colors.grey[800],
                              child: friend.avatarUrl == null
                                  ? Text(friend.displayName[0].toUpperCase())
                                  : null,
                            ),
                            title: Text(
                              friend.displayName,
                              style: const TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            trailing: Container(
                              padding: const EdgeInsets.all(8),
                              decoration: const BoxDecoration(
                                color: Color(0xFF00F0FF),
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(Icons.send, color: Colors.black, size: 20),
                            ),
                            onTap: () => _performAudioOnlyDirectSend(friend.id),
                          );
                        },
                      );
                    },
                    loading: () => const Center(
                      child: CircularProgressIndicator(color: Color(0xFF00F0FF)),
                    ),
                    error: (_, __) => const Center(
                      child: Text('Error loading friends', style: TextStyle(color: Colors.red)),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
  
  /// Perform direct send for audio-only vibes (consistent with Photo/Video)
  Future<void> _performAudioOnlyDirectSend(String receiverId) async {
    // 1. Close picker first
    if (mounted && Navigator.canPop(context)) {
      Navigator.pop(context); 
    }
    
    // 2. Safety check: Ensure widget is still active before finding Scaffold
    if (!mounted) return;

    // Show initial feedback
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('Sending audio vibe...'),
        duration: Duration(seconds: 2),
      ),
    );
    
    try {
      // 1. Prepare Metadata
      final waveform = ref.read(waveformDataProvider);
      
      // 2. Prepare Files (MUST happen before navigation)
      final audioFile = _recordedAudioFile;
      final audioExists = await audioFile?.exists() ?? false;
      final audioSize = audioExists ? await audioFile!.length() : 0;
      debugPrint('ðŸ” [CameraScreen] Preparing audio-only content (audioPath=${audioFile?.path}, exists=$audioExists, size=$audioSize bytes)');
      
      if (audioExists && audioSize == 0) {
        debugPrint('âš ï¸ [CameraScreen] WARNING: Audio file is empty (0 bytes)!');
      }
      
      // For audio-only, we need to create a background image
      File? imageFile = await _compositeImageWithOverlays();
      debugPrint('ðŸ” [CameraScreen] Aura snapshot captured: exists=${imageFile != null}, path=${imageFile?.path}');
      
      // Trigger background upload
      debugPrint('ðŸ“¤ [CameraScreen] Triggering background upload (audio-only) to receiver $receiverId');
      await ref.read(vibeUploadProvider.notifier).addUpload(
        receiverId: receiverId,
        audioPath: _recordedAudioFile?.path,
        audioDuration: _audioDuration,
        waveformData: waveform,
        imagePath: imageFile?.path,
        videoPath: null,
        isVideo: false,
        isAudioOnly: true,
        isFromGallery: false,
      );
      
      // 3. CONTEXT-AWARE NAVIGATION (2026 UX Best Practice)
      // Walkie-Talkie Mode: Stay in mode for rapid exchanges
      // General Camera: Return to home (clean "task complete" state)
      if (mounted) {
        final isWalkieTalkieMode = widget.recipientId != null;
        
        if (isWalkieTalkieMode) {
          // WALKIE-TALKIE: Stay in audio-only mode for continuous conversation
          setState(() {
            _recordedAudioFile = null;
            _audioDuration = 0;
            // Keep _isAudioOnlyMode = true for next recording
          });
          
          // Success feedback without navigation
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Row(
                children: [
                  Icon(Icons.check_circle, color: Color(0xFF00F0FF), size: 20),
                  SizedBox(width: 12),
                  Text('Sent! Ready for next message', style: TextStyle(fontWeight: FontWeight.bold)),
                ],
              ),
              backgroundColor: Color(0xFF1E1E1E),
              behavior: SnackBarBehavior.floating,
              duration: Duration(seconds: 1),
            ),
          );
        } else {
          // GENERAL CAMERA: Clean exit to home feed
          setState(() {
            _recordedAudioFile = null;
            _audioDuration = 0;
            _isAudioOnlyMode = false; // Exit audio-only mode
          });
          context.go('/');
          _askForNotificationsContextually();
        }
      }
    } catch (e) {
      debugPrint('Error initiating audio send: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    }
  }
  
  /// Build beautiful background for Audio-Only mode in camera view
  /// Premium glassmorphic orb design with waveform visualization
  Widget _buildAudioOnlyModeBackground() {
    final userAsync = ref.watch(currentUserProvider);
    
    return Stack(
      fit: StackFit.expand,
      children: [
        // Layer 1: Profile image or gradient base
        userAsync.when(
          data: (user) {
            if (user?.avatarUrl != null && user!.avatarUrl!.isNotEmpty) {
              return Image.network(
                user.avatarUrl!,
                fit: BoxFit.cover,
                errorBuilder: (_, __, ___) => _buildAudioModeGradient(),
              );
            }
            return _buildAudioModeGradient();
          },
          loading: () => _buildAudioModeGradient(),
          error: (_, __) => _buildAudioModeGradient(),
        ),
        
        // Layer 2: Heavy blur effect
        BackdropFilter(
          filter: ui.ImageFilter.blur(sigmaX: 50, sigmaY: 50),
          child: Container(color: Colors.transparent),
        ),
        
        // Layer 3: Dark overlay for contrast
        Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black.withOpacity(0.2),
                Colors.black.withOpacity(0.4),
                Colors.black.withOpacity(0.6),
              ],
            ),
          ),
        ),
        
        // Layer 4: AuraVisualization for consistent look with preview
         Positioned.fill(
           child: Opacity(
             opacity: 0.4,
             child: RepaintBoundary(
               child: AuraVisualization(isPlaying: _isRecordingAudio),
             ),
           ),
         ),
        
        // Layer 5: Main content - Compact layout for portal
        Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // Title text
              Text(
                _isRecordingAudio ? 'Recording...' : 'Tap to record',
                style: TextStyle(
                  color: Colors.white.withOpacity(0.9),
                  fontSize: 18,
                  fontWeight: FontWeight.w600,
                ),
              ),
              
              const SizedBox(height: 24),
              
              // MAIN: Isolated Waveform & Duration Updates
              RepaintBoundary(
                child: Consumer(
                  builder: (context, ref, _) {
                    final recordingDuration = ref.watch(recordingDurationProvider);
                    return Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Glassmorphic Orb with waveform
                        GestureDetector(
                          onTap: () {
                            if (_isRecordingAudio) {
                              _stopAudioOnlyRecording();
                            } else {
                              _startAudioOnlyRecording();
                            }
                          },
                          child: _buildGlassmorphicOrb(recordingDuration),
                        ),
                        
                        const SizedBox(height: 16),
                        
                        // Duration display when recording
                        if (_isRecordingAudio)
                          Text(
                            '${recordingDuration}s',
                            style: TextStyle(
                              color: Colors.white.withOpacity(0.7),
                              fontSize: 24,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                      ],
                    );
                  },
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
  
  /// Build the premium glassmorphic orb with waveform
  Widget _buildGlassmorphicOrb(int duration) {
    // Smaller size for portal-constrained layout
    final size = _isRecordingAudio ? 140.0 : 120.0;
    
    return AnimatedContainer(
      duration: const Duration(milliseconds: 300),
      width: size,
      height: size,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: _isRecordingAudio
              ? [
                  const Color(0xFFFF6B9D).withOpacity(0.8),
                  const Color(0xFFFF0099).withOpacity(0.6),
                  const Color(0xFFAA00FF).withOpacity(0.4),
                ]
              : [
                  AppColors.primaryAction.withOpacity(0.7),
                  const Color(0xFF667EEA).withOpacity(0.5),
                  const Color(0xFF764BA2).withOpacity(0.4),
                ],
        ),
        boxShadow: [
          BoxShadow(
            color: (_isRecordingAudio ? const Color(0xFFFF0099) : AppColors.primaryAction)
                .withOpacity(0.4),
            blurRadius: _isRecordingAudio ? 60 : 40,
            spreadRadius: _isRecordingAudio ? 10 : 5,
          ),
          BoxShadow(
            color: Colors.white.withOpacity(0.1),
            blurRadius: 20,
            spreadRadius: -5,
            offset: const Offset(-5, -5),
          ),
        ],
        border: Border.all(
          color: Colors.white.withOpacity(0.3),
          width: 2,
        ),
      ),
      child: ClipOval(
        child: BackdropFilter(
          filter: ui.ImageFilter.blur(sigmaX: 10, sigmaY: 10),
          child: Container(
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              color: Colors.white.withOpacity(0.1),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // âš¡ ISOLATED REPAINT: Mini Waveform rendering moved to leaf widget
                if (_isRecordingAudio)
                  const WaveformVisualizer(
                    barCount: 15,
                    height: 40,
                  )
                else
                  Icon(
                    Icons.mic_rounded,
                    size: 56,
                    color: Colors.white.withOpacity(0.9),
                  ),
                
                const SizedBox(height: 8),
                
                // Timer when recording
                if (_isRecordingAudio)
                  Text(
                    _formatDuration(duration),
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      letterSpacing: 2,
                    ),
                  )
                else
                  Text(
                    'TAP',
                    style: TextStyle(
                      color: Colors.white.withOpacity(0.7),
                      fontSize: 14,
                      fontWeight: FontWeight.w600,
                      letterSpacing: 2,
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
  
  /// Format duration as MM:SS
  String _formatDuration(int seconds) {
    final mins = (seconds ~/ 60).toString().padLeft(2, '0');
    final secs = (seconds % 60).toString().padLeft(2, '0');
    return '$mins:$secs';
  }
  
  /// Build bottom action bar for audio mode
  Widget _buildAudioModeActionBar() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 60),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          // Retry / Re-record button
          GestureDetector(
            onTap: () {
              HapticFeedback.lightImpact();
              if (_isRecordingAudio) {
                // Cancel current recording
                ref.read(recordingStateProvider.notifier).stopRecording();
                setState(() => _isRecordingAudio = false);
              }
              // Clear any recorded audio
              setState(() => _recordedAudioFile = null);
            },
            child: Container(
              width: 52,
              height: 52,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.white.withOpacity(0.15),
                border: Border.all(color: Colors.white.withOpacity(0.2)),
              ),
              child: Icon(
                Icons.refresh_rounded,
                color: Colors.white.withOpacity(0.8),
                size: 24,
              ),
            ),
          ),
          
          const SizedBox(width: 40),
          
          // Delete button
          GestureDetector(
            onTap: () {
              HapticFeedback.mediumImpact();
              if (_isRecordingAudio) {
                ref.read(recordingStateProvider.notifier).stopRecording();
              }
              setState(() {
                _isRecordingAudio = false;
                _recordedAudioFile = null;
                _isAudioOnlyMode = false; // Exit audio mode
              });
            },
            child: Container(
              width: 52,
              height: 52,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: AppColors.error.withOpacity(0.2),
                border: Border.all(color: AppColors.error.withOpacity(0.3)),
              ),
              child: Icon(
                Icons.delete_outline_rounded,
                color: AppColors.error.withOpacity(0.9),
                size: 24,
              ),
            ),
          ),
        ],
      ),
    );
  }
  
  /// Gradient fallback for audio mode
  Widget _buildAudioModeGradient() {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF667EEA),
            Color(0xFF764BA2),
            Color(0xFFFF0099),
            Color(0xFF00F0FF),
          ],
        ),
      ),
    );
  }

  Widget _buildCapturedBottomControls() {
    // AUDIO MODE: Show Cancel + Mic recording UI
    if (_currentEditMode == EditMode.audio) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 32),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            // LEFT: Cancel / Exit audio mode
            CircleActionButton(
              icon: Icons.close,
              label: 'Cancel',
              onTap: () {
                _setEditMode(EditMode.none);
              },
            ),
            
            // CENTER: Large Mic Button (tap to start/stop recording)
            GestureDetector(
              onTap: () {
                // Tap-to-toggle recording
                if (_isRecordingAudio) {
                  _stopVoiceRecording();
                } else {
                  _startVoiceRecording();
                }
              },
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 200),
                width: _isRecordingAudio ? 88 : 80,
                height: _isRecordingAudio ? 88 : 80,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: _isRecordingAudio ? AppColors.error : Colors.grey.shade700,
                  border: Border.all(
                    color: _isRecordingAudio ? AppColors.error : Colors.grey.shade500,
                    width: 3,
                  ),
                  boxShadow: _isRecordingAudio ? [
                    BoxShadow(
                      color: AppColors.error.withAlpha(128),
                      blurRadius: 30,
                      spreadRadius: 4,
                    ),
                  ] : null,
                ),
                child: Icon(
                  _isRecordingAudio ? Icons.stop : Icons.mic,
                  color: Colors.white,
                  size: 32,
                ),
              ),
            ),
            
            // RIGHT: Show recorded indicator or empty space
            _recordedAudioFile != null && !_isRecordingAudio
                ? CircleActionButton(
                    icon: Icons.check_circle,
                    label: 'Done',
                    onTap: () => _setEditMode(EditMode.none),
                  )
                : const SizedBox(width: 52),
          ],
        ),
      );
    }
    
    // NORMAL MODE: Retake, Send, Save
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: [
          CircleActionButton(
            icon: Icons.refresh,
            label: 'Retake',
            onTap: _discardCapture,
          ),
          _buildSendButton(),
          CircleActionButton(
            icon: Icons.download_rounded,
            label: 'Save',
            onTap: () {},
          ),
        ],
      ),
    );
  }
  
  // ============ AUDIO RECORDING METHODS ============
  
  void _startVoiceRecording() async {
    HapticFeedback.heavyImpact();
    setState(() => _isRecordingAudio = true);
    
    // FIX: Stop any active audio playback before starting voice recording
    ref.read(audioServiceProvider).stop();
    
    final success = await ref.read(recordingStateProvider.notifier).startRecording();
    if (!success && mounted) {
      setState(() {
        _isRecordingAudio = false;
        _isMicPermissionGranted = false;
      });
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Microphone permission required'),
          backgroundColor: Colors.orange,
        ),
      );
    }
  }
  
  void _stopVoiceRecording() async {
    HapticFeedback.mediumImpact();
    final path = await ref.read(recordingStateProvider.notifier).stopRecording();
    
    if (path != null && mounted) {
      // Get recorded duration from timer
      // If timer shows 0 but we have a file, minimum is 1 second
      final timerDuration = ref.read(recordingDurationProvider);
      
      // Use timer duration, with minimum of 1 second if file exists
      // This prevents the fallback to 5 seconds which causes progress bar desync
      final actualDuration = timerDuration > 0 ? timerDuration : 1;
      
      setState(() {
        _recordedAudioFile = File(path);
        _audioDuration = actualDuration;
        _isRecordingAudio = false;
        _currentEditMode = EditMode.none; // Auto-exit audio mode
      });
      
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Row(
            children: [
              const Icon(Icons.mic, color: Colors.white, size: 18),
              const SizedBox(width: 8),
              Text('Voice note added ($_audioDuration s)'),
            ],
          ),
          backgroundColor: Colors.green.shade700,
          duration: const Duration(seconds: 2),
        ),
      );
    } else {
      setState(() => _isRecordingAudio = false);
    }
  }

  Widget _buildCaptureButton() {
    return Listener(
      onPointerDown: _handlePointerDown,
      onPointerUp: _handlePointerUp,
      onPointerMove: _handlePointerMove,
      onPointerCancel: _handlePointerCancel,
      child: AnimatedBuilder(
        animation: _shutterAnimation,
        builder: (context, child) {
          final shutterColor = _isRecordingVideo ? AppColors.urgency : AppColors.primaryAction;
          
          return Transform.scale(
            scale: _shutterAnimation.value,
            child: CustomPaint(
              painter: glass.CircularLuminousBorderPainter(
                strokeWidth: 4,
                baseColor: shutterColor,
              ),
              child: Container(
                width: 84, height: 84,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: shutterColor.withAlpha(128), 
                      blurRadius: 25, 
                      spreadRadius: 4
                    )
                  ],
                ),
                child: Center(
                  child: AnimatedContainer(
                    duration: const Duration(milliseconds: 200),
                    width: _isRecordingVideo ? 32 : 68,
                    height: _isRecordingVideo ? 32 : 68,
                    decoration: BoxDecoration(
                      color: shutterColor,
                      borderRadius: BorderRadius.circular(_isRecordingVideo ? 8 : 34),
                      boxShadow: [
                        BoxShadow(
                          color: shutterColor.withAlpha(150),
                          blurRadius: 15,
                          spreadRadius: 2,
                        ),
                      ],
                    ),
                    child: _isRecordingVideo ? null : Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Text('HOLD', style: TextStyle(color: Colors.black, fontSize: 9, fontWeight: FontWeight.w900, letterSpacing: 0.5)),
                          Text('TO REC', style: TextStyle(color: Colors.black, fontSize: 9, fontWeight: FontWeight.w900, letterSpacing: 0.5)),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  void _handlePointerDown(PointerDownEvent event) {
  if (_hasCaptured || _isProcessingCapture) return;
  
  // ðŸ§­ JIT PERMISSION FIX: If camera is not ready, trigger request instead of silent fail
  final cameraState = ref.read(cameraControllerProvider);
  if (!cameraState.isInitialized && !_isAudioOnlyMode) {
    if (cameraState.error == 'Camera permission required' || cameraState.error == 'Camera permission denied') {
      _requestCameraPermission();
      return;
    }
  }

  _pointerDownTime = DateTime.now();
  _dragStartY = event.position.dy;
  _baseZoom = ref.read(cameraControllerProvider).zoomLevel;
  _shutterController.forward(); // Scale down button on press
  
  // ðŸš€ PRE-WARM PROTOCOL (Competitive Moat)
  // Shave ~200ms off video start by initializing audio session on touch
  // We wait 150ms to ensure it's not a deliberate fast tap
  _preWarmTimer?.cancel();
  _preWarmTimer = Timer(const Duration(milliseconds: 150), () {
    if (mounted && _pointerDownTime != null) {
      debugPrint('ðŸ”¥ Pre-warming audio session...');
      ref.read(cameraControllerProvider.notifier).enableAudio();
    }
  });

  // Start video recording after 500ms hold
  _longPressTimer?.cancel();
  _longPressTimer = Timer(_tapThreshold, () {
    if (mounted && _pointerDownTime != null) {
      _startVideoRecording();
    }
  });
}

  void _handlePointerMove(PointerMoveEvent event) {
  if (!_isRecordingVideo || _pointerDownTime == null) return;

  // SNAPCHAT SLIDE ZOOM
  // Dragging UP (negative delta) increases zoom
  final double dragDelta = _dragStartY - event.position.dy;
  
  // Sensitivity: 200 pixels for full zoom range (approx)
  // We use the hardware limits from MediaService
  final cameraState = ref.read(cameraControllerProvider);
  final minZoom = cameraState.minZoom;
  
  // INDUSTRY STANDARD: Cap front camera zoom to prevent extreme pixelation
  // while still allowing "Dramatic Zoom" and 0.5x Ultra-wide hardware
  final maxZoom = cameraState.isFrontCamera ? 3.0 : cameraState.maxZoom;

  // Calculate new zoom level
  // 0.01 zoom per pixel of drag
  final double newZoom = (_baseZoom + (dragDelta / 150)).clamp(minZoom, maxZoom);
  
  if (newZoom != cameraState.zoomLevel) {
    ref.read(cameraControllerProvider.notifier).setZoomLevel(newZoom);
  }
}

void _handlePointerUp(PointerUpEvent event) {
  if (_pointerDownTime == null) return;
  
  final duration = DateTime.now().difference(_pointerDownTime!);
  _pointerDownTime = null;
  
  _longPressTimer?.cancel();
  _longPressTimer = null;
  _preWarmTimer?.cancel();
  _preWarmTimer = null;
  
  _shutterController.reverse(); // Scale button back up
  
  if (duration < _tapThreshold) {
    // Release before 500ms -> It's a TAP (Photo)
    debugPrint('ðŸ‘† Capture TAP -> Photo');
    _takePhoto();
  } else {
    // Release after 500ms -> It's a RELEASE (Stop Video)
    debugPrint('ðŸ–– Capture RELEASE -> STOP UI (Ghost Mode)');
    
    // GHOST START: Update UI immediately
    if (_isRecordingVideo) {
      setState(() {
        _isRecordingVideo = false;
        // Do NOT set _isProcessingCapture = false yet
      });
      _recordingProgressController.stop();
      _pulseController.stop();
      HapticFeedback.mediumImpact();
      
      // Hardware stop happens in background (Ghost)
      _ghostStopHardware();
    }
  }
}

  void _handlePointerCancel(PointerCancelEvent event) {
    debugPrint('âš ï¸ Capture CANCELLED (Finger dragged away)');
    _preWarmTimer?.cancel(); // Release pre-warm lock
    _handlePointerUp(PointerUpEvent(
      pointer: event.pointer,
      position: event.position,
    ));
  }
  
  /// Mic capture button for Audio-Only mode (matches camera shutter position/style)
  Widget _buildMicCaptureButton() {
    return GestureDetector(
      onTap: () {
        if (_isRecordingAudio) {
          _stopAudioOnlyRecording();
        } else {
          _startAudioOnlyRecording();
        }
      },
      child: AnimatedBuilder(
        animation: _shutterAnimation,
        builder: (context, child) {
          return Transform.scale(
            scale: _shutterAnimation.value,
            child: Container(
              width: 84, height: 84,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(
                  color: _isRecordingAudio ? AppColors.urgency : AppColors.telemetry,
                  width: 4,
                ),
                boxShadow: [
                  BoxShadow(
                    color: (_isRecordingAudio ? AppColors.urgency : AppColors.telemetry).withAlpha(128),
                    blurRadius: 25,
                    spreadRadius: 4,
                  ),
                ],
              ),
              child: Center(
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  width: _isRecordingAudio ? 32 : 68,
                  height: _isRecordingAudio ? 32 : 68,
                  decoration: BoxDecoration(
                    gradient: _isRecordingAudio 
                        ? null 
                        : LinearGradient(colors: [AppColors.telemetry, AppColors.telemetry.withOpacity(0.7)]),
                    color: _isRecordingAudio ? AppColors.urgency : null,
                    borderRadius: BorderRadius.circular(_isRecordingAudio ? 8 : 34),
                    boxShadow: [
                      BoxShadow(
                        color: (_isRecordingAudio ? AppColors.urgency : AppColors.telemetry).withAlpha(150),
                        blurRadius: 15,
                        spreadRadius: 2,
                      ),
                    ],
                  ),
                  child: Center(
                    child: Icon(
                      _isRecordingAudio ? Icons.stop : Icons.mic,
                      color: Colors.black,
                      size: _isRecordingAudio ? 20 : 32,
                    ),
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildSendButton() {
    return GestureDetector(
      onTap: _sendVibe,
      child: Container(
        width: 72, height: 72,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: AppColors.primaryAction,
          boxShadow: [
            BoxShadow(
              color: AppColors.primaryAction.withAlpha(150), 
              blurRadius: 20, 
              spreadRadius: 4
            )
          ],
        ),
        child: Icon(Icons.send_rounded, color: Colors.black, size: 28),
      ),
    );
  }

  /// Placeholder UI shown in the portal when camera permission is missing
  Widget _buildPermissionPlaceholder() {
    return Container(
      color: AppColors.surface,
      width: double.infinity,
      height: double.infinity,
      alignment: Alignment.center,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.videocam_off, color: Colors.white.withOpacity(0.5), size: 48),
          const SizedBox(height: 16),
          Text(
            'Enable Camera to Vibe',
            style: GoogleFonts.inter(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'We need access to capture moments.',
            style: GoogleFonts.inter(
              color: Colors.white.withOpacity(0.6),
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 24),
          GestureDetector(
            onTap: _requestCameraPermission,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(30),
              ),
              child: Text(
                'Allow Access',
                style: GoogleFonts.inter(
                  color: Colors.black,
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// New Helper: Centralized camera permission request logic
  Future<void> _requestCameraPermission() async {
    debugPrint('ðŸ”˜ Requesting Camera Permission...');
    
    var status = await Permission.camera.status;
    debugPrint('   Current status before request: $status');

    if (status.isPermanentlyDenied) {
      debugPrint('   -> Status is PERMANENTLY DENIED. Opening settings...');
      await openAppSettings();
      return;
    }

    // On Android, isDenied can sometimes mean "Permanently Denied" if "Don't ask again" was checked previously
    // So we request it. If it returns immediately with denied/permanentlyDenied, we know.
    debugPrint('   Requesting permission via system dialog...');
    final newStatus = await Permission.camera.request();
    debugPrint('   -> Request result: $newStatus');

    if (newStatus.isGranted) {
      debugPrint('   -> Permission GRANTED! Initializing camera...');
      if (mounted) {
        setState(() => _showCurtain = true);
      }
      _initializeCamera();
    } else if (newStatus.isPermanentlyDenied) {
      debugPrint('   -> Status is PERMANENTLY DENIED. Opening settings...');
      openAppSettings();
    } else {
      debugPrint('   -> Permission DENIED (but not permanent? or system did not show dialog).');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Camera access is needed to use this feature.')),
        );
      }
    }
  }

  /// Placeholder UI shown in the portal when microphone permission is missing
  Widget _buildMicPermissionPlaceholder() {
    return Container(
      color: AppColors.surface,
      width: double.infinity,
      height: double.infinity,
      alignment: Alignment.center,
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.mic_off_rounded, color: Colors.white.withOpacity(0.5), size: 48),
          const SizedBox(height: 16),
          Text(
            'Enable Microphone to Vibe',
            style: GoogleFonts.inter(
              color: Colors.white,
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            'We need access to record your voice.',
            style: GoogleFonts.inter(
              color: Colors.white.withOpacity(0.6),
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 24),
          GestureDetector(
            onTap: _requestMicPermission,
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(30),
              ),
              child: Text(
                'Allow Access',
                style: GoogleFonts.inter(
                  color: Colors.black,
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Helper: Centralized microphone permission request logic
  Future<void> _requestMicPermission() async {
    debugPrint('ðŸ”˜ Requesting Microphone Permission...');
    
    var status = await Permission.microphone.status;
    if (status.isPermanentlyDenied) {
      await openAppSettings();
      return;
    }

    final newStatus = await Permission.microphone.request();
    if (mounted) {
      setState(() {
        _isMicPermissionGranted = newStatus.isGranted;
      });
      
      if (!newStatus.isGranted && !newStatus.isPermanentlyDenied) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Microphone access is needed for audio vibes.')),
        );
      } else if (newStatus.isPermanentlyDenied) {
        openAppSettings();
      }
    }
  }

}




========================================

FILE #44: E:\Vive\lib\features\camera\presentation\preview_screen.dart

========================================


import 'dart:io';
import 'dart:math' as math;
import 'dart:ui' as ui;
import 'dart:isolate';
import 'dart:typed_data';
import 'package:image/image.dart' as img;
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:video_player/video_player.dart';
import 'package:audioplayers/audioplayers.dart'; // For PlayerState enum
import 'package:path_provider/path_provider.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/vibe_service.dart';
import 'package:nock/core/services/audio_service.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/shared/widgets/aura_visualization.dart';
import 'package:nock/features/squad/presentation/squad_screen.dart';  // for friendsProvider
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/providers/vibe_upload_provider.dart';

/// Preview Screen - Review photo/video + audio before sending
class PreviewScreen extends ConsumerStatefulWidget {
  final String imagePath;
  final String audioPath;
  final String? videoPath;
  final bool isVideo;
  final bool isAudioOnly;  // Audio-only mode with blurred profile background
  final String? senderAvatarUrl;  // For audio-only blurred background
  final bool isFromGallery;
  final DateTime? originalPhotoDate;
  final int? audioDuration; // Actual audio/video duration in seconds

  const PreviewScreen({
    super.key,
    required this.imagePath,
    required this.audioPath,
    this.videoPath,
    this.isVideo = false,
    this.isAudioOnly = false,
    this.senderAvatarUrl,
    required this.isFromGallery,
    this.originalPhotoDate,
    this.audioDuration,
  });

  @override
  ConsumerState<PreviewScreen> createState() => _PreviewScreenState();
}

class _PreviewScreenState extends ConsumerState<PreviewScreen> with WidgetsBindingObserver {
  bool _isSending = false;
  VideoPlayerController? _videoController;
  bool _isVideoInitialized = false;
  
  // Key for capturing audio-only background as image
  final GlobalKey _backgroundKey = GlobalKey();
  
  // Audio playback state for Aura visualization
  bool _isAudioPlaying = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    
    // FIX: Stop any "zombie" audio from previous screens immediately
    ref.read(audioServiceProvider).stop();
    
    if (widget.isVideo && widget.videoPath != null) {
      _initializeVideoPlayer();
    }
    
    // Listen to audio playback state for Aura visualization
    if (widget.isAudioOnly || (!widget.isVideo && widget.audioPath.isNotEmpty)) {
      _setupAudioStateListener();
      
      // FIX #7: Auto-play audio for photo+audio mode (consistent with video auto-play)
      // Delay slightly to let the UI settle
      Future.delayed(const Duration(milliseconds: 500), () {
        if (mounted && widget.audioPath.isNotEmpty) {
          ref.read(audioServiceProvider).playFromFile(widget.audioPath);
        }
      });
    }
  }
  
  void _setupAudioStateListener() {
    final audioService = ref.read(audioServiceProvider);
    audioService.stateStream.listen((state) {
      if (mounted) {
        setState(() {
          _isAudioPlaying = state == PlayerState.playing;
        });
      }
    });
  }

  Future<void> _initializeVideoPlayer() async {
    final controller = VideoPlayerController.file(File(widget.videoPath!));
    
    // Release old controller if it exists to prevent leaks
    final oldController = _videoController;
    if (oldController != null) {
      await oldController.dispose();
    }
    
    // Assign early so dispose() can clean it up if user exits NOW
    _videoController = controller;

  try {
    await controller.initialize();
    
    // CRITICAL RACE FIX:
    if (!mounted) {
      // No need to dispose here as dispose() method already handled _videoController
      // effectively (or will when it runs, if it hasn't already).
      // Actually, if dispose() ran, _videoController might be null or disposed.
      return; 
    }
    
    // Safety check: ensure the controller we just inited is still the active one
    // and hasn't been disposed/replaced by another call.
    if (_videoController != controller) return;

    await controller.setLooping(true);
    await controller.play();
    
    if (mounted) {
      setState(() => _isVideoInitialized = true);
    }
  } catch (e) {
    debugPrint('Error initializing video: $e');
  }
}

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      // FIX: Stop audio and pause video when app goes to background
      ref.read(audioServiceProvider).stop();
      if (_videoController != null && _videoController!.value.isPlaying) {
        _videoController!.pause();
        if (mounted) setState(() {});
      }
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _videoController?.dispose();
    // FIX: Stop audio playback to prevent "Zombie Audio" leak
    // Without this, audio continues playing after leaving screen
    ref.read(audioServiceProvider).stop();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.voidNavy,
      body: Stack(
        children: [
          // Preview content (image, video, or audio-only background)
          Positioned.fill(
            child: RepaintBoundary(
              key: _backgroundKey,
              child: _buildPreviewContent(),
            ),
          ),

          // Top bar
          SafeArea(
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  IconButton(
                    onPressed: () => context.pop(),
                    icon: const Icon(Icons.close, color: Colors.white),
                  ),
                  Row(
                    children: [
                      if (widget.isVideo)
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 12,
                            vertical: 6,
                          ),
                          decoration: BoxDecoration(
                            color: AppColors.secondaryAction.withOpacity(0.8),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          child: Row(
                            children: [
                              Icon(Icons.videocam, color: Colors.white, size: 16),
                              SizedBox(width: 4),
                              Text(
                                'VIDEO',
                                style: AppTypography.labelSmall.copyWith(
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ),
                        ),
                      if (widget.isFromGallery && widget.originalPhotoDate != null) ...[
                        const SizedBox(width: 8),
                        Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 12,
                            vertical: 6,
                          ),
                          decoration: BoxDecoration(
                            color: Colors.black54,
                            borderRadius: BorderRadius.circular(8),
                          ),
                            child: Text(
                            'ðŸ“… ${_formatDate(widget.originalPhotoDate!)}',
                            style: AppTypography.labelSmall.copyWith(
                              color: AppColors.vibeAccent,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),

          // Video playback controls (if video)
          if (widget.isVideo && _isVideoInitialized && _videoController != null)
            Positioned(
              bottom: MediaQuery.of(context).padding.bottom + 200,
              left: 0,
              right: 0,
              child: Center(
                child: GestureDetector(
                  onTap: () {
                    setState(() {
                      if (_videoController!.value.isPlaying) {
                        _videoController!.pause();
                      } else {
                        _videoController!.play();
                      }
                    });
                  },
                  child: Container(
                    width: 64,
                    height: 64,
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.5),
                      shape: BoxShape.circle,
                    ),
                    child: Icon(
                      _videoController!.value.isPlaying
                          ? Icons.pause
                          : Icons.play_arrow,
                      color: Colors.white,
                      size: 32,
                    ),
                  ),
                ),
              ),
            ),

          // Bottom controls
          Positioned(
            bottom: 0,
            left: 0,
            right: 0,
            child: Container(
              padding: EdgeInsets.only(
                left: 24,
                right: 24,
                bottom: MediaQuery.of(context).padding.bottom + 24,
                top: 24,
              ),
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [
                    Colors.transparent,
                    Colors.black.withOpacity(0.9),
                  ],
                ),
              ),
              child: Column(
                children: [
                  // Audio preview indicator (only for photo mode)
                  if (!widget.isVideo && widget.audioPath.isNotEmpty)
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        children: [
                          const Icon(
                            Icons.mic,
                            color: AppColors.error, // Ã¢Å“Â¨ Thermal Orange (Voice/Record standard)
                          ),
                          const SizedBox(width: 12),
                          const Expanded(
                            child: Text(
                              'Voice note attached',
                              style: TextStyle(color: Colors.white),
                            ),
                          ),
                          IconButton(
                            onPressed: () {
                              ref.read(audioServiceProvider).playFromFile(
                                widget.audioPath,
                              );
                            },
                            icon: const Icon(
                              Icons.play_arrow,
                              color: AppColors.primaryAction,
                            ),
                          ),
                        ],
                      ),
                    ),

                  // Video info (for video mode)
                  if (widget.isVideo && _videoController != null)
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Row(
                        children: [
                          const Icon(
                            Icons.videocam,
                            color: AppColors.secondaryAction,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Text(
                              'Video with audio ${_isVideoInitialized ? "(${_formatDuration(_videoController!.value.duration)})" : ""}',
                              style: const TextStyle(color: Colors.white),
                            ),
                          ),
                        ],
                      ),
                    ),

                  const SizedBox(height: 24),

                  // Send button
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton.icon(
                      onPressed: _isSending ? null : _sendVibe,
                      style: ElevatedButton.styleFrom(
                        backgroundColor: AppColors.primaryAction,
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      icon: _isSending
                          ? const SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.black,
                              ),
                            )
                          : const Icon(Icons.send, color: Colors.black),
                      label: Text(
                        _isSending ? 'Sending...' : 'Send Vibe',
                        style: AppTypography.buttonText.copyWith(color: Colors.black),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Build the main preview content based on mode
  Widget _buildPreviewContent() {
    // Audio-only mode: Show blurred profile picture or gradient
    // Use 1:1 aspect ratio to match the camera portal design
    if (widget.isAudioOnly) {
      return Center(
        child: AspectRatio(
          aspectRatio: 1.0, // Match camera portal's 1:1 square
          child: ClipRRect(
            borderRadius: BorderRadius.circular(24),
            child: _buildAudioOnlyBackground(),
          ),
        ),
      );
    }
    
    // Video mode
    if (widget.isVideo && widget.videoPath != null) {
      return _buildVideoPlayer();
    }
    
    // Photo mode (default)
    if (widget.imagePath.isNotEmpty && File(widget.imagePath).existsSync()) {
      return Image.file(
        File(widget.imagePath),
        fit: BoxFit.cover,
      );
    }
    
    // Fallback: gradient background
    return _buildAudioOnlyBackground();
  }
  
  /// Build beautiful background for audio-only vibes
  /// Uses blurred profile picture if available, otherwise animated gradient
  Widget _buildAudioOnlyBackground() {
    return Stack(
      fit: StackFit.expand,
      children: [
        // Layer 1: Profile image or gradient base
        if (widget.senderAvatarUrl != null && widget.senderAvatarUrl!.isNotEmpty)
          Image.network(
            widget.senderAvatarUrl!,
            fit: BoxFit.cover,
            errorBuilder: (_, __, ___) => _buildGradientFallback(),
          )
        else
          _buildGradientFallback(),
        
        // Layer 2: Heavy blur effect
        BackdropFilter(
          filter: ui.ImageFilter.blur(sigmaX: 40, sigmaY: 40),
          child: Container(color: Colors.transparent),
        ),
        
        // Layer 3: Dark overlay for contrast
        Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black.withOpacity(0.3),
                Colors.black.withOpacity(0.5),
                Colors.black.withOpacity(0.7),
              ],
            ),
          ),
        ),
        
        // Layer 4: Animated Aura visualization
        // Connected to actual audio playback state
        Positioned.fill(
          child: Opacity(
            opacity: 0.4,
            child: AuraVisualization(isPlaying: _isAudioPlaying),
          ),
        ),
        
        // Layer 5: Audio mode indicator in center
        // FIX: Removed redundant static mic icon - AuraVisualization IS the indicator
        // Keeping just the text labels for context
        Center(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Animated play button that pulses with audio
                GestureDetector(
                  onTap: () {
                    if (_isAudioPlaying) {
                      ref.read(audioServiceProvider).stop();
                    } else {
                      ref.read(audioServiceProvider).playFromFile(widget.audioPath);
                    }
                  },
                  child: Container(
                    width: 80,
                    height: 80,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      gradient: LinearGradient(
                        colors: [
                          AppColors.primaryAction.withOpacity(0.3),
                          AppColors.primaryAction.withOpacity(0.1),
                        ],
                      ),
                      border: Border.all(
                        color: AppColors.primaryAction.withOpacity(0.5),
                        width: 2,
                      ),
                    ),
                    child: Icon(
                      _isAudioPlaying ? Icons.pause : Icons.play_arrow,
                      size: 42,
                      color: Colors.white,
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  'Audio Vibe',
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.9),
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  '${widget.audioDuration ?? 0}s',
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.6),
                    fontSize: 14,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
  
  /// Gradient fallback when no profile picture available
  Widget _buildGradientFallback() {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFF667EEA),
            Color(0xFF764BA2),
            Color(0xFFFF0099),
            Color(0xFF00F0FF),
          ],
        ),
      ),
    );
  }
  
  /// Capture the background as an image file for widget compatibility
  /// 
  /// SAFETY FIX: Implements dynamic downscaling to prevent GPU Texture OOM crashes.
  /// Standard mobile GPUs have a Max Texture Size limit (often 4096px or 8192px).
  /// Capturing at full device pixel ratio on a large tablet can exceed this limit.
  Future<File?> _captureBackgroundAsImage() async {
    try {
      final boundary = _backgroundKey.currentContext?.findRenderObject() as RenderRepaintBoundary?;
      if (boundary == null) return null;
      
      // 1. Calculate a safe pixel ratio
      // logicalSize * pixelRatio = physicalPixels
      final ui.Size logicalSize = boundary.size;
      
      // CRITICAL OOM FIX: Lowered from 2048px to 1080px (Final Safety Adjustment).
      // 2048x2048px = 16MB (Safe-ish).
      // 1080x1920px = 8MB (Ideal high-quality limit).
      // 1024x1024px = 4MB (Bulletproof).
      const double maxSafeDimension = 1080.0; 
      
      final double maxSide = math.max(logicalSize.width, logicalSize.height);
      
      // If the widget is already larger than 1080px, the ratio will be < 1.0
      double safePixelRatio = 1.0;
      if (maxSide > maxSafeDimension) {
        safePixelRatio = maxSafeDimension / maxSide;
      }
      
      // 2. Capture the image with the calculated safe ratio
      final image = await boundary.toImage(pixelRatio: safePixelRatio);
      
      // CRITICAL PERFORMANCE FIX: "Extract on Main, Encode on Worker" Pattern
      // 1. Extract raw RGBA bytes on the UI thread (very fast, no encoding).
      final byteData = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
      final int width = image.width;
      final int height = image.height;
      
      // CRITICAL: Explicitly dispose the GPU handle immediately as we now have the CPU bytes.
      image.dispose();
      
      if (byteData == null) return null;

      // 2. Offload heavy PNG compression to a background isolate using the 'image' package.
      // This avoids the ArgumentError because we are passing raw bytes (Uint8List), not a GPU handle.
      final Uint8List pngBytes = await Isolate.run(() {
        final rawBytes = byteData.buffer.asUint8List();
        
        // Convert raw bytes to an 'image' package object
        final imgImage = img.Image.fromBytes(
          width: width,
          height: height,
          bytes: rawBytes.buffer,
          numChannels: 4,
          format: img.Format.uint8,
          order: img.ChannelOrder.rgba,
        );
        
        // Perform the CPU-intensive PNG encoding
        return img.encodePng(imgImage);
      });
      
      final tempDir = await getTemporaryDirectory();
      final file = File('${tempDir.path}/audio_vibe_bg_${DateTime.now().millisecondsSinceEpoch}.png');
      await file.writeAsBytes(pngBytes);
      
      return file;
    } catch (e) {
      debugPrint('Error capturing background: $e');
      return null;
    }
  }

  Widget _buildVideoPlayer() {
    if (!_isVideoInitialized || _videoController == null) {
      return Container(
        color: Colors.black,
        child: const Center(
          child: CircularProgressIndicator(
            color: Color(0xFF00F0FF),
          ),
        ),
      );
    }

    return GestureDetector(
      onTap: () {
        setState(() {
          if (_videoController!.value.isPlaying) {
            _videoController!.pause();
          } else {
            _videoController!.play();
          }
        });
      },
      // PORTAL PARADOX FIX: Use AspectRatio instead of BoxFit.cover
      // This preserves the 1:1 square framing the user saw during recording
      child: Center(
        child: AspectRatio(
          aspectRatio: _videoController!.value.aspectRatio, // 1.0 (1:1 square)
          child: ClipRRect(
            borderRadius: BorderRadius.circular(24), // Match camera portal
            child: VideoPlayer(_videoController!),
          ),
        ),
      ),
    );
  }

  String _formatDuration(Duration duration) {
    String twoDigits(int n) => n.toString().padLeft(2, '0');
    final minutes = twoDigits(duration.inMinutes.remainder(60));
    final seconds = twoDigits(duration.inSeconds.remainder(60));
    return '$minutes:$seconds';
  }

  String _formatDate(DateTime date) {
    final months = [
      'JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
      'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'
    ];
    return '${months[date.month - 1]} ${date.day}';
  }

  Future<void> _sendVibe() async {
    _showFriendPicker();
  }

  void _showFriendPicker() {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF1A1A1A),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => Consumer(
        builder: (context, ref, _) {
          final friendsAsync = ref.watch(friendsProvider);
          
          return Container(
            padding: const EdgeInsets.all(24),
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(context).size.height * 0.6,
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  'Send to...',
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                
                Expanded(
                  child: friendsAsync.when(
                    data: (friends) {
                      if (friends.isEmpty) {
                        return Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              const Icon(Icons.people_outline, color: Colors.grey, size: 48),
                              const SizedBox(height: 16),
                              const Text(
                                'No friends yet',
                                style: TextStyle(color: Colors.white),
                              ),
                              const SizedBox(height: 8),
                              TextButton(
                                onPressed: () {
                                  Navigator.pop(context); // Close picker
                                  context.push(AppRoutes.addFriends);
                                },
                                child: const Text('Add Friends'),
                              ),
                            ],
                          ),
                        );
                      }
                      
                      return ListView.separated(
                        itemCount: friends.length,
                        separatorBuilder: (_, __) => const SizedBox(height: 12),
                        itemBuilder: (context, index) {
                          final friend = friends[index];
                          return ListTile(
                            contentPadding: EdgeInsets.zero,
                            leading: CircleAvatar(
                              radius: 24,
                              backgroundImage: friend.avatarUrl != null
                                  ? NetworkImage(friend.avatarUrl!)
                                  : null,
                              backgroundColor: Colors.grey[800],
                              child: friend.avatarUrl == null
                                  ? Text(friend.displayName[0].toUpperCase())
                                  : null,
                            ),
                            title: Text(
                              friend.displayName,
                              style: const TextStyle(
                                color: Colors.white,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                            trailing: Container(
                              padding: const EdgeInsets.all(8),
                              decoration: const BoxDecoration(
                                color: AppColors.primaryAction,
                                shape: BoxShape.circle,
                              ),
                              child: const Icon(Icons.send, color: Colors.black, size: 20),
                            ),
                            onTap: () => _performSend(friend.id),
                          );
                        },
                      );
                    },
                    loading: () => const Center(
                      child: CircularProgressIndicator(color: AppColors.primaryAction),
                    ),
                    error: (_, __) => const Center(
                      child: Text('Error loading friends', style: TextStyle(color: Colors.red)),
                    ),
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _performSend(String receiverId) async {
    Navigator.pop(context); // Close picker
    
    if (_isSending) return;
    
    // FIX: stop audio immediately when send starts to prevent "Zombie Audio" 
    ref.read(audioServiceProvider).stop();
    
    // We need to capture the background image BEFORE navigating
    // because after navigation the context is gone
    File? imageFile;
    if (widget.isAudioOnly) {
      // Show a temporary loading if needed, but since capture is fast, we just do it
      // AUDIO-ONLY: Capture the blurred background as image for widget
      imageFile = await _captureBackgroundAsImage();
      if (imageFile == null) {
        debugPrint('Warning: Could not capture background, sending without image');
      }
    } else if (!widget.isVideo && widget.imagePath.isNotEmpty) {
      // PHOTO: Use the actual photo
      imageFile = File(widget.imagePath);
    }

    // Capture duration and other metadata
    int duration = widget.audioDuration ?? 5;
    if (widget.isVideo && _isVideoInitialized && _videoController != null) {
      duration = _videoController!.value.duration.inSeconds;
      if (duration <= 0) duration = widget.audioDuration ?? 5;
    }
    
    // Mock waveform for now (should be passed from camera but PreviewScreen doesn't have it yet)
    final waveform = List.generate(20, (_) => 0.5);

    // Trigger background upload
    debugPrint('ðŸ“¤ [PreviewScreen] Triggering background upload');
    await ref.read(vibeUploadProvider.notifier).addUpload(
      receiverId: receiverId,
      audioPath: widget.audioPath.isNotEmpty ? widget.audioPath : null,
      audioDuration: duration,
      waveformData: waveform,
      imagePath: imageFile?.path,
      videoPath: widget.isVideo && widget.videoPath != null ? widget.videoPath : null,
      isVideo: widget.isVideo,
      isAudioOnly: widget.isAudioOnly,
      isFromGallery: widget.isFromGallery,
      originalPhotoDate: widget.originalPhotoDate,
    );

    // OPTIMISTIC NAVIGATION: Go home immediately!
    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Sending Nock...'),
          duration: Duration(seconds: 2),
        ),
      );
      context.go(AppRoutes.home);
    }
  }
}



========================================

FILE #45: E:\Vive\lib\features\camera\presentation\painters\camera_painters.dart

========================================


// Barrel file for camera painters
export 'drawing_painter.dart';
export 'corner_progress_painter.dart';
export 'focus_painter.dart';



========================================

FILE #46: E:\Vive\lib\features\camera\presentation\painters\corner_progress_painter.dart

========================================


import 'package:flutter/material.dart';

/// Custom painter for corner progress indicator during video recording
/// Draws an animated rounded rectangle border that fills based on progress
class CornerProgressPainter extends CustomPainter {
  final double progress;
  final Color color;
  final double strokeWidth;
  final double cornerRadius;

  CornerProgressPainter({
    required this.progress,
    required this.color,
    required this.strokeWidth,
    required this.cornerRadius,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final rect = Rect.fromLTWH(
      strokeWidth / 2, strokeWidth / 2,
      size.width - strokeWidth, size.height - strokeWidth,
    );
    final rrect = RRect.fromRectAndRadius(rect, Radius.circular(cornerRadius));
    
    final fullPath = Path()..addRRect(rrect);
    final pathMetrics = fullPath.computeMetrics().first;
    final extractPath = pathMetrics.extractPath(0, pathMetrics.length * progress);
    
    // Glow effect
    final glowPaint = Paint()
      ..color = color.withAlpha(102)
      ..strokeWidth = strokeWidth + 8
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 8);
    
    canvas.drawPath(extractPath, glowPaint);
    canvas.drawPath(extractPath, paint);
  }

  @override
  bool shouldRepaint(CornerProgressPainter oldDelegate) => oldDelegate.progress != progress;
}



========================================

FILE #47: E:\Vive\lib\features\camera\presentation\painters\drawing_painter.dart

========================================


import 'package:flutter/material.dart';
import 'package:nock/features/camera/domain/models/drawing_stroke.dart';

/// Custom painter for drawing strokes on camera preview
/// Paints both completed strokes and the current in-progress stroke
class DrawingPainter extends CustomPainter {
  final List<DrawingStroke> strokes;
  final List<Offset> currentStroke;
  final Color currentColor;
  final double currentStrokeWidth;

  DrawingPainter({
    required this.strokes,
    required this.currentStroke,
    required this.currentColor,
    required this.currentStrokeWidth,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Base width for scaling stroke width (matches PlayerScreen strategy)
    final strokeScale = size.width / 360;

    // Draw completed strokes
    for (final stroke in strokes) {
      final paint = Paint()
        ..color = stroke.color
        ..strokeWidth = stroke.strokeWidth * strokeScale
        ..strokeCap = StrokeCap.round
        ..style = PaintingStyle.stroke;
      
      if (stroke.points.length > 1) {
        final path = Path();
        path.moveTo(stroke.points.first.dx * size.width, stroke.points.first.dy * size.height);
        for (int i = 1; i < stroke.points.length; i++) {
          path.lineTo(stroke.points[i].dx * size.width, stroke.points[i].dy * size.height);
        }
        canvas.drawPath(path, paint);
      }
    }
    
    // Draw current stroke
    if (currentStroke.length > 1) {
      final paint = Paint()
        ..color = currentColor
        ..strokeWidth = currentStrokeWidth * strokeScale
        ..strokeCap = StrokeCap.round
        ..style = PaintingStyle.stroke;
      
      final path = Path();
      path.moveTo(currentStroke.first.dx * size.width, currentStroke.first.dy * size.height);
      for (int i = 1; i < currentStroke.length; i++) {
        path.lineTo(currentStroke[i].dx * size.width, currentStroke[i].dy * size.height);
      }
      canvas.drawPath(path, paint);
    }
  }

  @override
  bool shouldRepaint(DrawingPainter oldDelegate) {
    return oldDelegate.strokes != strokes ||
        oldDelegate.currentStroke != currentStroke ||
        oldDelegate.currentColor != currentColor ||
        oldDelegate.currentStrokeWidth != currentStrokeWidth;
  }
}



========================================

FILE #48: E:\Vive\lib\features\camera\presentation\painters\focus_painter.dart

========================================


import 'package:flutter/material.dart';

class FocusBracketPainter extends CustomPainter {
  final Color color;

  FocusBracketPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0;

    final double length = 15.0;

    // Top-left bracket
    canvas.drawLine(const Offset(0, 0), Offset(length, 0), paint);
    canvas.drawLine(const Offset(0, 0), Offset(0, length), paint);

    // Top-right bracket
    canvas.drawLine(Offset(size.width, 0), Offset(size.width - length, 0), paint);
    canvas.drawLine(Offset(size.width, 0), Offset(size.width, length), paint);

    // Bottom-left bracket
    canvas.drawLine(Offset(0, size.height), Offset(length, size.height), paint);
    canvas.drawLine(Offset(0, size.height), Offset(0, size.height - length), paint);

    // Bottom-right bracket
    canvas.drawLine(Offset(size.width, size.height), Offset(size.width - length, size.height), paint);
    canvas.drawLine(Offset(size.width, size.height), Offset(size.width, size.height - length), paint);
    
    // Tiny center dot
    canvas.drawCircle(Offset(size.width / 2, size.height / 2), 1.5, paint..style = PaintingStyle.fill);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}



========================================

FILE #49: E:\Vive\lib\features\camera\presentation\state\camera_session_state.freezed.dart

========================================


// GENERATED CODE - DO NOT MODIFY BY HAND
// coverage:ignore-file
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'camera_session_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
/// @nodoc
mixin _$CameraSessionState {

// Capture State
 File? get capturedImage; File? get capturedVideo; File? get recordedAudioFile; bool get isRecordingVideo; bool get isRecordingAudio; int get audioDuration;// Edit State
 EditMode get currentEditMode; Color get currentDrawColor; double get currentStrokeWidth; TextFontStyle get currentFontStyle; double get currentTextSize;// UI/Preview State
 bool get isAudioOnlyMode; bool get isProcessingCapture; bool get showCurtain; bool get wasFrontCamera;// HUD State
 bool get showFocusReticle; Offset? get focusPoint;// Selection state for stickers/text
 int? get selectedStickerIndex; int? get selectedTextIndex;
/// Create a copy of CameraSessionState
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
$CameraSessionStateCopyWith<CameraSessionState> get copyWith => _$CameraSessionStateCopyWithImpl<CameraSessionState>(this as CameraSessionState, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is CameraSessionState&&(identical(other.capturedImage, capturedImage) || other.capturedImage == capturedImage)&&(identical(other.capturedVideo, capturedVideo) || other.capturedVideo == capturedVideo)&&(identical(other.recordedAudioFile, recordedAudioFile) || other.recordedAudioFile == recordedAudioFile)&&(identical(other.isRecordingVideo, isRecordingVideo) || other.isRecordingVideo == isRecordingVideo)&&(identical(other.isRecordingAudio, isRecordingAudio) || other.isRecordingAudio == isRecordingAudio)&&(identical(other.audioDuration, audioDuration) || other.audioDuration == audioDuration)&&(identical(other.currentEditMode, currentEditMode) || other.currentEditMode == currentEditMode)&&(identical(other.currentDrawColor, currentDrawColor) || other.currentDrawColor == currentDrawColor)&&(identical(other.currentStrokeWidth, currentStrokeWidth) || other.currentStrokeWidth == currentStrokeWidth)&&(identical(other.currentFontStyle, currentFontStyle) || other.currentFontStyle == currentFontStyle)&&(identical(other.currentTextSize, currentTextSize) || other.currentTextSize == currentTextSize)&&(identical(other.isAudioOnlyMode, isAudioOnlyMode) || other.isAudioOnlyMode == isAudioOnlyMode)&&(identical(other.isProcessingCapture, isProcessingCapture) || other.isProcessingCapture == isProcessingCapture)&&(identical(other.showCurtain, showCurtain) || other.showCurtain == showCurtain)&&(identical(other.wasFrontCamera, wasFrontCamera) || other.wasFrontCamera == wasFrontCamera)&&(identical(other.showFocusReticle, showFocusReticle) || other.showFocusReticle == showFocusReticle)&&(identical(other.focusPoint, focusPoint) || other.focusPoint == focusPoint)&&(identical(other.selectedStickerIndex, selectedStickerIndex) || other.selectedStickerIndex == selectedStickerIndex)&&(identical(other.selectedTextIndex, selectedTextIndex) || other.selectedTextIndex == selectedTextIndex));
}


@override
int get hashCode => Object.hashAll([runtimeType,capturedImage,capturedVideo,recordedAudioFile,isRecordingVideo,isRecordingAudio,audioDuration,currentEditMode,currentDrawColor,currentStrokeWidth,currentFontStyle,currentTextSize,isAudioOnlyMode,isProcessingCapture,showCurtain,wasFrontCamera,showFocusReticle,focusPoint,selectedStickerIndex,selectedTextIndex]);

@override
String toString() {
  return 'CameraSessionState(capturedImage: $capturedImage, capturedVideo: $capturedVideo, recordedAudioFile: $recordedAudioFile, isRecordingVideo: $isRecordingVideo, isRecordingAudio: $isRecordingAudio, audioDuration: $audioDuration, currentEditMode: $currentEditMode, currentDrawColor: $currentDrawColor, currentStrokeWidth: $currentStrokeWidth, currentFontStyle: $currentFontStyle, currentTextSize: $currentTextSize, isAudioOnlyMode: $isAudioOnlyMode, isProcessingCapture: $isProcessingCapture, showCurtain: $showCurtain, wasFrontCamera: $wasFrontCamera, showFocusReticle: $showFocusReticle, focusPoint: $focusPoint, selectedStickerIndex: $selectedStickerIndex, selectedTextIndex: $selectedTextIndex)';
}


}

/// @nodoc
abstract mixin class $CameraSessionStateCopyWith<$Res>  {
  factory $CameraSessionStateCopyWith(CameraSessionState value, $Res Function(CameraSessionState) _then) = _$CameraSessionStateCopyWithImpl;
@useResult
$Res call({
 File? capturedImage, File? capturedVideo, File? recordedAudioFile, bool isRecordingVideo, bool isRecordingAudio, int audioDuration, EditMode currentEditMode, Color currentDrawColor, double currentStrokeWidth, TextFontStyle currentFontStyle, double currentTextSize, bool isAudioOnlyMode, bool isProcessingCapture, bool showCurtain, bool wasFrontCamera, bool showFocusReticle, Offset? focusPoint, int? selectedStickerIndex, int? selectedTextIndex
});




}
/// @nodoc
class _$CameraSessionStateCopyWithImpl<$Res>
    implements $CameraSessionStateCopyWith<$Res> {
  _$CameraSessionStateCopyWithImpl(this._self, this._then);

  final CameraSessionState _self;
  final $Res Function(CameraSessionState) _then;

/// Create a copy of CameraSessionState
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? capturedImage = freezed,Object? capturedVideo = freezed,Object? recordedAudioFile = freezed,Object? isRecordingVideo = null,Object? isRecordingAudio = null,Object? audioDuration = null,Object? currentEditMode = null,Object? currentDrawColor = null,Object? currentStrokeWidth = null,Object? currentFontStyle = null,Object? currentTextSize = null,Object? isAudioOnlyMode = null,Object? isProcessingCapture = null,Object? showCurtain = null,Object? wasFrontCamera = null,Object? showFocusReticle = null,Object? focusPoint = freezed,Object? selectedStickerIndex = freezed,Object? selectedTextIndex = freezed,}) {
  return _then(_self.copyWith(
capturedImage: freezed == capturedImage ? _self.capturedImage : capturedImage // ignore: cast_nullable_to_non_nullable
as File?,capturedVideo: freezed == capturedVideo ? _self.capturedVideo : capturedVideo // ignore: cast_nullable_to_non_nullable
as File?,recordedAudioFile: freezed == recordedAudioFile ? _self.recordedAudioFile : recordedAudioFile // ignore: cast_nullable_to_non_nullable
as File?,isRecordingVideo: null == isRecordingVideo ? _self.isRecordingVideo : isRecordingVideo // ignore: cast_nullable_to_non_nullable
as bool,isRecordingAudio: null == isRecordingAudio ? _self.isRecordingAudio : isRecordingAudio // ignore: cast_nullable_to_non_nullable
as bool,audioDuration: null == audioDuration ? _self.audioDuration : audioDuration // ignore: cast_nullable_to_non_nullable
as int,currentEditMode: null == currentEditMode ? _self.currentEditMode : currentEditMode // ignore: cast_nullable_to_non_nullable
as EditMode,currentDrawColor: null == currentDrawColor ? _self.currentDrawColor : currentDrawColor // ignore: cast_nullable_to_non_nullable
as Color,currentStrokeWidth: null == currentStrokeWidth ? _self.currentStrokeWidth : currentStrokeWidth // ignore: cast_nullable_to_non_nullable
as double,currentFontStyle: null == currentFontStyle ? _self.currentFontStyle : currentFontStyle // ignore: cast_nullable_to_non_nullable
as TextFontStyle,currentTextSize: null == currentTextSize ? _self.currentTextSize : currentTextSize // ignore: cast_nullable_to_non_nullable
as double,isAudioOnlyMode: null == isAudioOnlyMode ? _self.isAudioOnlyMode : isAudioOnlyMode // ignore: cast_nullable_to_non_nullable
as bool,isProcessingCapture: null == isProcessingCapture ? _self.isProcessingCapture : isProcessingCapture // ignore: cast_nullable_to_non_nullable
as bool,showCurtain: null == showCurtain ? _self.showCurtain : showCurtain // ignore: cast_nullable_to_non_nullable
as bool,wasFrontCamera: null == wasFrontCamera ? _self.wasFrontCamera : wasFrontCamera // ignore: cast_nullable_to_non_nullable
as bool,showFocusReticle: null == showFocusReticle ? _self.showFocusReticle : showFocusReticle // ignore: cast_nullable_to_non_nullable
as bool,focusPoint: freezed == focusPoint ? _self.focusPoint : focusPoint // ignore: cast_nullable_to_non_nullable
as Offset?,selectedStickerIndex: freezed == selectedStickerIndex ? _self.selectedStickerIndex : selectedStickerIndex // ignore: cast_nullable_to_non_nullable
as int?,selectedTextIndex: freezed == selectedTextIndex ? _self.selectedTextIndex : selectedTextIndex // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}

}


/// Adds pattern-matching-related methods to [CameraSessionState].
extension CameraSessionStatePatterns on CameraSessionState {
/// A variant of `map` that fallback to returning `orElse`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeMap<TResult extends Object?>(TResult Function( _CameraSessionState value)?  $default,{required TResult orElse(),}){
final _that = this;
switch (_that) {
case _CameraSessionState() when $default != null:
return $default(_that);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// Callbacks receives the raw object, upcasted.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case final Subclass2 value:
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult map<TResult extends Object?>(TResult Function( _CameraSessionState value)  $default,){
final _that = this;
switch (_that) {
case _CameraSessionState():
return $default(_that);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `map` that fallback to returning `null`.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case final Subclass value:
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>(TResult? Function( _CameraSessionState value)?  $default,){
final _that = this;
switch (_that) {
case _CameraSessionState() when $default != null:
return $default(_that);case _:
  return null;

}
}
/// A variant of `when` that fallback to an `orElse` callback.
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return orElse();
/// }
/// ```

@optionalTypeArgs TResult maybeWhen<TResult extends Object?>(TResult Function( File? capturedImage,  File? capturedVideo,  File? recordedAudioFile,  bool isRecordingVideo,  bool isRecordingAudio,  int audioDuration,  EditMode currentEditMode,  Color currentDrawColor,  double currentStrokeWidth,  TextFontStyle currentFontStyle,  double currentTextSize,  bool isAudioOnlyMode,  bool isProcessingCapture,  bool showCurtain,  bool wasFrontCamera,  bool showFocusReticle,  Offset? focusPoint,  int? selectedStickerIndex,  int? selectedTextIndex)?  $default,{required TResult orElse(),}) {final _that = this;
switch (_that) {
case _CameraSessionState() when $default != null:
return $default(_that.capturedImage,_that.capturedVideo,_that.recordedAudioFile,_that.isRecordingVideo,_that.isRecordingAudio,_that.audioDuration,_that.currentEditMode,_that.currentDrawColor,_that.currentStrokeWidth,_that.currentFontStyle,_that.currentTextSize,_that.isAudioOnlyMode,_that.isProcessingCapture,_that.showCurtain,_that.wasFrontCamera,_that.showFocusReticle,_that.focusPoint,_that.selectedStickerIndex,_that.selectedTextIndex);case _:
  return orElse();

}
}
/// A `switch`-like method, using callbacks.
///
/// As opposed to `map`, this offers destructuring.
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case Subclass2(:final field2):
///     return ...;
/// }
/// ```

@optionalTypeArgs TResult when<TResult extends Object?>(TResult Function( File? capturedImage,  File? capturedVideo,  File? recordedAudioFile,  bool isRecordingVideo,  bool isRecordingAudio,  int audioDuration,  EditMode currentEditMode,  Color currentDrawColor,  double currentStrokeWidth,  TextFontStyle currentFontStyle,  double currentTextSize,  bool isAudioOnlyMode,  bool isProcessingCapture,  bool showCurtain,  bool wasFrontCamera,  bool showFocusReticle,  Offset? focusPoint,  int? selectedStickerIndex,  int? selectedTextIndex)  $default,) {final _that = this;
switch (_that) {
case _CameraSessionState():
return $default(_that.capturedImage,_that.capturedVideo,_that.recordedAudioFile,_that.isRecordingVideo,_that.isRecordingAudio,_that.audioDuration,_that.currentEditMode,_that.currentDrawColor,_that.currentStrokeWidth,_that.currentFontStyle,_that.currentTextSize,_that.isAudioOnlyMode,_that.isProcessingCapture,_that.showCurtain,_that.wasFrontCamera,_that.showFocusReticle,_that.focusPoint,_that.selectedStickerIndex,_that.selectedTextIndex);case _:
  throw StateError('Unexpected subclass');

}
}
/// A variant of `when` that fallback to returning `null`
///
/// It is equivalent to doing:
/// ```dart
/// switch (sealedClass) {
///   case Subclass(:final field):
///     return ...;
///   case _:
///     return null;
/// }
/// ```

@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>(TResult? Function( File? capturedImage,  File? capturedVideo,  File? recordedAudioFile,  bool isRecordingVideo,  bool isRecordingAudio,  int audioDuration,  EditMode currentEditMode,  Color currentDrawColor,  double currentStrokeWidth,  TextFontStyle currentFontStyle,  double currentTextSize,  bool isAudioOnlyMode,  bool isProcessingCapture,  bool showCurtain,  bool wasFrontCamera,  bool showFocusReticle,  Offset? focusPoint,  int? selectedStickerIndex,  int? selectedTextIndex)?  $default,) {final _that = this;
switch (_that) {
case _CameraSessionState() when $default != null:
return $default(_that.capturedImage,_that.capturedVideo,_that.recordedAudioFile,_that.isRecordingVideo,_that.isRecordingAudio,_that.audioDuration,_that.currentEditMode,_that.currentDrawColor,_that.currentStrokeWidth,_that.currentFontStyle,_that.currentTextSize,_that.isAudioOnlyMode,_that.isProcessingCapture,_that.showCurtain,_that.wasFrontCamera,_that.showFocusReticle,_that.focusPoint,_that.selectedStickerIndex,_that.selectedTextIndex);case _:
  return null;

}
}

}

/// @nodoc


class _CameraSessionState extends CameraSessionState {
  const _CameraSessionState({this.capturedImage, this.capturedVideo, this.recordedAudioFile, this.isRecordingVideo = false, this.isRecordingAudio = false, this.audioDuration = 0, this.currentEditMode = EditMode.none, this.currentDrawColor = Colors.white, this.currentStrokeWidth = 5.0, this.currentFontStyle = TextFontStyle.classic, this.currentTextSize = 32.0, this.isAudioOnlyMode = false, this.isProcessingCapture = false, this.showCurtain = false, this.wasFrontCamera = false, this.showFocusReticle = false, this.focusPoint, this.selectedStickerIndex, this.selectedTextIndex}): super._();
  

// Capture State
@override final  File? capturedImage;
@override final  File? capturedVideo;
@override final  File? recordedAudioFile;
@override@JsonKey() final  bool isRecordingVideo;
@override@JsonKey() final  bool isRecordingAudio;
@override@JsonKey() final  int audioDuration;
// Edit State
@override@JsonKey() final  EditMode currentEditMode;
@override@JsonKey() final  Color currentDrawColor;
@override@JsonKey() final  double currentStrokeWidth;
@override@JsonKey() final  TextFontStyle currentFontStyle;
@override@JsonKey() final  double currentTextSize;
// UI/Preview State
@override@JsonKey() final  bool isAudioOnlyMode;
@override@JsonKey() final  bool isProcessingCapture;
@override@JsonKey() final  bool showCurtain;
@override@JsonKey() final  bool wasFrontCamera;
// HUD State
@override@JsonKey() final  bool showFocusReticle;
@override final  Offset? focusPoint;
// Selection state for stickers/text
@override final  int? selectedStickerIndex;
@override final  int? selectedTextIndex;

/// Create a copy of CameraSessionState
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
@pragma('vm:prefer-inline')
_$CameraSessionStateCopyWith<_CameraSessionState> get copyWith => __$CameraSessionStateCopyWithImpl<_CameraSessionState>(this, _$identity);



@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _CameraSessionState&&(identical(other.capturedImage, capturedImage) || other.capturedImage == capturedImage)&&(identical(other.capturedVideo, capturedVideo) || other.capturedVideo == capturedVideo)&&(identical(other.recordedAudioFile, recordedAudioFile) || other.recordedAudioFile == recordedAudioFile)&&(identical(other.isRecordingVideo, isRecordingVideo) || other.isRecordingVideo == isRecordingVideo)&&(identical(other.isRecordingAudio, isRecordingAudio) || other.isRecordingAudio == isRecordingAudio)&&(identical(other.audioDuration, audioDuration) || other.audioDuration == audioDuration)&&(identical(other.currentEditMode, currentEditMode) || other.currentEditMode == currentEditMode)&&(identical(other.currentDrawColor, currentDrawColor) || other.currentDrawColor == currentDrawColor)&&(identical(other.currentStrokeWidth, currentStrokeWidth) || other.currentStrokeWidth == currentStrokeWidth)&&(identical(other.currentFontStyle, currentFontStyle) || other.currentFontStyle == currentFontStyle)&&(identical(other.currentTextSize, currentTextSize) || other.currentTextSize == currentTextSize)&&(identical(other.isAudioOnlyMode, isAudioOnlyMode) || other.isAudioOnlyMode == isAudioOnlyMode)&&(identical(other.isProcessingCapture, isProcessingCapture) || other.isProcessingCapture == isProcessingCapture)&&(identical(other.showCurtain, showCurtain) || other.showCurtain == showCurtain)&&(identical(other.wasFrontCamera, wasFrontCamera) || other.wasFrontCamera == wasFrontCamera)&&(identical(other.showFocusReticle, showFocusReticle) || other.showFocusReticle == showFocusReticle)&&(identical(other.focusPoint, focusPoint) || other.focusPoint == focusPoint)&&(identical(other.selectedStickerIndex, selectedStickerIndex) || other.selectedStickerIndex == selectedStickerIndex)&&(identical(other.selectedTextIndex, selectedTextIndex) || other.selectedTextIndex == selectedTextIndex));
}


@override
int get hashCode => Object.hashAll([runtimeType,capturedImage,capturedVideo,recordedAudioFile,isRecordingVideo,isRecordingAudio,audioDuration,currentEditMode,currentDrawColor,currentStrokeWidth,currentFontStyle,currentTextSize,isAudioOnlyMode,isProcessingCapture,showCurtain,wasFrontCamera,showFocusReticle,focusPoint,selectedStickerIndex,selectedTextIndex]);

@override
String toString() {
  return 'CameraSessionState(capturedImage: $capturedImage, capturedVideo: $capturedVideo, recordedAudioFile: $recordedAudioFile, isRecordingVideo: $isRecordingVideo, isRecordingAudio: $isRecordingAudio, audioDuration: $audioDuration, currentEditMode: $currentEditMode, currentDrawColor: $currentDrawColor, currentStrokeWidth: $currentStrokeWidth, currentFontStyle: $currentFontStyle, currentTextSize: $currentTextSize, isAudioOnlyMode: $isAudioOnlyMode, isProcessingCapture: $isProcessingCapture, showCurtain: $showCurtain, wasFrontCamera: $wasFrontCamera, showFocusReticle: $showFocusReticle, focusPoint: $focusPoint, selectedStickerIndex: $selectedStickerIndex, selectedTextIndex: $selectedTextIndex)';
}


}

/// @nodoc
abstract mixin class _$CameraSessionStateCopyWith<$Res> implements $CameraSessionStateCopyWith<$Res> {
  factory _$CameraSessionStateCopyWith(_CameraSessionState value, $Res Function(_CameraSessionState) _then) = __$CameraSessionStateCopyWithImpl;
@override @useResult
$Res call({
 File? capturedImage, File? capturedVideo, File? recordedAudioFile, bool isRecordingVideo, bool isRecordingAudio, int audioDuration, EditMode currentEditMode, Color currentDrawColor, double currentStrokeWidth, TextFontStyle currentFontStyle, double currentTextSize, bool isAudioOnlyMode, bool isProcessingCapture, bool showCurtain, bool wasFrontCamera, bool showFocusReticle, Offset? focusPoint, int? selectedStickerIndex, int? selectedTextIndex
});




}
/// @nodoc
class __$CameraSessionStateCopyWithImpl<$Res>
    implements _$CameraSessionStateCopyWith<$Res> {
  __$CameraSessionStateCopyWithImpl(this._self, this._then);

  final _CameraSessionState _self;
  final $Res Function(_CameraSessionState) _then;

/// Create a copy of CameraSessionState
/// with the given fields replaced by the non-null parameter values.
@override @pragma('vm:prefer-inline') $Res call({Object? capturedImage = freezed,Object? capturedVideo = freezed,Object? recordedAudioFile = freezed,Object? isRecordingVideo = null,Object? isRecordingAudio = null,Object? audioDuration = null,Object? currentEditMode = null,Object? currentDrawColor = null,Object? currentStrokeWidth = null,Object? currentFontStyle = null,Object? currentTextSize = null,Object? isAudioOnlyMode = null,Object? isProcessingCapture = null,Object? showCurtain = null,Object? wasFrontCamera = null,Object? showFocusReticle = null,Object? focusPoint = freezed,Object? selectedStickerIndex = freezed,Object? selectedTextIndex = freezed,}) {
  return _then(_CameraSessionState(
capturedImage: freezed == capturedImage ? _self.capturedImage : capturedImage // ignore: cast_nullable_to_non_nullable
as File?,capturedVideo: freezed == capturedVideo ? _self.capturedVideo : capturedVideo // ignore: cast_nullable_to_non_nullable
as File?,recordedAudioFile: freezed == recordedAudioFile ? _self.recordedAudioFile : recordedAudioFile // ignore: cast_nullable_to_non_nullable
as File?,isRecordingVideo: null == isRecordingVideo ? _self.isRecordingVideo : isRecordingVideo // ignore: cast_nullable_to_non_nullable
as bool,isRecordingAudio: null == isRecordingAudio ? _self.isRecordingAudio : isRecordingAudio // ignore: cast_nullable_to_non_nullable
as bool,audioDuration: null == audioDuration ? _self.audioDuration : audioDuration // ignore: cast_nullable_to_non_nullable
as int,currentEditMode: null == currentEditMode ? _self.currentEditMode : currentEditMode // ignore: cast_nullable_to_non_nullable
as EditMode,currentDrawColor: null == currentDrawColor ? _self.currentDrawColor : currentDrawColor // ignore: cast_nullable_to_non_nullable
as Color,currentStrokeWidth: null == currentStrokeWidth ? _self.currentStrokeWidth : currentStrokeWidth // ignore: cast_nullable_to_non_nullable
as double,currentFontStyle: null == currentFontStyle ? _self.currentFontStyle : currentFontStyle // ignore: cast_nullable_to_non_nullable
as TextFontStyle,currentTextSize: null == currentTextSize ? _self.currentTextSize : currentTextSize // ignore: cast_nullable_to_non_nullable
as double,isAudioOnlyMode: null == isAudioOnlyMode ? _self.isAudioOnlyMode : isAudioOnlyMode // ignore: cast_nullable_to_non_nullable
as bool,isProcessingCapture: null == isProcessingCapture ? _self.isProcessingCapture : isProcessingCapture // ignore: cast_nullable_to_non_nullable
as bool,showCurtain: null == showCurtain ? _self.showCurtain : showCurtain // ignore: cast_nullable_to_non_nullable
as bool,wasFrontCamera: null == wasFrontCamera ? _self.wasFrontCamera : wasFrontCamera // ignore: cast_nullable_to_non_nullable
as bool,showFocusReticle: null == showFocusReticle ? _self.showFocusReticle : showFocusReticle // ignore: cast_nullable_to_non_nullable
as bool,focusPoint: freezed == focusPoint ? _self.focusPoint : focusPoint // ignore: cast_nullable_to_non_nullable
as Offset?,selectedStickerIndex: freezed == selectedStickerIndex ? _self.selectedStickerIndex : selectedStickerIndex // ignore: cast_nullable_to_non_nullable
as int?,selectedTextIndex: freezed == selectedTextIndex ? _self.selectedTextIndex : selectedTextIndex // ignore: cast_nullable_to_non_nullable
as int?,
  ));
}


}

// dart format on



========================================

FILE #50: E:\Vive\lib\features\camera\presentation\widgets\camera_buttons.dart

========================================


import 'package:flutter/material.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/shared/widgets/glass_container.dart';

/// Reusable camera screen button widgets
/// These are commonly used button patterns in the camera UI

/// A translucent circular "glass" button
/// Used for top-left/top-right action buttons (settings, close, undo)
class GlassButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onPressed;
  final Color? color;
  final double size;

  const GlassButton({
    super.key,
    required this.icon,
    required this.onPressed,
    this.color,
    this.size = 44,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onPressed,
      child: CustomPaint(
        painter: CircularLuminousBorderPainter(
          strokeWidth: 1.5,
          baseColor: AppColors.glassBorder,
        ),
        child: Container(
          width: size,
          height: size,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: color?.withAlpha(51) ?? AppColors.glassBackground,
          ),
          child: Icon(icon, color: color ?? Colors.white, size: size * 0.5),
        ),
      ),
    );
  }
}

/// A pill-shaped button with icon and label
/// Used for Flash/Flip camera controls
class MiniPillButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const MiniPillButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: GlassContainer(
        useLuminousBorder: true,
        borderRadius: 24,
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        backgroundColor: AppColors.glassBackground,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(icon, color: Colors.white, size: 18),
            const SizedBox(width: 6),
            Text(
              label,
              style: AppTypography.labelMedium.copyWith(
                color: Colors.white,
                fontWeight: FontWeight.w600,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// A gradient edit mode button with icon and label
/// Used for Draw/Sticker/Text/Voice edit buttons
class EditModeButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final Gradient gradient;
  final VoidCallback onTap;
  final bool isActive;

  const EditModeButton({
    super.key,
    required this.icon,
    required this.label,
    required this.gradient,
    required this.onTap,
    this.isActive = false,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            width: 52,
            height: 52,
            decoration: BoxDecoration(
              gradient: gradient,
              borderRadius: BorderRadius.circular(16),
              border: isActive ? Border.all(color: Colors.white, width: 3) : null,
              boxShadow: [
                BoxShadow(
                  color: (gradient as LinearGradient).colors.first.withAlpha(102),
                  blurRadius: 12,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: Icon(icon, color: Colors.white, size: 26),
          ),
          const SizedBox(height: 6),
          Text(
            label,
            style: AppTypography.labelSmall.copyWith(
              color: Colors.white.withAlpha(204),
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

/// A bottom navigation button with icon and label
/// Used for Memories/Vibes buttons at the bottom
class BottomNavButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const BottomNavButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          GlassContainer(
            width: 52,
            height: 52,
            borderRadius: 16,
            useLuminousBorder: true,
            backgroundColor: AppColors.glassBackground,
            child: Icon(icon, color: Colors.white, size: 24),
          ),
          const SizedBox(height: 6),
          Text(
            label,
            style: AppTypography.labelSmall.copyWith(
              color: Colors.white.withAlpha(204),
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

/// A circular action button with icon and label
/// Used for Retake/Save action buttons when captured
class CircleActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final VoidCallback onTap;

  const CircleActionButton({
    super.key,
    required this.icon,
    required this.label,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          CustomPaint(
            painter: CircularLuminousBorderPainter(
              strokeWidth: 1,
              baseColor: AppColors.glassBorder.withOpacity(0.4),
            ),
            child: Container(
              width: 52,
              height: 52,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: AppColors.glassBackground,
              ),
              child: Icon(icon, color: Colors.white, size: 24),
            ),
          ),
          const SizedBox(height: 6),
          Text(
            label,
            style: AppTypography.labelSmall.copyWith(
              color: Colors.white.withAlpha(204),
              fontWeight: FontWeight.w500,
            ),
          ),
        ],
      ),
    );
  }
}

/// A simple toolbar icon button
/// Used in edit mode toolbars (stroke size, etc.)
class ToolbarIconButton extends StatelessWidget {
  final IconData icon;
  final VoidCallback onTap;
  final double iconSize;

  const ToolbarIconButton({
    super.key,
    required this.icon,
    required this.onTap,
    this.iconSize = 20,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 44,
        height: 44,
        decoration: BoxDecoration(
          color: Colors.white24,
          borderRadius: BorderRadius.circular(12),
        ),
        child: Icon(icon, color: Colors.white, size: iconSize),
      ),
    );
  }
}



========================================

FILE #51: E:\Vive\lib\features\camera\presentation\widgets\camera_widgets.dart

========================================


// Barrel file for camera widgets
export 'camera_buttons.dart';



========================================

FILE #52: E:\Vive\lib\features\camera\presentation\widgets\waveform_visualizer.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nock/core/services/audio_service.dart';
import 'package:nock/core/theme/app_colors.dart';

/// Isolated leaf widget for high-frequency waveform updates.
/// 
/// This prevents "Waveform Rebuild Storms" by containing the ref.watch 
/// and isolating repaints via RepaintBoundary.
class WaveformVisualizer extends ConsumerWidget {
  final int barCount;
  final double height;
  final double width;
  final Color? color;
  final bool isPlaying;

  const WaveformVisualizer({
    super.key,
    this.barCount = 10,
    this.height = 24,
    this.width = double.infinity,
    this.color,
    this.isPlaying = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. ISOLATED WATCH: Only this widget rebuilds every 100ms
    final waveformData = ref.watch(waveformDataProvider);

    // 2. REPAINT BOUNDARY: Firewalls the GPU from redrawing heavy layers (Camera Texture)
    return RepaintBoundary(
      child: SizedBox(
        height: height,
        child: Row(
          mainAxisSize: MainAxisSize.min,
          mainAxisAlignment: MainAxisAlignment.center,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: List.generate(barCount, (index) {
            double value = 0.3; // Default resting height
            
            if (waveformData.isNotEmpty) {
              final step = (waveformData.length / barCount).ceil();
              final dataIndex = (index * step).clamp(0, waveformData.length - 1);
              value = waveformData[dataIndex];
            }
            
            final barHeight = (value * height).clamp(height * 0.2, height);
            
            return AnimatedContainer(
              duration: const Duration(milliseconds: 150),
              margin: const EdgeInsets.symmetric(horizontal: 2),
              width: 3,
              height: barHeight,
              decoration: BoxDecoration(
                color: color ?? (isPlaying ? AppColors.primaryAction : Colors.white.withOpacity(0.7)),
                borderRadius: BorderRadius.circular(2),
              ),
            );
          }),
        ),
      ),
    );
  }
}



========================================

FILE #53: E:\Vive\lib\features\home\presentation\bento_dashboard_screen.dart

========================================


import 'dart:async';
import 'dart:ui' as ui;
import 'package:intl/intl.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:rxdart/rxdart.dart'; // For CombineLatestStream
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/constants/app_constants.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/services/transcription_service.dart';
import 'package:nock/core/services/vibe_service.dart'; // For paginatedVibesProvider
import 'package:nock/core/models/user_model.dart';
import 'package:nock/core/models/vibe_model.dart';
import 'package:nock/core/models/squad_model.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/services/widget_update_service.dart';

// ============================================================================
// PROVIDERS - Using existing data structures from your codebase
// ============================================================================

/// Latest vibes received or sent by current user (for Hero Tile)
final _heroVibesProvider = StreamProvider.family<List<VibeModel>, bool>((ref, isSent) {
  // ðŸ§  OPTIMIZATION: Only watch the ID. 
  // This prevents re-fetching when 'lastActive' updates in the background.
  final userId = ref.watch(currentUserProvider.select(
    (user) => user.valueOrNull?.id
  ));
  
  if (userId == null) return const Stream.empty();
  
  return FirebaseFirestore.instance
      .collection(AppConstants.vibesCollection)
      .where(isSent ? 'senderId' : 'receiverId', isEqualTo: userId)
      .orderBy('createdAt', descending: true)
      .limit(5)
      .snapshots()
      .map((snapshot) {
        final docs = snapshot.docs.map((doc) => VibeModel.fromFirestore(doc)).toList();
            
            // ðŸ§  SMART SORT ALGORITHM (Client-Side)
            // 1. Priority: Unread items (isPlayed == false) -> Hero Slot
            // 2. Recency: If priority is equal, sort by time
            docs.sort((a, b) {
              if (a.isPlayed != b.isPlayed) {
                // If one is unread (false) and other is read (true)
                // We want false < true, so false comes first? 
                // Wait, sort ascending? 
                // boolean compare: false < true. 
                // If a.isPlayed (false) and b.isPlayed (true), we want a first.
                // return -1.
                return a.isPlayed ? 1 : -1;
              }
              // If priority is equal, sort by time descending
              return b.createdAt.compareTo(a.createdAt);
            });
            
      // Return top 5 for the Bento Grid
      return docs.take(5).toList();
    });
});

/// Friends list provider (for avatar display)
/// FIX: Batch query to handle Firestore whereIn limit of 10
final _friendsProvider = StreamProvider<List<UserModel>>((ref) {
  // FIX: Optimization - Only watch friendIds list to prevent total rebuild on timestamp updates
  // This saves massive Firestore read costs
  final friendIds = ref.watch(currentUserProvider.select(
    (user) => user.valueOrNull?.friendIds ?? const <String>[]
  ));
  
  if (friendIds.isEmpty) {
    return Stream.value([]);
  }
      
  // FIX: Batch queries for friends beyond the whereIn limit of 10
  // Split into chunks of 10
  final chunks = <List<String>>[];
  for (var i = 0; i < friendIds.length; i += 10) {
    chunks.add(friendIds.sublist(
      i, 
      i + 10 > friendIds.length ? friendIds.length : i + 10,
    ));
  }
  
  // Create a stream for each chunk and merge them
  final streams = chunks.map((chunk) {
    return FirebaseFirestore.instance
        .collection(AppConstants.usersCollection)
        .where(FieldPath.documentId, whereIn: chunk)
        .snapshots()
        .map((snapshot) =>
            snapshot.docs.map((doc) => UserModel.fromFirestore(doc)).toList());
  }).toList();
  
  // Merge all streams into one
  if (streams.isEmpty) return Stream.value([]);
  if (streams.length == 1) return streams.first;
  
  // INDUSTRY BEST PRACTICE: CombineLatestStream for Firestore chunk merging
  // This prevents duplicate accumulation and ensures UI shows exact DB state
  return CombineLatestStream.list(streams)
    .debounceTime(const Duration(milliseconds: 100)) // FIX: Throttles rapid updates to prevent rebuild spam
    .map((listOfLists) => listOfLists.expand((batch) => batch).toList())
    .startWith([]); // FIX: Emit empty list immediately to trigger skeleton
  });


// ============================================================================
// LAYOUT STATE ENUM - For the "Breathing Grid" adaptive layout
// ============================================================================

/// Layout states for the priority-based "Breathing Grid"
/// The grid adapts its structure based on the most important content
enum _BentoLayoutState {
  /// Data is loading - Show skeleton
  loading,
  
  /// Video vibe received - Full-width cinematic hero
  videoHero,
  
  /// Photo/voice vibe received - Standard bento layout
  standard,
  
  /// No friends yet - Onboarding focused empty state
  emptyNoFriends,
  
  /// Has friends but no content - Waiting for vibes
  emptyWithFriends,
}

// ============================================================================
// MEMORY CLUSTER MODEL - For Narrative Grouping
// ============================================================================

enum MemoryClusterType {
  flashback,    // "On This Day" / Time Travel
  today,        // Today's vibes
  yesterday,    // Yesterday's vibes  
  thisWeek,     // Recent cluster
  month,        // Monthly archive
}

class MemoryCluster {
  final String title;
  final String? subtitle;
  final DateTime startDate;
  final DateTime endDate;
  final List<VibeModel> vibes;
  final MemoryClusterType type;
  
  MemoryCluster({
    required this.title,
    this.subtitle,
    required this.startDate,
    required this.endDate,
    required this.vibes,
    required this.type,
  });
  
  VibeModel? get heroVibe => vibes.isNotEmpty ? vibes.first : null;
}

// ============================================================================
// BENTO DASHBOARD SCREEN
// ============================================================================

/// Bento Dashboard Screen - Gen Z "Chaos meets Cyber-Minimalism"
/// 
/// Replaces the old SquadScreen with a dynamic, widget-style dashboard
/// that aggregates friend activity into a visually rich control center.
/// 
/// Layout:
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  Hero   â”‚  Note   â”‚
/// â”‚ (2x2)   â”‚  (1x1)  â”‚
/// â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
/// â”‚         â”‚ Status  â”‚
/// â”‚         â”‚  (1x1)  â”‚
/// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
/// â”‚   Action (2x1)    â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// â”‚ Squad Active Bar  â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
class BentoDashboardScreen extends ConsumerStatefulWidget {
  const BentoDashboardScreen({super.key, this.onNavigateBack});
  
  /// Called when user swipes down at the top to navigate back to camera
  final VoidCallback? onNavigateBack;

  @override
  ConsumerState<BentoDashboardScreen> createState() => _BentoDashboardScreenState();
}

class _BentoDashboardScreenState extends ConsumerState<BentoDashboardScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _pulseController;
  
  // For swipe-back navigation detection
  final ScrollController _scrollController = ScrollController();
  double _dragStartY = 0;
  
  // FIX: Debounce timer for widget updates to prevent native bridge flooding
  Timer? _widgetUpdateTimer;
  
  // FIX: Optimization - Periodic timer to refresh "Active" status UI without a separate stream
  Timer? _statusRefreshTimer;

  // ðŸ§­ PERSISTENCE FIX: Track if we are viewing Sent or Received history
  bool _isSentView = false;
  
  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    )..repeat(reverse: true);
    
    // FIX: Optimized periodic refresh for "Online" status
    _statusRefreshTimer = Timer.periodic(const Duration(minutes: 1), (_) {
      if (mounted) setState(() {});
    });
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _scrollController.dispose();
    _widgetUpdateTimer?.cancel();
    _statusRefreshTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // ðŸ§  OPTIMIZATION: Only watch specific parts of currentUser to prevent redundant rebuilds
    // on background timestamp updates (lastActive).
    final currentUserDisplayName = ref.watch(currentUserProvider.select((u) => u.valueOrNull?.displayName));
    final currentUserAvatar = ref.watch(currentUserProvider.select((u) => u.valueOrNull?.avatarUrl));
    final currentUserIsPremium = ref.watch(currentUserProvider.select((u) => u.valueOrNull?.isPremium));
    final currentUserHasTrial = ref.watch(currentUserProvider.select((u) => u.valueOrNull?.hasPremiumAccess));
    final currentUserId = ref.watch(currentUserProvider.select((u) => u.valueOrNull?.id));

    final latestVibesAsync = ref.watch(_heroVibesProvider(_isSentView));
    final friendsAsync = ref.watch(_friendsProvider);
    
    // OPTIMIZATION: Computer active friends here from the main friends list
    // This removes the need for a separate Firestore stream (saves battery/reads)
    final fiveMinutesAgo = DateTime.now().subtract(const Duration(minutes: 5));
    final activeFriends = (friendsAsync.valueOrNull ?? []).where((friend) => 
        friend.status == UserStatus.online ||
        friend.lastActive.isAfter(fiveMinutesAgo)
    ).toList();
    
    // HYBRID DASHBOARD: Watch paginated vibes for infinite memories grid
    // Family provider allows us to switch and keep both lists in memory cached
    final paginatedState = ref.watch(paginatedVibesProvider(_isSentView));
    
    // FIX: Listen to vibes changes to trigger transcriptions
    // This replaces the side-effect inside _buildHeroTile
    ref.listen<AsyncValue<List<VibeModel>>>(_heroVibesProvider(_isSentView), (previous, next) {
      next.whenData((vibes) {
        for (final vibe in vibes) {
          if (vibe.audioUrl.isNotEmpty) {
            // Check if we need to load transcription
            final notifier = ref.read(transcriptionStateProvider.notifier);
            if (notifier.getTranscription(vibe.id) == null) {
              notifier.loadTranscription(vibe.id, vibe.audioUrl);
            }
          }
        }
        
        // SQUAD & NOCK WIDGET SYNC: Update all widgets with recent vibes
        // FIX: Debounce to prevent flooding native bridge during Firestore sync
        if (vibes.isNotEmpty) {
          _widgetUpdateTimer?.cancel();
          _widgetUpdateTimer = Timer(const Duration(seconds: 1), () {
            if (!mounted) return;
            debugPrint('ðŸ”„ [BentoDashboard] Syncing all widgets (debounced)');
            WidgetUpdateService.refreshAllWidgets(vibes);
          });
        }
      });
    });
    
    // BFF CONFIG SYNC: Ensure friends list is available for native configuration activities
    // This fixes the "Data Desert" where BFF widgets had no friends to select from.
    ref.listen<AsyncValue<List<UserModel>>>(_friendsProvider, (previous, next) {
      next.whenData((friends) {
        if (friends.isNotEmpty) {
          debugPrint('ðŸ”„ [BentoDashboard] Syncing friends_list for native BFF selection');
          WidgetUpdateService.syncFriendsList(friends);
        }
      });
    });
    
    // Use Listener for raw pointer events - these fire BEFORE gesture recognizers
    // This allows us to detect swipe-down at top before CustomScrollView claims the gesture
    return Listener(
      onPointerDown: (event) {
        _dragStartY = event.position.dy;
        debugPrint('ðŸ‘† Pointer down at y=${_dragStartY.toStringAsFixed(0)}');
      },
      onPointerUp: (event) {
        final dragEndY = event.position.dy;
        final dragDistance = dragEndY - _dragStartY;
        final isAtTop = !_scrollController.hasClients || _scrollController.offset <= 0;
        
        debugPrint('ðŸ‘‡ Pointer up: isAtTop=$isAtTop, dragDistance=${dragDistance.toStringAsFixed(0)}');
        
        // Swipe down = positive dragDistance (finger moved down)
        // Threshold: 80px drag at the top of scroll
        if (isAtTop && dragDistance > 80) {
          debugPrint('ðŸ”™ Swipe-down navigation triggered!');
          widget.onNavigateBack?.call();
        }
      },
      child: Builder(
        builder: (context) {
          // ðŸ” INDEX ERROR SURFACING: Show errors if Firestore query fails (missing index)
          if (paginatedState.error != null) {
            final error = paginatedState.error!;
            if (error.contains('FAILED_PRECONDITION') || error.contains('index')) {
              debugPrint('ðŸ”¥ [BentoDashboard] DATABASE INDEX MISSING: $error');
              WidgetsBinding.instance.addPostFrameCallback((_) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: const Text('Unable to load full history at this time.'),
                    backgroundColor: Colors.black87,
                    behavior: SnackBarBehavior.floating,
                    duration: const Duration(seconds: 3),
                    action: SnackBarAction(
                      label: 'Dismiss',
                      textColor: AppColors.primaryAction,
                      onPressed: () {},
                    ),
                  ),
                );
              });
            }
          }
          
          return CustomScrollView(
        controller: _scrollController,
        physics: const AlwaysScrollableScrollPhysics(
          parent: BouncingScrollPhysics(),
        ),
      slivers: [
        // Swipe Down Hint - Fix for vertical navigation discoverability
        SliverSafeArea(
          bottom: false,
          sliver: SliverToBoxAdapter(
            child: _buildSwipeDownHint(),
          ),
        ),
        
        // Header
        SliverToBoxAdapter(
          child: _buildHeader(
            displayName: currentUserDisplayName,
            avatarUrl: currentUserAvatar,
            isPremium: currentUserIsPremium ?? false,
            hasPremiumAccess: currentUserHasTrial ?? false,
          ),
        ),
        
        // Bento Grid
        SliverPadding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          sliver: SliverToBoxAdapter(
            child: latestVibesAsync.when(
              data: (vibes) => _buildBentoGrid(
                vibes: vibes,
                currentUserId: currentUserId,
                activeFriends: activeFriends,
                allFriends: friendsAsync.valueOrNull ?? [],
                isFriendsLoading: friendsAsync.isLoading,
              ),
              loading: () => _buildBentoSkeleton(),
              error: (_, __) => const SizedBox(height: 300),
            ),
          ),
        ),
        

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NARRATIVE ENGINE: Flashbacks & Clusters
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // "On This Day" Section
        SliverToBoxAdapter(
          child: _buildFlashbackSection(_getFlashbacks(paginatedState.vibes)),
        ),

        // Memories Section Header
        SliverToBoxAdapter(
          child: _buildMemoriesHeader(),
        ),

        // Clustered Memories List
        if (paginatedState.vibes.isEmpty && paginatedState.isLoading)
          const SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.all(40),
              child: Center(
                child: CircularProgressIndicator(color: AppColors.primaryAction),
              ),
            ),
          )
        else if (paginatedState.vibes.isEmpty)
          SliverToBoxAdapter(
            child: _buildEmptyMemoriesState(),
          )
        else
          ..._buildMemoryClusters(paginatedState.vibes).map((cluster) {
            return [
              // Cluster Date Header
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(16, 24, 16, 12),
                  child: Row(
                    children: [
                      Container(
                        width: 4,
                        height: 16,
                        decoration: BoxDecoration(
                          gradient: _getClusterGradient(cluster.type),
                          borderRadius: BorderRadius.circular(2),
                        ),
                      ),
                      const SizedBox(width: 8),
                      Text(
                        cluster.title.toUpperCase(),
                        style: TextStyle(
                          color: cluster.type == MemoryClusterType.month 
                            ? Colors.white.withOpacity(0.4)
                            : Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                          letterSpacing: 1.2,
                        ),
                      ),
                      const Spacer(),
                      Text(
                        cluster.subtitle ?? '',
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.2),
                          fontSize: 10,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              // Cluster Grid
              SliverPadding(
                padding: const EdgeInsets.symmetric(horizontal: 12),
                sliver: SliverGrid(
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 2,
                    mainAxisSpacing: 8,
                    crossAxisSpacing: 8,
                    childAspectRatio: 0.75,
                  ),
                  delegate: SliverChildBuilderDelegate(
                    (context, index) {
                      final vibe = cluster.vibes[index];
                      // Infinite scroll trigger: only on the very last vibe of all clusters
                      if (vibe.id == paginatedState.vibes.last.id && 
                          !paginatedState.isLoading && 
                          paginatedState.hasMore) {
                        WidgetsBinding.instance.addPostFrameCallback((_) {
                          ref.read(paginatedVibesProvider(_isSentView).notifier).loadMore();
                        });
                      }
                      return _buildMemoryTile(vibe);
                    },
                    childCount: cluster.vibes.length,
                  ),
                ),
              ),
            ];
          }).expand((e) => e),
        
        // Loading indicator at bottom when fetching more
        if (paginatedState.isLoading && paginatedState.vibes.isNotEmpty)
          const SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.all(20),
              child: Center(
                child: SizedBox(
                  width: 24,
                  height: 24,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                    color: AppColors.primaryAction,
                  ),
                ),
              ),
            ),
          ),
        
        // Bottom padding for FAB / safe area
        const SliverToBoxAdapter(
          child: SizedBox(height: 120),
        ),
      ],
          );
        },
      ),
    );
  }

  Widget _buildSwipeDownHint() {
    return Padding(
      padding: const EdgeInsets.only(top: 8, bottom: 4),
      child: Center(
        child: Container(
          width: 40,
          height: 4,
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.15),
            borderRadius: BorderRadius.circular(2),
            boxShadow: [
              BoxShadow(
                color: AppColors.primaryAction.withOpacity(0.1),
                blurRadius: 4,
                spreadRadius: 1,
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildHeader({
    String? displayName,
    String? avatarUrl,
    required bool isPremium,
    required bool hasPremiumAccess,
  }) {
    final hour = DateTime.now().hour;
    String greeting;
    if (hour < 12) {
      greeting = 'Good Morning';
    } else if (hour < 17) {
      greeting = 'Good Afternoon';
    } else {
      greeting = 'Good Evening';
    }
    
    return Padding(
      padding: const EdgeInsets.fromLTRB(20, 16, 20, 16),
      child: Row(
        children: [
          // Profile avatar with online indicator
          Stack(
            children: [
              CustomPaint(
                painter: CircularLuminousBorderPainter(
                  strokeWidth: 2,
                  baseColor: Colors.white.withOpacity(0.1),
                ),
                child: Container(
                  width: 44,
                  height: 44,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    image: avatarUrl != null
                        ? DecorationImage(
                            image: NetworkImage(avatarUrl),
                            fit: BoxFit.cover,
                          )
                        : null,
                    gradient: avatarUrl == null
                        ? AppColors.auraGradient
                        : null,
                  ),
                  child: avatarUrl == null
                    ? Center(
                        child: Text(
                          displayName?.isNotEmpty == true
                              ? displayName![0].toUpperCase()
                              : 'V',
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      )
                    : null,
                ),
              ),
              // Online indicator
              Positioned(
                bottom: 0,
                right: 0,
                child: Container(
                  width: 14,
                  height: 14,
                  decoration: BoxDecoration(
                    color: AppColors.primaryAction,
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: AppColors.background,
                      width: 2,
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: AppColors.primaryAction.withOpacity(0.5),
                        blurRadius: 8,
                        spreadRadius: 2,
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(width: 12),
          // Greeting
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  greeting,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                    color: Colors.white.withOpacity(0.5),
                    letterSpacing: 1,
                  ),
                ),
                Row(
                  children: [
                    Text(
                      displayName ?? 'Nock User',
                      style: const TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    if (isPremium == true) ...[
                      const SizedBox(width: 8),
                      _buildBadge('PRO', AppColors.primaryAction),
                    ] else if (hasPremiumAccess == true) ...[
                      const SizedBox(width: 8),
                      _buildBadge('TRIAL', AppColors.secondaryAction),
                    ],
                  ],
                ),
              ],
            ),
          ),
          // Notifications button with unread count
          _buildNotificationButton(),
        ],
      ),
    );
  }

  Widget _buildBadge(String label, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(
          color: color.withOpacity(0.5),
          width: 0.5,
        ),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: color,
          fontSize: 8,
          fontWeight: FontWeight.w900,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildNotificationButton() {
    // Navigate to Squad Manager
    // PHASE 1 DEMO: Luminous border enabled to showcase Spatial Glass effect
    return GlassContainer(
      width: 44,
      height: 44,
      borderRadius: 22,
      padding: EdgeInsets.zero,
      useLuminousBorder: true, // ðŸŒŸ LUMINOUS ARCHITECTURE (Phase 1)
      onTap: () {
        HapticFeedback.lightImpact();
        context.push(AppRoutes.squadManager);
      },
      child: const Icon(Icons.people_outline, color: Colors.white, size: 22),
    );
  }



  /// Determines the current layout state based on content priority
  /// This enables the "Breathing Grid" - layout adapts to content type
  _BentoLayoutState _getLayoutState({
    required List<VibeModel> vibes,
    required List<UserModel> allFriends,
    required bool isFriendsLoading,  // FIX: Add loading state param
  }) {
    final heroVibe = vibes.isNotEmpty ? vibes.first : null;
    
    // Priority 1: Video gets cinematic full-width treatment
    if (heroVibe?.isVideo == true) {
      return _BentoLayoutState.videoHero;
    }
    
    // Priority 2: Photo/Voice vibe - standard layout
    if (heroVibe != null) {
      return _BentoLayoutState.standard;
    }
    
    // FIX: Priority 3 - Check loading state BEFORE empty state
    // This prevents FOUC (Flash of Unstyled Content)
    if (isFriendsLoading) {
      // Show loading skeleton while friends are loading
      return _BentoLayoutState.loading;
    }
    
    // Priority 4: No content at all - empty state (only after loading completes)
    if (allFriends.isEmpty) {
      return _BentoLayoutState.emptyNoFriends;
    }
    
    return _BentoLayoutState.emptyWithFriends;
  }

  Widget _buildBentoGrid({
    required List<VibeModel> vibes,
    required String? currentUserId,
    required List<UserModel> activeFriends,
    required List<UserModel> allFriends,
    required bool isFriendsLoading,  // FIX: Add loading parameter
  }) {
    final heroVibe = vibes.isNotEmpty ? vibes.first : null;
    final layoutState = _getLayoutState(
      vibes: vibes,
      allFriends: allFriends,
      isFriendsLoading: isFriendsLoading,  // FIX: Pass loading state
    );
    
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      switchInCurve: Curves.easeOutCubic,
      switchOutCurve: Curves.easeInCubic,
      child: _buildLayoutForState(
        key: ValueKey(layoutState),
        state: layoutState,
        heroVibe: heroVibe,
        activeFriends: activeFriends,
        allFriends: allFriends,
        currentUserId: currentUserId,
      ),
    );
  }

  Widget _buildLayoutForState({
    required Key key,
    required _BentoLayoutState state,
    required VibeModel? heroVibe,
    required List<UserModel> activeFriends,
    required List<UserModel> allFriends,
    required String? currentUserId,
  }) {
    switch (state) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE 0: LOADING - Show Skeleton
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case _BentoLayoutState.loading:
      return _buildBentoSkeleton();

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STATE 1: VIDEO HERO - Full-width cinematic mode
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      case _BentoLayoutState.videoHero:
        return Column(
          key: key,
          children: [
            // Full-width video hero (optimized 4:5 ratio for vertical social vibes)
          AspectRatio(
            aspectRatio: 4 / 5,  // Social-optimized vertical ratio (replaces 16:9 crop)
            child: _buildHeroTile(heroVibe, isFullWidth: true),
          ),
            const SizedBox(height: 8),
            // Status bar below video
            _buildStatusTile(activeFriends, allFriends, isCompact: true),
          ],
        );
      
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STATE 2: STANDARD - Classic bento grid (photo/voice)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    case _BentoLayoutState.standard:
      return Column(
        key: key,
        children: [
          AspectRatio(
            aspectRatio: 1.3,
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  flex: 65,
                  child: _buildHeroTile(heroVibe, isActive: true),
                ),
                const SizedBox(width: 8),
                Expanded(
                  flex: 35,
                  child: _buildStatusTile(activeFriends, allFriends),
                ),
              ],
            ),
          ),
          const SizedBox(height: 8),
        ],
      );

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STATE 4: EMPTY (No Friends) - Onboarding focused
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      case _BentoLayoutState.emptyNoFriends:
        return Column(
          key: key,
          children: [
            _buildEmptyStateNoFriends(),
          ],
        );
        
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // STATE 5: EMPTY (Has Friends, No Content) - Waiting for vibes
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      case _BentoLayoutState.emptyWithFriends:
        return Column(
          key: key,
          children: [
            AspectRatio(
              aspectRatio: 1.3,
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    flex: 65,
                    child: _buildEmptyHeroPlaceholder(),
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    flex: 35,
                    child: _buildStatusTile(activeFriends, allFriends),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 8),
          ],
        );
    }
  }

  Widget _buildEmptyStateNoFriends() {
    return AspectRatio(
      aspectRatio: 1.2,
      child: GlassContainer(
        padding: const EdgeInsets.all(24),
        useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous empty state
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: AppColors.primaryAction.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.waving_hand,
                size: 32,
                color: AppColors.primaryAction,
              ),
            ),
            const SizedBox(height: 16),
            const Text(
              'Welcome to Vibe!',
              style: TextStyle(
                color: Colors.white,
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Add friends to start sharing voice notes and photos.',
              textAlign: TextAlign.center,
              style: TextStyle(
                color: Colors.white.withOpacity(0.7),
                fontSize: 14,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Skeleton loader to prevent FOUC (Flash of Unstyled Content)
  Widget _buildBentoSkeleton() {
    return Column(
      children: [
        // Hero Skeleton
        AspectRatio(
          aspectRatio: 1.2,
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Large Tile
              Expanded(
                flex: 6,
                child: GlassContainer(
                    backgroundColor: Colors.white.withOpacity(0.05),
                    useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous skeleton
                    child: Center(
                       child: CircularProgressIndicator(color: Colors.white.withOpacity(0.2)),
                    ),
                ),
              ),
              const SizedBox(width: 8),
              // Side Column
              Expanded(
                flex: 4,
                child: Column(
                  children: [
                    Expanded(
                      child: GlassContainer(
                        backgroundColor: Colors.white.withOpacity(0.05),
                        useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous skeleton
                        child: const SizedBox(),
                      ),
                    ),
                    const SizedBox(height: 8),
                    Expanded(
                      child: GlassContainer(
                        backgroundColor: Colors.white.withOpacity(0.05),
                        useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous skeleton
                        child: const SizedBox(),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: 8),
        // Action Tile Skeleton
        SizedBox(
           height: 80,
           child: GlassContainer(
             backgroundColor: Colors.white.withOpacity(0.05),
             useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous skeleton
             child: const SizedBox(),
           ),
        ),
      ],
    );
  }


  /// Empty hero placeholder when waiting for vibes
  Widget _buildEmptyHeroPlaceholder() {
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(24),
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            const Color(0xFF111111),
            const Color(0xFF0D0D0D),
          ],
        ),
        border: Border.all(
          color: AppColors.primaryAction.withOpacity(0.1),
          width: 1,
        ),
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.photo_camera_outlined,
            color: Colors.white.withOpacity(0.2),
            size: 48,
          ),
          const SizedBox(height: 12),
          Text(
            'Waiting for vibes...',
            style: TextStyle(
              color: Colors.white.withOpacity(0.4),
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 4),
          Text(
            'Swipe right to send one!',
            style: TextStyle(
              color: AppColors.primaryAction.withOpacity(0.6),
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }

  /// Hero Tile - Latest vibe from a friend with live photo support
  /// [isFullWidth] - When true, optimized for full-width video display
  /// [isActive] - When true, shows the glowing Acid Green to Electric Cyan border
  Widget _buildHeroTile(VibeModel? vibe, {bool isFullWidth = false, bool isActive = false}) {
    return GestureDetector(
      onTap: () {
        if (vibe != null) {
          HapticFeedback.lightImpact();
          // SWIPE NAVIGATION: Pass vibes list for horizontal swipe through recent vibes
          final vibesList = ref.read(_heroVibesProvider(_isSentView)).valueOrNull ?? [];
          final startIndex = vibesList.indexWhere((v) => v.id == vibe.id);
          
          if (startIndex >= 0 && vibesList.length > 1) {
            context.push('/home/player/${vibe.id}', extra: {
              'vibe': vibe,
              'vibesList': vibesList,
              'startIndex': startIndex,
            });
          } else {
            // Fallback: single vibe (backwards compatible)
            context.push('/home/player/${vibe.id}', extra: vibe);
          }
        }
      },
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(24),
          color: const Color(0xFF111111),
          border: isActive ? Border.all(color: Colors.transparent, width: 2) : null,
        ),
        clipBehavior: Clip.antiAlias,
        child: Stack(
          fit: StackFit.expand,
          children: [
            // Gradient Border Background (Hero always pops)
            if (isActive)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(24),
                    gradient: LinearGradient(
                      begin: Alignment.topLeft,
                      end: Alignment.bottomRight,
                      colors: [
                        AppColors.primaryAction,
                        AppColors.telemetry,
                      ],
                    ),
                  ),
                ),
              ),
            
            // Inner content container (clipping for border)
            Positioned.fill(
              child: Container(
                margin: EdgeInsets.all(isActive ? 2 : 0),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(22),
                  color: const Color(0xFF111111),
                ),
                clipBehavior: Clip.antiAlias,
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    // Background image
                    if (vibe?.imageUrl != null)
                      CachedNetworkImage(
                        imageUrl: vibe!.imageUrl!,
                        fit: BoxFit.cover,
                        placeholder: (_, __) => Container(
                          color: AppColors.background,
                          child: Center(
                            child: Icon(
                              Icons.image_outlined,
                              color: Colors.white.withOpacity(0.2),
                              size: 48,
                            ),
                          ),
                        ),
                        errorWidget: (_, __, ___) => Container(
                          color: AppColors.background,
                          child: _buildEmptyHeroContent(),
                        ),
                      )
                    else
                      Container(
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            begin: Alignment.topLeft,
                            end: Alignment.bottomRight,
                            colors: vibe?.isAudioOnly == true 
                                ? [AppColors.primaryAction.withOpacity(0.4), AppColors.secondaryAction.withOpacity(0.4)]
                                : [AppColors.primaryAction.withOpacity(0.2), AppColors.secondaryAction.withOpacity(0.2)],
                          ),
                        ),
                        child: vibe?.isAudioOnly == true 
                            ? _buildAudioOnlyHeroContent(vibe)
                            : _buildEmptyHeroContent(),
                      ),
                    
                    // Gradient overlay
                    Container(
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          begin: Alignment.topCenter,
                          end: Alignment.bottomCenter,
                          colors: [
                            Colors.transparent,
                            Colors.transparent,
                            Colors.black.withOpacity(0.7),
                          ],
                          stops: const [0.0, 0.5, 1.0],
                        ),
                      ),
                    ),
                    
                    // Timestamp pill
                    if (vibe != null)
                      Positioned(
                        top: 12,
                        left: 12,
                        child: Container(
                          padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                          decoration: BoxDecoration(
                            color: Colors.white.withOpacity(0.08),
                            borderRadius: BorderRadius.circular(20),
                            border: Border.all(color: Colors.white.withOpacity(0.1)),
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              AnimatedBuilder(
                                animation: _pulseController,
                                builder: (context, child) {
                                  return Container(
                                    width: 6,
                                    height: 6,
                                    decoration: BoxDecoration(
                                      color: Color.lerp(
                                        const Color(0xFF39FF14),
                                        const Color(0xFF39FF14).withOpacity(0.3),
                                        _pulseController.value,
                                      ),
                                      shape: BoxShape.circle,
                                    ),
                                  );
                                },
                              ),
                              const SizedBox(width: 6),
                              Text(
                                _formatTimeAgo(vibe.createdAt),
                                style: const TextStyle(
                                  color: Colors.white,
                                  fontSize: 10,
                                  fontWeight: FontWeight.bold,
                                  letterSpacing: 0.5,
                                ),
                              ),
                              if (vibe.isVideo) ...[
                                const SizedBox(width: 6),
                                Container(
                                  width: 1,
                                  height: 10,
                                  color: Colors.white.withOpacity(0.2),
                                ),
                                const SizedBox(width: 6),
                                const Icon(Icons.videocam, color: Colors.white, size: 10),
                              ],
                              if (vibe.replyVibeId != null) ...[
                                const SizedBox(width: 6),
                                const Icon(Icons.reply, color: AppColors.primaryAction, size: 10),
                              ],
                            ],
                          ),
                        ),
                      ),
                    
                    // Metadata Overlay (Gen Z Inspired: Consolidate to Bottom-Left)
                    if (vibe != null)
                      Positioned(
                        bottom: 16,
                        left: 16,
                        right: 16,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              vibe.senderName,
                              style: const TextStyle(
                                color: Colors.white,
                                fontSize: 18,
                                fontWeight: FontWeight.w900,
                                letterSpacing: -0.5,
                                shadows: [
                                  Shadow(
                                    color: Colors.black26,
                                    offset: Offset(0, 2),
                                    blurRadius: 4,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }


  Widget _buildAudioOnlyHeroContent(VibeModel? vibe) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.1),
              shape: BoxShape.circle,
            ),
            child: const Icon(
              Icons.mic,
              color: Colors.white,
              size: 40,
            ),
          ),
          const SizedBox(height: 12),
          const Text(
            'AUDIO VIBE',
            style: TextStyle(
              color: Colors.white,
              fontSize: 12,
              fontWeight: FontWeight.w900,
              letterSpacing: 2,
            ),
          ),
          if (vibe != null) ...[
            const SizedBox(height: 4),
            Text(
              '${vibe.audioDuration}s recorded',
              style: TextStyle(
                color: Colors.white.withOpacity(0.6),
                fontSize: 10,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildEmptyHeroContent() {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(
            Icons.photo_camera_outlined,
            color: Colors.white.withOpacity(0.3),
            size: 48,
          ),
          const SizedBox(height: 12),
          Text(
            'No vibes yet',
            style: TextStyle(
              color: Colors.white.withOpacity(0.5),
              fontSize: 14,
            ),
          ),
          const SizedBox(height: 4),
          GestureDetector(
            onTap: () => context.push(AppRoutes.addFriends),
            child: Text(
              'Add friends to see their vibes',
              style: TextStyle(
                color: AppColors.primaryAction.withOpacity(0.8),
                fontSize: 12,
                decoration: TextDecoration.underline,
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Status Tile - Shows active friends
  /// [isCompact] - Smaller version for video hero layout
  Widget _buildStatusTile(List<UserModel> activeFriends, List<UserModel> allFriends, {bool isCompact = false}) {
    final isAnybodyOnline = activeFriends.isNotEmpty;
    final displayFriend = activeFriends.isNotEmpty 
        ? activeFriends.first 
        : (allFriends.isNotEmpty ? allFriends.first : null);
    
    return Container(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(24),
        color: const Color(0xFF111111),
        border: Border.all(color: Colors.white.withOpacity(0.05)),
      ),
      clipBehavior: Clip.antiAlias,
      child: Stack(
        children: [
          // Background gradient
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                gradient: RadialGradient(
                  colors: [
                    (isAnybodyOnline 
                        ? const Color(0xFF39FF14) 
                        : const Color(0xFFFF6B35)).withOpacity(0.3),
                    const Color(0xFF4ECDC4).withOpacity(0.2),
                    Colors.transparent,
                  ],
                  radius: 1.5,
                ),
              ),
            ),
          ),
          // Content
          Padding(
            padding: EdgeInsets.all(isCompact ? 10 : 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    // Friend avatar or icon
                    Container(
                      width: isCompact ? 28 : 32,
                      height: isCompact ? 28 : 32,
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(8),
                        color: displayFriend?.avatarUrl == null 
                            ? AppColors.primaryAction 
                            : null,
                        image: displayFriend?.avatarUrl != null
                            ? DecorationImage(
                                image: NetworkImage(displayFriend!.avatarUrl!),
                                fit: BoxFit.cover,
                              )
                            : null,
                        boxShadow: [
                          BoxShadow(
                            color: (isAnybodyOnline 
                                ? const Color(0xFF39FF14) 
                                : const Color(0xFFFF6B35)).withOpacity(0.3),
                            blurRadius: 8,
                          ),
                        ],
                      ),
                      child: displayFriend?.avatarUrl == null
                          ? Center(
                              child: Icon(
                                isAnybodyOnline ? Icons.person : Icons.person_outline,
                                color: Colors.white,
                                size: isCompact ? 14 : 16,
                              ),
                            )
                          : null,
                    ),
                    // Status indicator (Ambient Glowing Border on Avatar handles this now)
                    if (isAnybodyOnline)
                      Container(
                        width: 8,
                        height: 8,
                        decoration: const BoxDecoration(
                          color: AppColors.primaryAction,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: AppColors.primaryAction,
                              blurRadius: 4,
                              spreadRadius: 1,
                            ),
                          ],
                        ),
                      )
                    else
                      Icon(
                        Icons.circle_outlined,
                        color: Colors.white.withOpacity(0.3),
                        size: isCompact ? 14 : 16,
                      ),
                  ],
                ),
                // Compact display friend info
                Row(
                  children: [
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            displayFriend?.displayName ?? 'No friends yet',
                            style: TextStyle(
                              fontSize: isCompact ? 12 : 14,
                              fontWeight: FontWeight.w900,
                              color: Colors.white,
                              letterSpacing: -0.2,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }


  String _formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final diff = now.difference(dateTime);
    
    if (diff.inMinutes < 1) return 'now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    return '${(diff.inDays / 7).floor()}w ago';
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // NARRATIVE ENGINE: Flashbacks & Clusters (Merged from Vault)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  /// "On This Day" - Memories from this date in previous years
  List<VibeModel> _getFlashbacks(List<VibeModel> vibes) {
    final now = DateTime.now();
    return vibes.where((vibe) {
      final created = vibe.createdAt;
      return created.month == now.month && 
             created.day == now.day &&
             created.year != now.year;
    }).toList();
  }

  /// Flashback section - "On This Day" memories (Horizontal Reel)
  Widget _buildFlashbackSection(List<VibeModel> flashbacks) {
    if (flashbacks.isEmpty) return const SizedBox.shrink();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 24, 16, 12),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(6),
                decoration: BoxDecoration(
                  gradient: const LinearGradient(
                    colors: [AppColors.primaryAction, AppColors.secondaryAction],
                  ),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: const Icon(Icons.auto_awesome, color: Colors.black, size: 16),
              ),
              const SizedBox(width: 10),
              const Text(
                'ON THIS DAY',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 12,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 1.2,
                ),
              ),
            ],
          ),
        ),
        SizedBox(
          height: 180,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            padding: const EdgeInsets.symmetric(horizontal: 16),
            itemCount: flashbacks.length,
            itemBuilder: (context, index) => _buildFlashbackCard(flashbacks[index]),
          ),
        ),
      ],
    );
  }

  Widget _buildFlashbackCard(VibeModel vibe) {
    final yearsAgo = DateTime.now().year - vibe.createdAt.year;
    
    return GestureDetector(
      onTap: () => context.push('${AppRoutes.player}/${vibe.id}', extra: vibe),
      child: Container(
        width: 140,
        margin: const EdgeInsets.only(right: 12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(20),
          color: Colors.white.withOpacity(0.05),
        ),
        clipBehavior: Clip.antiAlias,
        child: Stack(
          fit: StackFit.expand,
          children: [
            if (vibe.imageUrl != null)
              CachedNetworkImage(
                imageUrl: vibe.imageUrl!,
                fit: BoxFit.cover,
                memCacheWidth: 300,
              )
            else
              Container(
                decoration: BoxDecoration(
                  gradient: AppColors.auraGradient,
                ),
                child: const Center(child: Icon(Icons.mic, color: Colors.white24, size: 40)),
              ),
            
            // Years ago badge
            Positioned(
              top: 10,
              left: 10,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: AppColors.primaryAction,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  '$yearsAgo ${yearsAgo == 1 ? 'Year' : 'Years'} Ago',
                  style: const TextStyle(
                    color: Colors.black,
                    fontSize: 9,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
            
            // Info bottom
            Positioned(
              bottom: 0,
              left: 0,
              right: 0,
              child: Container(
                padding: const EdgeInsets.all(10),
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    begin: Alignment.topCenter,
                    end: Alignment.bottomCenter,
                    colors: [Colors.transparent, Colors.black.withOpacity(0.8)],
                  ),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      vibe.senderName,
                      style: const TextStyle(color: Colors.white, fontSize: 11, fontWeight: FontWeight.bold),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    Text(
                      DateFormat('MMM d, yyyy').format(vibe.createdAt),
                      style: TextStyle(color: Colors.white.withOpacity(0.6), fontSize: 9),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Group vibes into narrative clusters (Merged from Vault)
  List<MemoryCluster> _buildMemoryClusters(List<VibeModel> vibes) {
    if (vibes.isEmpty) return [];
    
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final yesterday = today.subtract(const Duration(days: 1));
    final weekAgo = today.subtract(const Duration(days: 7));
    
    final grouped = <String, List<VibeModel>>{};
    
    for (final vibe in vibes) {
      final createdDate = DateTime(vibe.createdAt.year, vibe.createdAt.month, vibe.createdAt.day);
      String key;
      
      if (createdDate == today) {
        key = 'Today';
      } else if (createdDate == yesterday) {
        key = 'Yesterday';
      } else if (createdDate.isAfter(weekAgo)) {
        key = 'This Week';
      } else {
        key = DateFormat('MMMM yyyy').format(vibe.createdAt);
      }
      
      grouped.putIfAbsent(key, () => []);
      grouped[key]!.add(vibe);
    }
    
    return grouped.entries.map((entry) {
      final type = entry.key == 'Today' ? MemoryClusterType.today :
                   entry.key == 'Yesterday' ? MemoryClusterType.yesterday :
                   entry.key == 'This Week' ? MemoryClusterType.thisWeek :
                   MemoryClusterType.month;
                   
      return MemoryCluster(
        title: entry.key,
        subtitle: '${entry.value.length} memories',
        startDate: entry.value.last.createdAt,
        endDate: entry.value.first.createdAt,
        vibes: entry.value,
        type: type,
      );
    }).toList();
  }

  LinearGradient _getClusterGradient(MemoryClusterType type) {
    switch (type) {
      case MemoryClusterType.flashback:
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [AppColors.telemetry, AppColors.primaryAction],
        );
      case MemoryClusterType.today:
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [AppColors.primaryAction, AppColors.secondaryAction],
        );
      case MemoryClusterType.yesterday:
        return const LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [AppColors.telemetry, Color(0xFF0055FF)],
        );
      case MemoryClusterType.thisWeek:
        return LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [AppColors.urgency, AppColors.urgency.withOpacity(0.5)],
        );
      case MemoryClusterType.month:
        return LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [const Color(0xFF111111), const Color(0xFF111111)],
        );
    }
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HYBRID DASHBOARD: Memories Section Header
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  Widget _buildMemoriesHeader() {
    return Container(
      padding: const EdgeInsets.fromLTRB(16, 24, 16, 12),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(6),
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(
              Icons.grid_view_rounded,
              color: Colors.white.withOpacity(0.7),
              size: 16,
            ),
          ),
          const SizedBox(width: 10),
          Text(
            _isSentView ? 'MY SENT VIBES' : 'YOUR MEMORIES',
            style: AppTypography.retroTag.copyWith(
              color: AppColors.textPrimary.withOpacity(0.7),
              fontSize: 12,
            ),
          ),
          const Spacer(),
          // ðŸ”˜ Cyber-Minimalist Segmented Control
          _buildSegmentedControl(),
        ],
      ),
    );
  }

  Widget _buildSegmentedControl() {
    return Container(
      height: 32,
      padding: const EdgeInsets.all(2),
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.05),
        borderRadius: BorderRadius.circular(10),
        border: Border.all(color: Colors.white.withOpacity(0.1)),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildSegmentItem(
            label: 'For Me',
            isActive: !_isSentView,
            onTap: () => setState(() => _isSentView = false),
          ),
          _buildSegmentItem(
            label: 'By Me',
            isActive: _isSentView,
            onTap: () => setState(() => _isSentView = true),
          ),
        ],
      ),
    );
  }

  Widget _buildSegmentItem({
    required String label,
    required bool isActive,
    required VoidCallback onTap,
  }) {
    return GestureDetector(
      onTap: () {
        if (!isActive) {
          HapticFeedback.lightImpact();
          onTap();
        }
      },
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutCubic,
        padding: const EdgeInsets.symmetric(horizontal: 12),
        alignment: Alignment.center,
        decoration: BoxDecoration(
          color: isActive ? Colors.white.withOpacity(0.1) : Colors.transparent,
          borderRadius: BorderRadius.circular(8),
          boxShadow: isActive ? [
            BoxShadow(
              color: Colors.white.withOpacity(0.05),
              blurRadius: 4,
              offset: const Offset(0, 2),
            )
          ] : null,
        ),
        child: Text(
          label,
          style: TextStyle(
            fontSize: 10,
            fontWeight: isActive ? FontWeight.bold : FontWeight.w500,
            color: isActive ? Colors.white : Colors.white.withOpacity(0.4),
          ),
        ),
      ),
    );
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HYBRID DASHBOARD: Memory Tile Builder
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  Widget _buildMemoryTile(VibeModel vibe) {
    final user = ref.watch(currentUserProvider).valueOrNull;
    final isPremium = user?.hasPremiumAccess ?? false;
    final isLocked = !isPremium && 
                     !_isSentView && // Sent vibes are always accessible
                     DateTime.now().difference(vibe.createdAt).inHours > AppConstants.freeHistoryHours;
    
    final isVideo = vibe.isVideo;
    final hasAudio = vibe.audioUrl.isNotEmpty && vibe.imageUrl == null;
    
    return GestureDetector(
      onTap: () {
        HapticFeedback.lightImpact();
        if (isLocked) {
          context.push(AppRoutes.subscription);
        } else {
          context.push('${AppRoutes.player}/${vibe.id}');
        }
      },
      child: Container(
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(16),
          color: AppColors.surface,
          border: Border.all(color: Colors.white.withOpacity(0.05)),
        ),
        clipBehavior: Clip.antiAlias,
        child: Stack(
          fit: StackFit.expand,
          children: [
            // Media content with Blur if locked
            if (isLocked)
              Positioned.fill(
                child: ImageFiltered(
                  imageFilter: ColorFilter.mode(
                    Colors.black.withOpacity(0.3),
                    BlendMode.darken,
                  ),
                  child: ImageFiltered(
                    imageFilter: ui.ImageFilter.blur(sigmaX: 10, sigmaY: 10),
                    child: _buildMediaContent(vibe, hasAudio),
                  ),
                ),
              )
            else
              _buildMediaContent(vibe, hasAudio),
              
              // Video indicator
              if (isVideo && !isLocked)
                Positioned(
                  top: 8,
                  right: 8,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.6),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.play_arrow, color: Colors.white, size: 12),
                        const SizedBox(width: 2),
                        Text(
                          _formatDuration(vibe.audioDuration),
                          style: const TextStyle(
                            color: Colors.white,
                            fontSize: 10,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

              // Lock Icon Overlay
              if (isLocked)
                Positioned.fill(
                  child: Center(
                    child: Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.4),
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: Colors.white.withOpacity(0.2),
                          width: 1,
                        ),
                      ),
                      child: const Icon(
                        Icons.lock_outline_rounded,
                        color: Colors.white,
                        size: 24,
                      ),
                    ),
                  ),
                ),
              
              // Bottom gradient with sender info
              Positioned(
                bottom: 0,
                left: 0,
                right: 0,
                child: Container(
                  padding: const EdgeInsets.all(10),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: [
                        Colors.transparent,
                        Colors.black.withOpacity(0.7),
                      ],
                    ),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        vibe.senderName,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 12,
                          fontWeight: FontWeight.w600,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      Text(
                        _formatTimeAgo(vibe.createdAt),
                        style: TextStyle(
                          color: Colors.white.withOpacity(0.6),
                          fontSize: 10,
                        ),
                      ),
                      if (vibe.reactions.isNotEmpty) ...[
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            Text(
                              vibe.reactions.first.emoji,
                              style: const TextStyle(fontSize: 10),
                            ),
                            if (vibe.reactions.length > 1) ...[
                              const SizedBox(width: 2),
                              Text(
                                '+${vibe.reactions.length - 1}',
                                style: TextStyle(
                                  color: Colors.white.withOpacity(0.5),
                                  fontSize: 9,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ],
                          ],
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              
              // Unplayed indicator
              if (!vibe.isPlayed)
                Positioned(
                  top: 8,
                  left: 8,
                  child: Container(
                    width: 8,
                    height: 8,
                    decoration: BoxDecoration(
                      color: AppColors.primaryAction,
                      shape: BoxShape.circle,
                      boxShadow: [
                        BoxShadow(
                          color: AppColors.primaryAction.withOpacity(0.5),
                          blurRadius: 6,
                          spreadRadius: 1,
                        ),
                      ],
                    ),
                  ),
                ),
          ],
        ),
      ),
    );
  }
  
  String _formatDuration(int seconds) {
    final mins = seconds ~/ 60;
    final secs = seconds % 60;
    return '$mins:${secs.toString().padLeft(2, '0')}';
  }

  Widget _buildEmptyMemoriesState() {
    final user = ref.watch(currentUserProvider).valueOrNull;
    final isExpired = user != null && !user.hasPremiumAccess;

    return Container(
      padding: const EdgeInsets.all(40),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Container(
            width: 80,
            height: 80,
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.05),
              shape: BoxShape.circle,
            ),
            child: Icon(
              isExpired ? Icons.lock_outline : Icons.photo_library_outlined,
              size: 36,
              color: isExpired ? AppColors.secondaryAction.withOpacity(0.5) : Colors.white.withOpacity(0.3),
            ),
          ),
          const SizedBox(height: 16),
          Text(
            isExpired ? 'Unlock Your Vault' : 'No memories yet',
            style: TextStyle(
              color: Colors.white.withOpacity(0.7),
              fontSize: 16,
              fontWeight: FontWeight.w600,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            isExpired 
                ? 'Your 7-day trial has ended. Subscribe to VIBE+ to see your full history and unlock the Vault.'
                : 'Vibes from your friends will appear here',
            style: TextStyle(
              color: Colors.white.withOpacity(0.4),
              fontSize: 13,
            ),
            textAlign: TextAlign.center,
          ),
          if (isExpired) ...[
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => context.push(AppRoutes.subscription),
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.secondaryAction,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
              child: const Text('Upgrade to VIBE+'),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildMediaContent(VibeModel vibe, bool hasAudio) {
    if (vibe.imageUrl != null) {
      return CachedNetworkImage(
        imageUrl: vibe.imageUrl!,
        fit: BoxFit.cover,
        memCacheWidth: 400,
        placeholder: (_, __) => Container(
          color: Colors.white.withOpacity(0.05),
          child: const Center(
            child: CircularProgressIndicator(
              strokeWidth: 2,
              color: AppColors.primaryAction,
            ),
          ),
        ),
        errorWidget: (_, __, ___) => Container(
          color: Colors.white.withOpacity(0.05),
          child: const Icon(Icons.broken_image, color: Colors.white24),
        ),
      );
    } else if (hasAudio) {
      return Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topLeft,
            end: Alignment.bottomRight,
            colors: [
              AppColors.primaryAction.withOpacity(0.3),
              AppColors.secondaryAction.withOpacity(0.3),
            ],
          ),
        ),
        child: Center(
          child: Icon(
            Icons.mic,
            size: 32,
            color: Colors.white.withOpacity(0.7),
          ),
        ),
      );
    } else {
      return Container(
        color: Colors.white.withOpacity(0.05),
        child: Center(
          child: Text(
            vibe.senderName.isNotEmpty ? vibe.senderName[0].toUpperCase() : '?',
            style: TextStyle(
              fontSize: 32,
              fontWeight: FontWeight.bold,
              color: Colors.white.withOpacity(0.3),
            ),
          ),
        ),
      );
    }
  }
}



========================================

FILE #54: E:\Vive\lib\features\home\presentation\home_screen.dart

========================================


import 'dart:async';
import 'dart:io';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/foundation.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:home_widget/home_widget.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/services/fcm_token_service.dart';
import 'package:nock/core/services/widget_update_service.dart';
import 'package:nock/core/models/user_model.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/features/camera/presentation/camera_screen_new.dart';
import 'package:nock/features/home/presentation/bento_dashboard_screen.dart';
import 'package:collection/collection.dart';
import 'package:nock/core/providers/vibe_upload_provider.dart';
import 'package:nock/core/providers/deep_link_provider.dart';


/// Home Screen - 2025 Modern UI/UX
/// 
/// Navigation Model:
/// - Swipe UP: History/Dashboard (social hub)
/// - Default: Camera (camera-first)
/// - Settings: Modal overlay (not a full page)
/// 
/// Vertical swipe navigation with "History" indicator at bottom.
class HomeScreen extends ConsumerStatefulWidget {
  const HomeScreen({super.key});

  @override
  ConsumerState<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends ConsumerState<HomeScreen>
    with SingleTickerProviderStateMixin, WidgetsBindingObserver {
  
  // 0: Camera (default), 1: Dashboard (swipe up)
  final PageController _pageController = PageController(initialPage: 0);
  int _currentPage = 0;
  bool _isUpdatingAvatar = false;

  
  // FIX: Edge Guard + Drawing Mode Lock for Gesture Conflict
  ScrollPhysics _pagePhysics = const BouncingScrollPhysics(parent: PageScrollPhysics());
  bool _isDrawingMode = false; // Locks page swipe when camera is in drawing mode
  bool _isCameraActive = false; // Hides history indicator when camera is recording/captured
  Timer? _statusHeartbeat; // Heartbeat to keep user online
  StreamSubscription? _widgetClickedSubscription; // FIX: Memory Leak - Store for cancellation
  
  // REACTIVE SYNC FIX: Static guard to prevent multiple syncs per session
  // This replaces the race-prone main.dart sync that used authStateChanges().first
  static String? _lastSyncedUserId;

  @override
  void initState() {
    super.initState();
    
    // Immersive status bar
    SystemChrome.setSystemUIOverlayStyle(
      const SystemUiOverlayStyle(
        statusBarColor: Colors.transparent,
        statusBarIconBrightness: Brightness.light,
        systemNavigationBarColor: AppColors.voidNavy,
        systemNavigationBarIconBrightness: Brightness.light,
      ),
    );

    // Immersive status bar removed listener as _pageOffset is no longer needed

    // FIX: Add lifecycle observer to track app state (online/offline)
    WidgetsBinding.instance.addObserver(this);

    // Initialize services
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(authServiceProvider).updateUserStatus(UserStatus.online);
      ref.read(fcmTokenServiceProvider).initialize();
      _handleWidgetLaunch();
      
      // FIX 2024-12-25: REMOVED ref.listen from here!
      // ref.listen CANNOT be used in addPostFrameCallback/initState
      // It MUST be in build() - moved to build() method below line 204
      
      // FIX 1: Heartbeat - Keep user online while app is active
      // Prevents "False Offline" bug where user disappears after 5 min
      _statusHeartbeat = Timer.periodic(const Duration(minutes: 2), (timer) {
        if (WidgetsBinding.instance.lifecycleState == AppLifecycleState.resumed) {
          ref.read(authServiceProvider).updateUserStatus(UserStatus.online);
          debugPrint('HomeScreen: Heartbeat - updated status to online');
        }
      });
    });

  }

  /// FIX: Handle app lifecycle changes to update user online status
  /// This fixes the "Ghost User" bug where users appear online indefinitely
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    
    switch (state) {
      case AppLifecycleState.resumed:
        // App came to foreground - set online
        ref.read(authServiceProvider).updateUserStatus(UserStatus.online);
        debugPrint('HomeScreen: App resumed - set status to online');
        break;
      case AppLifecycleState.paused:
      case AppLifecycleState.inactive:
      case AppLifecycleState.detached:
      case AppLifecycleState.hidden:
        // App went to background or closed - set offline
        ref.read(authServiceProvider).updateUserStatus(UserStatus.offline);
        debugPrint('HomeScreen: App paused/detached - set status to offline');
        break;
    }
  }


  /// Edge Guard: Lock PageView when camera is in drawing mode OR active state
  /// This prevents vertical drawings/swipes from triggering page navigation during recording/capture

  Future<void> _handleWidgetLaunch() async {
    try {
      final initialUri = await HomeWidget.initiallyLaunchedFromHomeWidget();
      if (initialUri != null) {
        _handleWidgetUri(initialUri);
      }
      
      _widgetClickedSubscription = HomeWidget.widgetClicked.listen((uri) {
        if (uri != null) {
          _handleWidgetUri(uri);
        }
      });
    } catch (e) {
      debugPrint('HomeScreen: Error handling widget launch: $e');
    }
  }

  void _handleWidgetUri(Uri uri) {
    debugPrint('HomeScreen: Widget clicked with URI: $uri');
    final vibeId = uri.queryParameters['vibeId'];
    if (vibeId != null && vibeId.isNotEmpty && mounted) {
      // FIX Issue 8: Use pushReplacement to prevent back-stack accumulation
      // When users repeatedly click widgets, this ensures Back always goes to Home
      context.pushReplacement('${AppRoutes.player}/$vibeId');
    }
  }

  @override
  void dispose() {
    // Remove lifecycle observer
    WidgetsBinding.instance.removeObserver(this);
    
    // Note: Don't use ref.read() in dispose - widget may already be unmounted
    // The status will be set to offline automatically when user logs out
    // or when the app is backgrounded (handled in didChangeAppLifecycleState)
    
    _statusHeartbeat?.cancel();
    _widgetClickedSubscription?.cancel(); // FIX: Memory Leak - Cancel subscription
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // REACTIVE SYNC FIX: Listen to auth changes and sync read receipts
    // This fixes the race condition in main.dart where authStateChanges().first
    // could timeout on slow devices, causing read receipts to never sync.
    //
    // Why this works:
    // 1. Zero-Blocking: App launches instantly, sync happens in background
    // 2. Guaranteed Auth: Only syncs when user is confirmed authenticated
    // 3. Self-Healing: Re-syncs on re-login or account switch
    ref.listen<AsyncValue<UserModel?>>(currentUserProvider, (previous, next) {
      next.whenData((user) {
        // Only sync if we have a user AND haven't synced for this user yet
        if (user != null && _lastSyncedUserId != user.id) {
          _lastSyncedUserId = user.id;
          debugPrint('ðŸ”„ Auth detected: Syncing read receipts for ${user.id}...');
          WidgetUpdateService.syncPendingReadReceipts(user.id);
        }
      });
    });
    
    // FIX 2024-12-25: Handle pending invites (moved from initState)
    // Use activeInviteProvider to respect session-level dismissals
    ref.listen<String?>(activeInviteProvider, (previous, next) {
      if (next != null && mounted) {
        final target = '/home/invite/$next';
        
        if (GoRouterState.of(context).matchedLocation == target) {
          debugPrint('HomeScreen: Already at invite target, skipping context.go');
          return;
        }

        debugPrint('HomeScreen: Active invite detected: $next');
        context.go(target);
        
        // Use dismiss() instead of clearPendingInvite() to avoid losing 
        // the invite from storage if the user just wants to browse.
        ref.read(pendingInviteProvider.notifier).dismiss();
      }
    });

    // ðŸ“¤ VIBE UPLOAD FEEDBACK LISTENER (Global success/error)
    ref.listen<List<VibeUploadTask>>(vibeUploadProvider, (previous, next) {
      // Check for tasks that transitioned to success or error in the 'next' state
      for (final task in next) {
        final prevTask = previous?.firstWhereOrNull((t) => t.id == task.id);
        
        // Transition to SUCCESS
        if (task.status == VibeUploadStatus.success && prevTask?.status != VibeUploadStatus.success) {
          debugPrint('ðŸ [HomeScreen] Vibe upload success feedback');
          HapticFeedback.lightImpact();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Row(
                children: [
                   const Icon(Icons.check_circle, color: AppColors.primaryAction, size: 20),
                   const SizedBox(width: 12),
                   Text(task.isAudioOnly ? 'Audio vibe sent!' : 'Vibe sent!', style: const TextStyle(fontWeight: FontWeight.bold)),
                ],
              ),
              backgroundColor: const Color(0xFF1E1E1E),
              behavior: SnackBarBehavior.floating,
              duration: const Duration(seconds: 2),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
            ),
          );
        }
        
        // Transition to ERROR
        if (task.status == VibeUploadStatus.error && prevTask?.status != VibeUploadStatus.error) {
          debugPrint('âŒ [HomeScreen] Vibe upload error feedback: ${task.error}');
          HapticFeedback.vibrate();
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Row(
                children: [
                   const Icon(Icons.error_outline, color: AppColors.error, size: 20),
                   const SizedBox(width: 12),
                   Expanded(child: Text('Failed to send: ${task.error ?? "Unknown error"}')),
                ],
              ),
              backgroundColor: const Color(0xFF1E1E1E),
              behavior: SnackBarBehavior.floating,
              duration: const Duration(seconds: 4),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              action: SnackBarAction(
                label: 'Retry',
                textColor: AppColors.primaryAction,
                onPressed: () {
                   // VibeUploadNotifier handles auto-retry logic or we can trigger it
                },
              ),
            ),
          );
        }
      }
    });
    
    return Scaffold(
      backgroundColor: AppColors.voidNavy,
      body: Stack(
        children: [
          // Main VERTICAL navigation (swipe up for dashboard)
            PageView(
                controller: _pageController,
                scrollDirection: Axis.vertical, // Vertical swipe!
                physics: _pagePhysics,
                onPageChanged: (page) {
                  setState(() => _currentPage = page);
                  HapticFeedback.selectionClick();
                },
                children: [
                  // Page 0: Camera (Default - top)
                  CameraScreenNew(
                    key: const ValueKey('camera_screen_main'),
                    onOpenVault: _openVaultSheet,
                    onOpenSettings: _openSettingsSheet,
                    isVisible: _currentPage == 0,
                    onDrawingModeChanged: (isDrawing) {
                      // Lock/unlock PageView based on drawing mode
                      setState(() {
                        _isDrawingMode = isDrawing;
                        _pagePhysics = (isDrawing || _isCameraActive)
                            ? const NeverScrollableScrollPhysics()
                            : const BouncingScrollPhysics(parent: PageScrollPhysics());
                      });
                    },
                    onCaptureStateChanged: (isActive) {
                      // Hide/show history indicator based on camera state
                      setState(() {
                        _isCameraActive = isActive;
                        _pagePhysics = (_isDrawingMode || isActive)
                            ? const NeverScrollableScrollPhysics()
                            : const BouncingScrollPhysics(parent: PageScrollPhysics());
                      });
                    },
                  ),
                  
                  // Page 1: Bento Dashboard (Swipe UP to see)
                  BentoDashboardScreen(
                    onNavigateBack: () {
                      // Navigate back to camera (page 0)
                      _pageController.animateToPage(
                        0,
                        duration: const Duration(milliseconds: 300),
                        curve: Curves.easeOut,
                      );
                    },
                  ),
                ],
              ),

          // History indicator (only on camera page AND when camera is idle)
          if (_currentPage == 0 && !_isCameraActive)
            _buildHistoryIndicator(),
        ],
      ),
    );
  }

  /// History indicator at bottom of camera - tap or swipe up to see history
  Widget _buildHistoryIndicator() {
    // FIX: Respect iOS home indicator area on iPhone X+
    final bottomSafeArea = MediaQuery.of(context).viewPadding.bottom;
    
    return Positioned(
      bottom: 8 + bottomSafeArea, // Position above safe area + gesture bar
      left: 0,
      right: 0,
      child: GestureDetector(
        onTap: () {
          // Animate to dashboard page
          _pageController.animateToPage(
            1,
            duration: const Duration(milliseconds: 300),
            curve: Curves.easeOut,
          );
        },
        onVerticalDragEnd: (details) {
          // Swipe up gesture
          if (details.primaryVelocity != null && details.primaryVelocity! < -200) {
            _pageController.animateToPage(
              1,
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeOut,
            );
          }
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'History',
              style: AppTypography.labelLarge.copyWith(
                color: Colors.white.withAlpha(180),
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: 4),
            Icon(
              Icons.keyboard_arrow_up,
              color: Colors.white.withAlpha(120),
              size: 24,
            ),
          ],
        ),
      ),
    );
  }

  /// Open Vault as a bottom sheet (thumb accessible)
  void _openVaultSheet() {
    HapticFeedback.mediumImpact();
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.9,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (context, controller) => Container(
          decoration: const BoxDecoration(
            color: AppColors.background,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: Column(
            children: [
              // Handle
              Container(
                margin: const EdgeInsets.only(top: 12),
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.white.withAlpha(76),
                  borderRadius: BorderRadius.circular(2),
                ),
              ),
              // Header
              Padding(
                padding: const EdgeInsets.all(16),
                child: Row(
                  children: [
                    Text('Memories', style: AppTypography.headlineMedium),
                    const Spacer(),
                    IconButton(
                      onPressed: () => Navigator.pop(context),
                      icon: const Icon(Icons.close, color: AppColors.textSecondary),
                    ),
                  ],
                ),
              ),
              // Vault content placeholder
              Expanded(
                child: Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.photo_library_outlined,
                        size: 64,
                        color: AppColors.textTertiary,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        'Your memories will appear here',
                        style: AppTypography.bodyMedium.copyWith(
                          color: AppColors.textSecondary,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  /// Open Settings as a modal (keeps user in context)
  void _openSettingsSheet() {
    HapticFeedback.mediumImpact();
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.85,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (context, controller) => Container(
          decoration: const BoxDecoration(
            color: AppColors.background,
            borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
          ),
          child: _SettingsContent(scrollController: controller),
        ),
      ),
    );
  }
}

/// Settings Content - Extracted for modal use
class _SettingsContent extends ConsumerStatefulWidget {
  final ScrollController? scrollController;
  
  const _SettingsContent({super.key, this.scrollController});

  @override
  ConsumerState<_SettingsContent> createState() => _SettingsContentState();
}

class _SettingsContentState extends ConsumerState<_SettingsContent> {
  bool _isUpdatingAvatar = false;

  @override
  Widget build(BuildContext context) {
    final currentUser = ref.watch(currentUserProvider);

    return SingleChildScrollView(
      controller: widget.scrollController,
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Handle
          Center(
            child: Container(
              margin: const EdgeInsets.only(bottom: 16),
              width: 40,
              height: 4,
              decoration: BoxDecoration(
                color: Colors.white.withAlpha(76),
                borderRadius: BorderRadius.circular(2),
              ),
            ),
          ),
          
          // Header
          Row(
            children: [
              Text('Settings', style: AppTypography.headlineLarge),
              const Spacer(),
              IconButton(
                onPressed: () => Navigator.pop(context),
                icon: const Icon(Icons.close, color: AppColors.textSecondary),
              ),
            ],
          ),
          const SizedBox(height: 24),

          // Profile section
          currentUser.when(
            data: (user) => user != null
                ? _buildProfileCard(context, user)
                : const SizedBox(),
            loading: () => const Center(
              child: CircularProgressIndicator(color: AppColors.primaryAction),
            ),
            error: (_, __) => const SizedBox(),
          ),

          const SizedBox(height: 24),

          // Settings options
          _buildSettingsItem(
            icon: Icons.notifications_outlined,
            title: 'Notifications',
            onTap: () {},
          ),
          _buildSettingsItem(
            icon: Icons.lock_outline,
            title: 'Privacy',
            onTap: () {},
          ),
          _buildSettingsItem(
            icon: Icons.widgets_outlined,
            title: 'Widget Setup',
            onTap: () => context.push(AppRoutes.widgetSetup),
          ),
          _buildSettingsItem(
            icon: Icons.help_outline,
            title: 'Help & Support',
            onTap: () {},
          ),
          _buildSettingsItem(
            icon: Icons.info_outline,
            title: 'About',
            onTap: () {},
          ),

          // ðŸ”§ DEBUG: Widget Testing Section (only in debug mode)
          if (kDebugMode) ...[
            const SizedBox(height: 32),
            Text('DEBUG: Test Widgets', style: AppTypography.labelLarge.copyWith(color: Colors.orange)),
            const SizedBox(height: 16),
            
            // Test Video Vibe
            GlassContainer(
              margin: const EdgeInsets.only(bottom: 8),
              padding: const EdgeInsets.all(12),
              showGlow: true,
              glowColor: Colors.red,
              onTap: () async {
                await WidgetUpdateService.updateWidgetFromPush({
                  'senderName': 'Test User',
                  'senderId': 'test-user-123',
                  'senderAvatar': 'https://picsum.photos/200',
                  'vibeId': 'test-video-${DateTime.now().millisecondsSinceEpoch}',
                  'audioUrl': 'https://example.com/test.mp3',
                  'imageUrl': 'https://picsum.photos/400/600', // Thumbnail
                  'videoUrl': 'https://example.com/test.mp4',
                  'audioDuration': '15',
                  'isVideo': 'true',
                  'isAudioOnly': 'false',
                });
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('ðŸ“¹ Video vibe sent to widget!')),
                  );
                }
              },
              child: Row(
                children: [
                  const Icon(Icons.videocam, color: Colors.red),
                  const SizedBox(width: 12),
                  Text('Test VIDEO Vibe', style: AppTypography.bodyMedium),
                  const Spacer(),
                  const Icon(Icons.play_arrow, color: Colors.white54),
                ],
              ),
            ),
            
            // Test Audio-Only Vibe
            GlassContainer(
              margin: const EdgeInsets.only(bottom: 8),
              padding: const EdgeInsets.all(12),
              showGlow: true,
              glowColor: Colors.green,
              onTap: () async {
                await WidgetUpdateService.updateWidgetFromPush({
                  'senderName': 'Voice Test',
                  'senderId': 'test-user-456',
                  'senderAvatar': 'https://picsum.photos/200/200',
                  'vibeId': 'test-audio-${DateTime.now().millisecondsSinceEpoch}',
                  'audioUrl': 'https://example.com/voice.mp3',
                  'imageUrl': 'https://picsum.photos/200/200', // Avatar for blur
                  'audioDuration': '8',
                  'isVideo': 'false',
                  'isAudioOnly': 'true',
                });
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('ðŸŽ¤ Audio-only vibe sent to widget!')),
                  );
                }
              },
              child: Row(
                children: [
                  const Icon(Icons.mic, color: Colors.green),
                  const SizedBox(width: 12),
                  Text('Test AUDIO-ONLY Vibe', style: AppTypography.bodyMedium),
                  const Spacer(),
                  const Icon(Icons.play_arrow, color: Colors.white54),
                ],
              ),
            ),
            
            // Test Photo+Audio Vibe
            GlassContainer(
              margin: const EdgeInsets.only(bottom: 8),
              padding: const EdgeInsets.all(12),
              showGlow: true,
              glowColor: Colors.purple,
              onTap: () async {
                await WidgetUpdateService.updateWidgetFromPush({
                  'senderName': 'Photo Test',
                  'senderId': 'test-user-789',
                  'senderAvatar': 'https://picsum.photos/201/201',
                  'vibeId': 'test-photo-${DateTime.now().millisecondsSinceEpoch}',
                  'audioUrl': 'https://example.com/audio.mp3',
                  'imageUrl': 'https://picsum.photos/400/600',
                  'audioDuration': '5',
                  'isVideo': 'false',
                  'isAudioOnly': 'false',
                });
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    const SnackBar(content: Text('ðŸ“· Photo+Audio vibe sent to widget!')),
                  );
                }
              },
              child: Row(
                children: [
                  const Icon(Icons.photo_camera, color: Colors.purple),
                  const SizedBox(width: 12),
                  Text('Test PHOTO+AUDIO Vibe', style: AppTypography.bodyMedium),
                  const Spacer(),
                  const Icon(Icons.play_arrow, color: Colors.white54),
                ],
              ),
            ),
          ],

          const SizedBox(height: 32),

          // Vibe+ subscription
          _buildSubscriptionCard(context),

          const SizedBox(height: 32),

          // Sign out
          Center(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                TextButton(
                  onPressed: () async {
                    await ref.read(authServiceProvider).signOut();
                    if (context.mounted) {
                      Navigator.pop(context);
                      context.go(AppRoutes.splash);
                    }
                  },
                  child: Text(
                    'Sign Out',
                    style: AppTypography.labelLarge.copyWith(color: Colors.white70),
                  ),
                ),
                const SizedBox(width: 24),
                TextButton(
                  onPressed: () => _confirmDeleteAccount(context),
                  child: Text(
                    'Delete Account',
                    style: AppTypography.labelLarge.copyWith(color: AppColors.error),
                  ),
                ),
              ],
            ),
          ),

          const SizedBox(height: 16),

          // Version
          Center(
            child: Text(
              'Nock v1.0.0',
              style: AppTypography.caption,
            ),
          ),
          
          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Widget _buildProfileCard(BuildContext context, UserModel user) {
    return GlassContainer(
      padding: const EdgeInsets.all(20),
      useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous profile card
      child: Row(
        children: [
          Container(
            width: 56,
            height: 56,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: AppColors.auraGradient,
            ),
            child: user.avatarUrl != null
                ? ClipOval(
                    child: Image.network(user.avatarUrl!, fit: BoxFit.cover),
                  )
                : const Icon(Icons.person, size: 28, color: Colors.white),
          ),
          const SizedBox(width: 16),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(user.displayName, style: AppTypography.headlineSmall),
                const SizedBox(height: 4),
                Text(user.phoneNumber, style: AppTypography.bodySmall),
              ],
            ),
          ),
          IconButton(
            onPressed: _isUpdatingAvatar ? null : () => _pickAndUploadAvatar(context),
            icon: _isUpdatingAvatar 
                ? const SizedBox(
                    width: 20, 
                    height: 20, 
                    child: CircularProgressIndicator(strokeWidth: 2, color: AppColors.textSecondary)
                  )
                : const Icon(Icons.edit_outlined, color: AppColors.textSecondary),
          ),
        ],
      ),
    );
  }

  Future<void> _pickAndUploadAvatar(BuildContext context) async {
    debugPrint('ðŸ”˜ Profile Edit Button Pressed!');
    final picker = ImagePicker();
    try {
      debugPrint('ðŸ“¸ Launching Image Picker...');
      final XFile? image = await picker.pickImage(
        source: ImageSource.gallery,
        maxWidth: 512,
        maxHeight: 512,
        imageQuality: 75,
      );
      debugPrint('ðŸ“¸ Image Picker Result: ${image?.path ?? "Cancelled"}');

      if (image != null) {
        setState(() => _isUpdatingAvatar = true);
        HapticFeedback.mediumImpact();
        
        await ref.read(authServiceProvider).updateAvatar(File(image.path));
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Profile picture updated everywhere!'),
              backgroundColor: AppColors.vibePrimary,
            ),
          );
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to update avatar: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isUpdatingAvatar = false);
      }
    }
  }



  Widget _buildSettingsItem({
    required IconData icon,
    required String title,
    required VoidCallback onTap,
  }) {
    return GlassContainer(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous settings
      onTap: onTap,
      child: Row(
        children: [
          Icon(icon, color: AppColors.textSecondary),
          const SizedBox(width: 16),
          Text(title, style: AppTypography.bodyLarge),
          const Spacer(),
          const Icon(Icons.chevron_right, color: AppColors.textTertiary),
        ],
      ),
    );
  }

  Widget _buildSubscriptionCard(BuildContext context) {
    return GlassContainer(
      padding: const EdgeInsets.all(20),
      showGlow: true,
      useLuminousBorder: true, // ðŸŒŸ PHASE 2: Luminous premium card
      glowColor: AppColors.secondaryAction,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              ShaderMask(
                shaderCallback: (bounds) =>
                    AppColors.primaryGradient.createShader(bounds),
                child: Text(
                  'VIBE+',
                  style: AppTypography.headlineMedium.copyWith(color: Colors.white),
                ),
              ),
              const Spacer(),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: AppColors.secondaryAction,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '\$4.99/mo',
                  style: AppTypography.labelMedium.copyWith(color: Colors.white),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Text(
            'Unlock unlimited memories in the Vault',
            style: AppTypography.bodyMedium.copyWith(color: AppColors.textSecondary),
          ),
          const SizedBox(height: 16),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: () => context.push(AppRoutes.subscription),
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.secondaryAction,
              ),
              child: Text('Upgrade', style: AppTypography.buttonText),
            ),
          ),
        ],
      ),
    );
  }

  void _confirmDeleteAccount(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Delete Account?', style: TextStyle(color: Colors.white)),
        content: const Text(
          'This will permanently delete your profile, vibes, and subscription data. This action cannot be undone.',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel', style: TextStyle(color: Colors.white54)),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Delete Permanently', style: TextStyle(color: AppColors.error)),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      // 2025: Robust deletion flow with re-authentication support
      try {
        await ref.read(authServiceProvider).deleteAccount();
        if (context.mounted) _handleDeletionSuccess(context);
      } on FirebaseAuthException catch (e) {
        if (e.code == 'requires-recent-login') {
          debugPrint('ðŸ” Deletion requires re-authentication. Prompting user...');
          if (context.mounted) {
            await _handleReauthenticationFlow(context);
          }
        } else {
            if (context.mounted) _handleDeletionError(context, e.message ?? e.code);
        }
      } catch (e) {
        if (context.mounted) _handleDeletionError(context, e.toString());
      }
    }
  }

  Future<void> _handleReauthenticationFlow(BuildContext context) async {
    // 1. Explain why
    final shouldReauth = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Security Check', style: TextStyle(color: Colors.white)),
        content: const Text(
          'For your security, please sign in again to confirm you want to delete this account.',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
             onPressed: () => Navigator.pop(context, false),
             child: const Text('Cancel', style: TextStyle(color: Colors.white54)),
          ),
          ElevatedButton(
            style: ElevatedButton.styleFrom(backgroundColor: AppColors.primaryAction),
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Verify Identity', style: TextStyle(color: Colors.black)),
          ),
        ],
      ),
    );

    if (shouldReauth != true) return;

    // 2. Determine provider and re-authenticate
    try {
        final originalUser = ref.read(currentUserProvider).value;
        final originalUid = FirebaseAuth.instance.currentUser?.uid; // Capture physical UID
        final provider = originalUser?.authProvider ?? 'google';
        
        if (originalUid == null) throw Exception('No authenticated user found');

        debugPrint('ðŸ” Re-authenticating via $provider (Original UID: $originalUid)...');
        
        if (provider == 'google') {
            await ref.read(authServiceProvider).signInWithGoogle();
        } else if (provider == 'apple') {
            await ref.read(authServiceProvider).signInWithApple();
        } else {
             throw Exception('Unsupported auth provider for legacy re-auth');
        }

        // --- SECURITY FIX: IDENTITY VERIFICATION ---
        final currentUid = FirebaseAuth.instance.currentUser?.uid;
        if (currentUid != originalUid) {
            debugPrint('ðŸš¨ SECURITY ALERT: Identity mismatch during re-auth! (New: $currentUid, Original: $originalUid)');
            
            // Immediately sign out to clear the "wrong" account
            await ref.read(authServiceProvider).signOut();
            
            if (context.mounted) {
                showDialog(
                    context: context,
                    builder: (context) => AlertDialog(
                        backgroundColor: AppColors.surface,
                        title: const Text('Identity Mismatch', style: TextStyle(color: Colors.white)),
                        content: const Text(
                            'The account you just signed into does not match the one you are trying to delete. Please sign in with the correct account.',
                            style: TextStyle(color: Colors.white70),
                        ),
                        actions: [
                            TextButton(
                                onPressed: () => Navigator.pop(context),
                                child: const Text('OK', style: TextStyle(color: AppColors.primaryAction)),
                            ),
                        ],
                    ),
                );
            }
            return;
        }
        // --- END SECURITY FIX ---
        
        // 3. Retry Deletion immediately
        await ref.read(authServiceProvider).deleteAccount();
        if (context.mounted) _handleDeletionSuccess(context);

    } catch (e) {
        if (context.mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Verification failed: $e')),
            );
        }
    }
  }

  void _handleDeletionSuccess(BuildContext context) {
      Navigator.pop(context); // Close settings sheet
      context.go(AppRoutes.splash);
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Account successfully deleted.')),
      );
  }

  void _handleDeletionError(BuildContext context, String error) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Error: $error')),
      );
  }
}



========================================

FILE #55: E:\Vive\lib\features\invite\presentation\invite_acceptance_screen.dart

========================================


import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';  // for authStateProvider
import 'package:nock/core/providers/deep_link_provider.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';

/// Invite Acceptance Screen
/// 
/// Handles deep links like: vibe.app/invite/username123
/// This screen is shown when a user clicks an invite link
class InviteAcceptanceScreen extends ConsumerStatefulWidget {
  final String inviterId;
  
  const InviteAcceptanceScreen({super.key, required this.inviterId});

  @override
  ConsumerState<InviteAcceptanceScreen> createState() => _InviteAcceptanceScreenState();
}

class _InviteAcceptanceScreenState extends ConsumerState<InviteAcceptanceScreen> {
  bool _isLoading = true;
  bool _isAccepting = false;
  String? _inviterName;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadInviterInfo();
    
    // CRITICAL: "Consume" the pending invite's mandatory redirect state on mount.
    // By calling dismiss(), we tell the Router that we have already seen this
    // invite in this session, so it won't force-redirect us back here if we
    // choose to navigate to Home or Settings later.
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        ref.read(pendingInviteProvider.notifier).dismiss();
        debugPrint('InviteAcceptanceScreen: Dismissed active redirect for this invite');
      }
    });
  }

  Future<void> _loadInviterInfo() async {
    try {
      if (widget.inviterId.isEmpty) {
        setState(() {
          _error = 'Invalid invite link';
          _isLoading = false;
        });
        return;
      }
      
      // ACTUAL FIRESTORE IMPLEMENTATION: Fetch inviter info
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(widget.inviterId)
          .get();
      
      if (!doc.exists) {
        setState(() {
          _error = 'User not found';
          _isLoading = false;
        });
        return;
      }
      
      final data = doc.data();
      setState(() {
        _inviterName = data?['displayName'] ?? 'Nock User';
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = 'Failed to load invite: $e';
        _isLoading = false;
      });
    }
  }

  Future<void> _acceptInvite() async {
    setState(() => _isAccepting = true);
    
    try {
      // Check if user is logged in
      final authState = ref.read(authStateProvider);
      final currentUser = authState.valueOrNull;
      
      if (currentUser == null) {
        // Not logged in - go to auth first, then come back
        context.go(AppRoutes.phoneAuth);
        return;
      }
      
      final currentUserId = currentUser.uid;
      final inviterId = widget.inviterId;
      
      // Validate inviter ID
      if (inviterId.isEmpty) {
        setState(() {
          _error = 'Invalid invite link';
          _isAccepting = false;
        });
        return;
      }
      
      if (inviterId == currentUserId) {
        setState(() {
          _error = 'You can\'t add yourself as a friend ðŸ˜…';
          _isAccepting = false;
        });
        return;
      }
      
      // ACTUAL FIRESTORE IMPLEMENTATION: Connect both users as friends
      // This replaces the TODO placeholder that broke the viral loop
      final firestore = FirebaseFirestore.instance;
      final batch = firestore.batch();
      
      // 1. Add inviter to current user's friend list
      batch.update(
        firestore.collection('users').doc(currentUserId),
        {'friendIds': FieldValue.arrayUnion([inviterId])},
      );
      
      // 2. Add current user to inviter's friend list (bidirectional)
      batch.update(
        firestore.collection('users').doc(inviterId),
        {'friendIds': FieldValue.arrayUnion([currentUserId])},
      );
      
      // Execute both updates atomically
      await batch.commit();
      
      // CRITICAL: Only clear pending invite AFTER successful acceptance
      // This prevents losing the invite if there's a network error
      ref.read(pendingInviteProvider.notifier).clearPendingInvite();
      
      // Show success and go to home
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                const Icon(Icons.check_circle, color: Colors.white),
                const SizedBox(width: 8),
                Text('You\'re now connected with $_inviterName!'),
              ],
            ),
            backgroundColor: Colors.green.shade700,
          ),
        );
        context.go(AppRoutes.home);
      }
    } catch (e) {
      setState(() {
        _error = 'Failed to accept invite: $e';
        _isAccepting = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.voidNavy,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: _isLoading
              ? const Center(
                  child: CircularProgressIndicator(color: Color(0xFF00F0FF)),
                )
              : _error != null
                  ? _buildErrorState()
                  : _buildInviteContent(),
        ),
      ),
    );
  }

  Widget _buildErrorState() {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(
            Icons.error_outline,
            color: Colors.red,
            size: 64,
          ),
          const SizedBox(height: 16),
          Text(
            _error ?? 'Something went wrong',
            style: const TextStyle(color: Colors.white),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),
          ElevatedButton(
            onPressed: () => context.go(AppRoutes.home),
            child: const Text('Go Home'),
          ),
        ],
      ),
    );
  }

  Widget _buildInviteContent() {
    return Column(
      children: [
        const Spacer(),
        
        // Glowing avatar area
        Container(
          width: 150,
          height: 150,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            gradient: LinearGradient(
              colors: [
                AppColors.primaryAction.withOpacity(0.3),
                AppColors.secondaryAction.withOpacity(0.3),
              ],
            ),
            boxShadow: [
              BoxShadow(
                color: AppColors.primaryAction.withOpacity(0.3),
                blurRadius: 50,
                spreadRadius: 20,
              ),
            ],
          ),
          child: Center(
            child: Text(
              _inviterName?.isNotEmpty == true 
                  ? _inviterName![0].toUpperCase() 
                  : '?',
              style: AppTypography.displayLarge.copyWith(
                fontSize: 64,
                color: Colors.white,
              ),
            ),
          ),
        ),
        
        const SizedBox(height: 32),
        
        Text(
          _inviterName ?? 'Someone',
          style: AppTypography.displaySmall.copyWith(
            color: Colors.white,
          ),
        ),
        
        const SizedBox(height: 8),
        
        Text(
          'wants to exchange Vibes with you!',
          style: AppTypography.bodyLarge.copyWith(
            color: Colors.white.withOpacity(0.7),
          ),
        ),
        
        const Spacer(),
        
        // Accept button
        SizedBox(
          width: double.infinity,
          child: ElevatedButton(
            onPressed: _isAccepting ? null : _acceptInvite,
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryAction,
              padding: const EdgeInsets.symmetric(vertical: 18),
            ),
            child: _isAccepting
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: Colors.black,
                    ),
                  )
                : Text(
                    'Accept Invite',
                    style: AppTypography.buttonText.copyWith(
                      color: Colors.black,
                      fontSize: 18,
                    ),
                  ),
          ),
        ),
        
        const SizedBox(height: 16),
        
        TextButton(
          onPressed: () {
            // CRITICAL FIX: Removed clearPendingInvite() to prevent losing the invite
            // if user just wants to browse first.
            context.go(AppRoutes.home);
          },
          child: const Text('Maybe later'),
        ),
      ],
    );
  }
}



========================================

FILE #56: E:\Vive\lib\features\onboarding\presentation\onboarding_screen.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/providers/onboarding_provider.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/shared/widgets/aura_visualization.dart';

/// Splash Screen - Initial loading screen with Aura animation
class SplashScreen extends ConsumerStatefulWidget {
  const SplashScreen({super.key});

  @override
  ConsumerState<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends ConsumerState<SplashScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _fadeAnimation;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    );

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.5, curve: Curves.easeOut),
      ),
    );

    _scaleAnimation = Tween<double>(begin: 0.5, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.7, curve: Curves.elasticOut),
      ),
    );

    _controller.forward();

    _controller.forward();

    // Navigate after animation
    _checkNavigation();
  }

  Future<void> _checkNavigation() async {
    debugPrint('ðŸš€ Splash: Starting 2.5s animation delay...');
    
    // Wait for animation to complete
    await Future.delayed(const Duration(milliseconds: 2500));
    
    debugPrint('ðŸš€ Splash: Animation complete, mounted=$mounted');
    
    // 2025 RACE CONDITION FIX:
    // User might have tapped a deep link or notification while the app was cold-starting.
    // DeepLinkService/FCMService may have already navigated. 
    // We MUST check if we are still on the splash route before overriding with Home.
    if (mounted) {
      final router = GoRouter.of(context);
      final currentLocation = router.routerDelegate.currentConfiguration.uri.path;
      
      if (currentLocation != AppRoutes.splash) {
        debugPrint('ðŸš€ Splash: Deep link or notification already navigated to $currentLocation. Skipping Home override.');
        return;
      }

      debugPrint('ðŸš€ Splash: Still on splash, navigating to ${AppRoutes.home}...');
      // Try to navigate to home - the router redirect will intercept
      // and send user to the correct screen (welcome, onboarding, home, etc.)
      context.go(AppRoutes.home);
      debugPrint('ðŸš€ Splash: context.go() called');
    } else {
      debugPrint('âŒ Splash: NOT mounted, cannot navigate');
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: Center(
        child: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return Opacity(
              opacity: _fadeAnimation.value,
              child: Transform.scale(
                scale: _scaleAnimation.value,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    // Aura visualization
                    const AuraVisualization(
                      size: 200,
                      isRecording: false,
                      mood: AuraMood.neutral,
                    ),
                    const SizedBox(height: 40),
                    // App name
                    ShaderMask(
                      shaderCallback: (bounds) =>
                          AppColors.primaryGradient.createShader(bounds),
                      child: Text(
                        'VIBE',
                        style: AppTypography.displayLarge.copyWith(
                          color: Colors.white,
                          letterSpacing: 8,
                        ),
                      ),
                    ),
                    const SizedBox(height: 12),
                    Text(
                      'Feel the connection',
                      style: AppTypography.bodyMedium.copyWith(
                        color: AppColors.textSecondary,
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

/// Onboarding Screen - Introduction to Vibe (2025 Progressive Disclosure)
/// 
/// Key Changes for 2025:
/// - No permission gates during onboarding
/// - Permissions requested contextually when features are used
/// - Skip button goes directly to auth/home
/// - "Get Started" completes onboarding without forcing permissions
class OnboardingScreen extends ConsumerStatefulWidget {
  const OnboardingScreen({super.key});

  @override
  ConsumerState<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends ConsumerState<OnboardingScreen> {
  final PageController _pageController = PageController();
  int _currentPage = 0;

  final List<OnboardingData> _pages = [
    OnboardingData(
      title: 'Voice + Photo',
      subtitle: 'Share moments with your voice',
      description: 'Capture a photo, add a 10-second voice note, and send it instantly to your squad.',
      mood: AuraMood.happy,
      icon: Icons.photo_camera,
    ),
    OnboardingData(
      title: 'Widget Magic',
      subtitle: 'Your home screen comes alive',
      description: 'See and hear your friends without opening the app. Tap to play, hold to reply.',
      mood: AuraMood.excited,
      icon: Icons.widgets,
    ),
    OnboardingData(
      title: 'Time Travel',
      subtitle: 'Share memories, not just moments',
      description: 'Upload photos from your gallery with a retro date stamp. Every picture tells a story.',
      mood: AuraMood.calm,
      icon: Icons.history,
    ),
    OnboardingData(
      title: 'Memory Vault',
      subtitle: 'Never lose a vibe',
      description: 'Keep all your voice memories safe. Relive every moment on a beautiful calendar.',
      mood: AuraMood.neutral,
      icon: Icons.lock,
    ),
  ];

  /// 2025 FIX: Complete onboarding and go to auth/home
  /// No permission gates - they'll be requested contextually
  Future<void> _completeOnboarding() async {
    // CRITICAL FIX: Check mounted and capture state BEFORE any await
    // This prevents "Cannot use ref after widget was disposed" error
    if (!mounted) return;
    
    // Capture auth state BEFORE the await to avoid ref access after disposal
    final authState = ref.read(authStateProvider);
    final isLoggedIn = authState.valueOrNull != null;
    final onboardingNotifier = ref.read(onboardingStateProvider.notifier);
    
    // Mark onboarding as complete
    // This prevents the infinite redirect loop between /welcome and /onboarding
    await onboardingNotifier.completeOnboarding();
    
    // Re-check mounted after await since widget may have been disposed
    if (!mounted) return;
    
    if (isLoggedIn) {
      // User is already logged in -> go directly to home
      context.go('/home');
    } else {
      // User not logged in -> go to welcome/auth screen
      context.go('/welcome');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: SafeArea(
        child: Column(
          children: [
            // Skip button - 2025: Goes directly to auth, no permissions
            Align(
              alignment: Alignment.topRight,
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: TextButton(
                  onPressed: _completeOnboarding,
                  child: Text(
                    'Skip',
                    style: AppTypography.labelLarge.copyWith(
                      color: AppColors.textSecondary,
                    ),
                  ),
                ),
              ),
            ),

            // Page view
            Expanded(
              child: PageView.builder(
                controller: _pageController,
                itemCount: _pages.length,
                onPageChanged: (index) {
                  setState(() => _currentPage = index);
                },
                itemBuilder: (context, index) {
                  return _buildPage(_pages[index]);
                },
              ),
            ),

            // Page indicators
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 20),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: List.generate(
                  _pages.length,
                  (index) => _buildIndicator(index),
                ),
              ),
            ),

            // Next/Get Started button
            Padding(
              padding: const EdgeInsets.all(24),
              child: SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    if (_currentPage < _pages.length - 1) {
                      _pageController.nextPage(
                        duration: const Duration(milliseconds: 300),
                        curve: Curves.easeInOut,
                      );
                    } else {
                      // 2025 FIX: Go directly to auth, no permission gates
                      _completeOnboarding();
                    }
                  },
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primaryAction,
                    padding: const EdgeInsets.symmetric(vertical: 16),
                  ),
                  child: Text(
                    _currentPage < _pages.length - 1 ? 'Next' : 'Get Started',
                    style: AppTypography.buttonText,
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPage(OnboardingData data) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 32),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Aura with icon
          Stack(
            alignment: Alignment.center,
            children: [
              AuraVisualization(
                size: 180,
                mood: data.mood,
              ),
              Icon(
                data.icon,
                size: 48,
                color: AppColors.background,
              ),
            ],
          ),
          const SizedBox(height: 48),

          // Title
          ShaderMask(
            shaderCallback: (bounds) =>
                AppColors.primaryGradient.createShader(bounds),
            child: Text(
              data.title,
              style: AppTypography.displaySmall.copyWith(color: Colors.white),
              textAlign: TextAlign.center,
            ),
          ),
          const SizedBox(height: 8),

          // Subtitle
          Text(
            data.subtitle,
            style: AppTypography.headlineSmall.copyWith(
              color: AppColors.textSecondary,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),

          // Description in glass container
          GlassContainer(
            padding: const EdgeInsets.all(20),
            child: Text(
              data.description,
              style: AppTypography.bodyMedium.copyWith(
                color: AppColors.textSecondary,
                height: 1.5,
              ),
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildIndicator(int index) {
    final isActive = index == _currentPage;
    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      margin: const EdgeInsets.symmetric(horizontal: 4),
      width: isActive ? 24 : 8,
      height: 8,
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(4),
        color: isActive ? AppColors.primaryAction : AppColors.surfaceLight,
      ),
    );
  }
}

class OnboardingData {
  final String title;
  final String subtitle;
  final String description;
  final AuraMood mood;
  final IconData icon;

  OnboardingData({
    required this.title,
    required this.subtitle,
    required this.description,
    required this.mood,
    required this.icon,
  });
}



========================================

FILE #57: E:\Vive\lib\features\onboarding\presentation\permission_screens.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/shared/widgets/aura_visualization.dart';

/// Permission flow screens - "Hard Gate" onboarding
/// Forces users to grant all permissions before entering the app

/// Base Permission Screen
class PermissionScreen extends ConsumerStatefulWidget {
  final String title;
  final String subtitle;
  final String description;
  final IconData icon;
  final Permission permission;
  final String nextRoute;
  final AuraMood mood;

  const PermissionScreen({
    super.key,
    required this.title,
    required this.subtitle,
    required this.description,
    required this.icon,
    required this.permission,
    required this.nextRoute,
    this.mood = AuraMood.neutral,
  });

  @override
  ConsumerState<PermissionScreen> createState() => _PermissionScreenState();
}

class _PermissionScreenState extends ConsumerState<PermissionScreen>
    with SingleTickerProviderStateMixin, WidgetsBindingObserver {
  late AnimationController _pulseController;
  bool _isRequesting = false;

  @override
  void initState() {
    super.initState();
    // FIX: Register as observer to detect when user returns from Settings
    WidgetsBinding.instance.addObserver(this);
    
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    )..repeat(reverse: true);

    _checkExistingPermission();
  }

  Future<void> _checkExistingPermission() async {
    final status = await widget.permission.status;
    if (status.isGranted && mounted) {
      context.go(widget.nextRoute);
    }
  }

  @override
  void dispose() {
    // FIX: Remove observer on dispose
    WidgetsBinding.instance.removeObserver(this);
    _pulseController.dispose();
    super.dispose();
  }
  
  // FIX: Auto-check permission when user returns from Settings
  // Without this, users get trapped on the permission screen
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.resumed) {
      // User returned from Settings, re-check permission status
      _checkExistingPermission();
    }
  }

  Future<void> _requestPermission() async {
    if (_isRequesting) return;

    setState(() => _isRequesting = true);

    final status = await widget.permission.request();

    setState(() => _isRequesting = false);

    if (status.isGranted && mounted) {
      context.go(widget.nextRoute);
    } else if (status.isPermanentlyDenied && mounted) {
      _showSettingsDialog();
    } else if (status.isDenied && mounted) {
      // FIX: Handle simple denial - show message and allow retry or skip
      _showDeniedDialog();
    }
  }

  void _showDeniedDialog() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: Text(
          'Permission Needed',
          style: AppTypography.headlineMedium,
        ),
        content: Text(
          '${widget.title} permission is required for the best Vibe experience. Would you like to try again?',
          style: AppTypography.bodyMedium,
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              // Allow skip - proceed anyway (limited functionality)
              context.go(widget.nextRoute);
            },
            child: const Text('Skip for now'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              _requestPermission();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryAction,
            ),
            child: const Text('Try Again'),
          ),
        ],
      ),
    );
  }

  void _showSettingsDialog() {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: Text(
          'Permission Required',
          style: AppTypography.headlineMedium,
        ),
        content: Text(
          '${widget.title} permission was permanently denied. Please enable it in Settings to continue, or skip to use limited functionality.',
          style: AppTypography.bodyMedium,
        ),
        actions: [
          // FIX: Add "Skip for now" to prevent death loop
          TextButton(
            onPressed: () {
              Navigator.pop(dialogContext);
              // Allow user to skip if they really refuse
              context.go(widget.nextRoute);
            },
            child: const Text('Skip for now'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(dialogContext);
              openAppSettings();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryAction,
            ),
            child: const Text('Open Settings'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Spacer(),

              // Animated Aura with icon
              AnimatedBuilder(
                animation: _pulseController,
                builder: (context, child) {
                  return Transform.scale(
                    scale: 0.9 + (_pulseController.value * 0.1),
                    child: Stack(
                      alignment: Alignment.center,
                      children: [
                        AuraVisualization(
                          size: 200,
                          mood: widget.mood,
                        ),
                        Container(
                          width: 80,
                          height: 80,
                          decoration: BoxDecoration(
                            color: AppColors.background.withOpacity(0.8),
                            shape: BoxShape.circle,
                          ),
                          child: Icon(
                            widget.icon,
                            size: 40,
                            color: AppColors.primaryAction,
                          ),
                        ),
                      ],
                    ),
                  );
                },
              ),

              const SizedBox(height: 48),

              // Title
              Text(
                widget.title,
                style: AppTypography.displaySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 8),

              // Subtitle
              Text(
                widget.subtitle,
                style: AppTypography.headlineSmall.copyWith(
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),

              // Description
              GlassContainer(
                padding: const EdgeInsets.all(20),
                child: Text(
                  widget.description,
                  style: AppTypography.bodyMedium.copyWith(
                    color: AppColors.textSecondary,
                    height: 1.5,
                  ),
                  textAlign: TextAlign.center,
                ),
              ),

              const Spacer(),

              // Grant Permission Button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: _isRequesting ? null : _requestPermission,
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppColors.primaryAction,
                    padding: const EdgeInsets.symmetric(vertical: 18),
                  ),
                  child: _isRequesting
                      ? const SizedBox(
                          width: 24,
                          height: 24,
                          child: CircularProgressIndicator(
                            color: AppColors.background,
                            strokeWidth: 2,
                          ),
                        )
                      : Text(
                          widget.title,
                          style: AppTypography.buttonText,
                        ),
                ),
              ),

              const SizedBox(height: 32),
            ],
          ),
        ),
      ),
    );
  }
}

/// Microphone Permission Screen
class MicrophonePermissionScreen extends StatelessWidget {
  const MicrophonePermissionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const PermissionScreen(
      title: 'Hear Your Friends',
      subtitle: 'Allow Microphone Access',
      description:
          'Nock uses your microphone to record voice notes. Share your thoughts, not just photos.',
      icon: Icons.mic,
      permission: Permission.microphone,
      nextRoute: AppRoutes.permissionNotification,
      mood: AuraMood.happy,
    );
  }
}

/// Notification Permission Screen
class NotificationPermissionScreen extends StatelessWidget {
  const NotificationPermissionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const PermissionScreen(
      title: 'Know When They Speak',
      subtitle: 'Allow Notifications',
      description:
          'Get notified instantly when your friends send you a vibe. Never miss a moment.',
      icon: Icons.notifications_active,
      permission: Permission.notification,
      nextRoute: AppRoutes.permissionCamera,
      mood: AuraMood.excited,
    );
  }
}

/// Camera Permission Screen
class CameraPermissionScreen extends StatelessWidget {
  const CameraPermissionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const PermissionScreen(
      title: 'Capture Moments',
      subtitle: 'Allow Camera Access',
      description:
          'Take photos to share with your voice notes. Show them what you see.',
      icon: Icons.camera_alt,
      permission: Permission.camera,
      nextRoute: AppRoutes.permissionContacts,
      mood: AuraMood.calm,
    );
  }
}

/// Contacts Permission Screen
class ContactsPermissionScreen extends StatelessWidget {
  const ContactsPermissionScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const PermissionScreen(
      title: 'Find Your Squad',
      subtitle: 'Allow Contacts Access',
      description:
          'Find friends who already use Vibe. Your contacts stay on your device and are never uploaded.',
      icon: Icons.people,
      permission: Permission.contacts,
      nextRoute: AppRoutes.widgetSetup,
      mood: AuraMood.neutral,
    );
  }
}



========================================

FILE #58: E:\Vive\lib\features\onboarding\presentation\widget_setup_screen.dart

========================================


import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:home_widget/home_widget.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/core/providers/onboarding_provider.dart';

/// Widget Setup Screen - Forces user to install the widget before entering the app
/// This is the "Widget Lockout" from the design specification
class WidgetSetupScreen extends ConsumerStatefulWidget {
  const WidgetSetupScreen({super.key});

  @override
  ConsumerState<WidgetSetupScreen> createState() => _WidgetSetupScreenState();
}

class _WidgetSetupScreenState extends ConsumerState<WidgetSetupScreen>
    with TickerProviderStateMixin {
  late AnimationController _pulseController;
  late AnimationController _bounceController;
  bool _widgetInstalled = false;
  Timer? _checkTimer;

  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this,
    )..repeat(reverse: true);

    _bounceController = AnimationController(
      duration: const Duration(milliseconds: 1000),
      vsync: this,
    )..repeat(reverse: true);

    // Removed: _startWidgetCheck() - replaced with honest "I've Added It" button
    // iOS/Android cannot reliably detect if a widget is installed
    // Showing "Waiting for widget..." when it will never detect is misleading UX
  }

  /// Mark widget as installed (user confirmation)
  /// This replaces the fake auto-detection that never worked
  void _confirmWidgetAdded() {
    setState(() => _widgetInstalled = true);
    // Haptic feedback for confirmation
    HapticFeedback.mediumImpact();
  }

  Future<void> _finishOnboarding() async {
    debugPrint('ðŸ WidgetSetup: Finishing onboarding...');
    await ref.read(onboardingStateProvider.notifier).completeOnboarding();
    debugPrint('ðŸ WidgetSetup: Onboarding marked complete, navigating to home...');
    
    // CRITICAL: Must explicitly navigate after completing onboarding
    // The router redirect only fires when navigating TO a route, not on state changes
    if (mounted) {
      context.go(AppRoutes.home);
    }
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _bounceController.dispose();
    _checkTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.background,
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: ListView(
            children: [
              // Skip for demo (remove in production)
              Align(
                alignment: Alignment.topRight,
                child: TextButton(
                  onPressed: () => context.go(AppRoutes.welcome),
                  child: Text(
                    'Skip (Demo)',
                    style: AppTypography.labelMedium.copyWith(
                      color: AppColors.textTertiary,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // Title
              Text(
                'Add the Widget',
                style: AppTypography.displaySmall,
                textAlign: TextAlign.center,
              ),

              const SizedBox(height: 12),

              Text(
                'The magic happens on your home screen',
                style: AppTypography.bodyLarge.copyWith(
                  color: AppColors.textSecondary,
                ),
                textAlign: TextAlign.center,
              ),

              const SizedBox(height: 40),

              // Widget preview
              Center(child: _buildWidgetPreview()),

              const SizedBox(height: 32),

              // Instructions
              GlassContainer(
                padding: const EdgeInsets.all(20),
                child: Column(
                  children: [
                    _buildStep(1, 'Long press on your home screen'),
                    const SizedBox(height: 16),
                    _buildStep(2, 'Tap the "+" button or "Widgets"'),
                    const SizedBox(height: 16),
                    _buildStep(3, 'Find and add the Vibe widget'),
                  ],
                ),
              ),

              const SizedBox(height: 40),

              // HONEST UX: "I've Added It" confirmation button
              if (!_widgetInstalled) ...[
                // Confirmation button
                SizedBox(
                  width: double.infinity,
                  child: OutlinedButton.icon(
                    onPressed: _confirmWidgetAdded,
                    icon: const Icon(Icons.check, color: AppColors.primaryAction),
                    label: Text(
                      "I've Added the Widget",
                      style: AppTypography.buttonText.copyWith(
                        color: AppColors.primaryAction,
                      ),
                    ),
                    style: OutlinedButton.styleFrom(
                      side: const BorderSide(color: AppColors.primaryAction, width: 2),
                      padding: const EdgeInsets.symmetric(vertical: 16),
                    ),
                  ),
                ),
                const SizedBox(height: 16),
              ] else ...[
                // Success state
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.check_circle, color: AppColors.success),
                    const SizedBox(width: 8),
                    Text(
                      'Great! Widget confirmed âœ“',
                      style: AppTypography.bodyMedium.copyWith(
                        color: AppColors.success,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
              ],

              // Continue button - ALWAYS enabled (App Store compliance)
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () => _finishOnboarding(),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: _widgetInstalled 
                        ? AppColors.primaryAction 
                        : AppColors.surface,
                    padding: const EdgeInsets.symmetric(vertical: 18),
                  ),
                  child: Text(
                    _widgetInstalled ? 'Continue' : 'Skip for Now',
                    style: AppTypography.buttonText.copyWith(
                      color: _widgetInstalled 
                          ? AppColors.background 
                          : AppColors.textSecondary,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 16),

              // Manual continue option
              Center(
                child: TextButton(
                  onPressed: () => _finishOnboarding(),
                  child: Text(
                    "I'll add it later",
                    style: AppTypography.labelMedium.copyWith(
                      color: AppColors.textTertiary,
                    ),
                  ),
                ),
              ),

              const SizedBox(height: 16),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildWidgetPreview() {
    return GlassContainer(
      width: 200,
      height: 200,
      borderRadius: 32,
      showGlow: true,
      glowColor: AppColors.primaryAction,
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // Fake profile picture
          Container(
            width: 100,
            height: 100,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: AppColors.auraGradient,
              boxShadow: [
                BoxShadow(
                  color: AppColors.primaryAction.withOpacity(0.5),
                  blurRadius: 20,
                  spreadRadius: 5,
                ),
              ],
            ),
            child: const Icon(
              Icons.person,
              size: 50,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 16),
          Text(
            'Tap to play',
            style: AppTypography.labelMedium.copyWith(
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: 4),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Container(
                width: 8,
                height: 8,
                decoration: const BoxDecoration(
                  color: AppColors.success,
                  shape: BoxShape.circle,
                ),
              ),
              const SizedBox(width: 6),
              Text(
                'New Vibe',
                style: AppTypography.labelSmall.copyWith(
                  color: AppColors.success,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildStep(int number, String text) {
    return Row(
      children: [
        Container(
          width: 32,
          height: 32,
          decoration: BoxDecoration(
            color: AppColors.primaryAction.withOpacity(0.2),
            shape: BoxShape.circle,
            border: Border.all(color: AppColors.primaryAction),
          ),
          child: Center(
            child: Text(
              '$number',
              style: AppTypography.labelLarge.copyWith(
                color: AppColors.primaryAction,
              ),
            ),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: Text(
            text,
            style: AppTypography.bodyMedium.copyWith(
              color: AppColors.textPrimary,
            ),
          ),
        ),
      ],
    );
  }
}



========================================

FILE #59: E:\Vive\lib\features\player\presentation\player_screen.dart

========================================


import 'dart:io';
import 'dart:async';
import 'dart:ui';
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:share_plus/share_plus.dart';
import 'package:path_provider/path_provider.dart';
import 'package:http/http.dart' as http;
import 'package:video_player/video_player.dart';
import 'package:record/record.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/services/audio_service.dart';
import 'package:nock/core/services/vibe_service.dart';
import 'package:nock/core/services/transcription_service.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/services/viral_video_service.dart';
import 'package:nock/features/camera/domain/services/video_processing_service.dart';
import 'package:nock/core/models/vibe_model.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/shared/widgets/aura_visualization.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter_animate/flutter_animate.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Ghost Player Screen - Deep link view when tapping the widget
/// Shows the photo with Aura visualization and voice playback
/// Includes instant voice reply functionality
class PlayerScreen extends ConsumerStatefulWidget {
  final VibeModel? vibe;
  final String? vibeId;
  /// When true, auto-highlights reply button after playback (opens from notification)
  final bool fromNotification;
  /// List of vibes for horizontal swipe navigation (from Vault)
  final List<VibeModel>? vibesList;
  /// Starting index in vibesList
  final int? startIndex;

  const PlayerScreen({
    super.key,
    this.vibe,
    this.vibeId,
    this.fromNotification = false,
    this.vibesList,
    this.startIndex,
  });

  @override
  ConsumerState<PlayerScreen> createState() => _PlayerScreenState();
}

class _PlayerScreenState extends ConsumerState<PlayerScreen>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  late AnimationController _fadeController;
  late Animation<double> _fadeAnimation;
  late AnimationController _pulseController;
  late Animation<double> _pulseAnimation;
  
  // FIX: Subscription management
  StreamSubscription? _audioStateSubscription;
  StreamSubscription? _audioPositionSubscription;
  
  // FIX: Store audio service reference for safe disposal
  AudioService? _audioService;
  
  bool _isPlaying = false;
  bool _isBuffering = false; // NEW: Track buffering explicitly
  bool _hasPlayed = false;
  bool _isReplying = false;
  double _playbackProgress = 0.0;
  
  bool _isExportingVideo = false;
  double _exportProgress = 0.0;
  
  // For transcription display
  bool _showTranscription = false;
  String? _transcriptionText;
  
  // Video player for video vibes
  VideoPlayerController? _videoController;
  bool _isVideoInitialized = false;
  
  
  // INSTANT REPLY: Mic pre-warmed during playback
  bool _micPreWarmed = false;
  bool _showReplyFocus = false;  // Highlights reply after playback if from notification
  
  // Vibe State
  VibeModel? _vibe;
  bool _isLoading = true;
  String? _error;
  
  // TEXT REPLIES: Visual Whispers
  bool _isTextReplying = false;
  final TextEditingController _textReplyController = TextEditingController();
  final FocusNode _textReplyFocusNode = FocusNode();
  
  // REACTIONS: Quick Reactions widget rain
  final List<FloatingEmoji> _floatingEmojis = [];
  Timer? _emojiCleanupTimer;
  
  // SWIPE NAVIGATION: PageController for horizontal swipe through vibes list
  PageController? _pageController;
  int _currentVibeIndex = 0;
  bool get _hasSwipeNavigation => widget.vibesList != null && widget.vibesList!.length > 1;
  
  // FIX Issue 3: Track current vibe URL to cancel stale initializations
  String? _currentVibeUrl;

  // NEW: Ghost Hints state (Progressive Disclosure)
  bool _showGhostHints = false;
  Timer? _ghostHintTimer;
  static const String _ghostHintsSeenKey = 'player_ghost_hints_seen';

  // Voice Reply Preview State
  String? _pendingReplyPath; // Path of recorded audio awaiting confirmation
  bool _isPreviewingReply = false; // Is user in preview mode
  bool _isPlayingPreview = false; // Is preview audio currently playing
  AudioPlayer? _previewPlayer; // Player for preview playback
  
  // Consistency: 15s limit for voice replies
  Timer? _recordingLimitTimer;

  @override
  void initState() {
    super.initState();
    // LIFECYCLE FIX: Register observer to pause media on background
    WidgetsBinding.instance.addObserver(this);
    
    // NOTE: We no longer store _audioService. We use scoped provider on demand.

    
    // SWIPE NAVIGATION: Initialize PageController if vibesList provided
    if (_hasSwipeNavigation) {
      _currentVibeIndex = widget.startIndex ?? 0;
      _pageController = PageController(initialPage: _currentVibeIndex);
      // Set initial vibe from the list
      _vibe = widget.vibesList![_currentVibeIndex];
      _hasPlayed = !_hasAudioOrVideo(); // FIX: Immediate reply for image-only
      _isLoading = false;
      _initAnimations();
    } else if (widget.vibe != null) {
      _vibe = widget.vibe;
      _hasPlayed = !_hasAudioOrVideo(); // FIX: Immediate reply for image-only
      _isLoading = false;
      _initAnimations();
    } else if (widget.vibeId != null) {
      _fetchVibe(widget.vibeId!);
    } else {
      setState(() {
        _isLoading = false;
        _error = "Vibe not found";
      });
    }
  }
  
  Future<void> _fetchVibe(String id) async {
    try {
      final vibe = await ref.read(vibeServiceProvider).getVibeById(id);
      if (mounted) {
        setState(() {
          _vibe = vibe;
          _isLoading = false;
          if (vibe != null) {
            // FIX: Set _hasPlayed for image-only vibes (same as other init paths)
            _hasPlayed = !_hasAudioOrVideo();
            _initAnimations();
          } else {
            _error = "Vibe not found";
          }
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isLoading = false;
          _error = "Error loading vibe";
        });
      }
    }
  }
  
  /// SWIPE NAVIGATION: Handle page change when user swipes to different vibe
  void _onVibeChanged(int newIndex) {
    if (!_hasSwipeNavigation || newIndex == _currentVibeIndex) return;
    
    // Stop current playback
    _videoController?.pause();
    _audioService?.stop();
    
    // Clean up video controller for previous vibe
    _videoController?.removeListener(_videoListener);
    _videoController?.dispose();
    _videoController = null;
    _isVideoInitialized = false;
    
    // Reset playback state
    _isPlaying = false;
    _playbackProgress = 0.0;
    
    setState(() {
      _currentVibeIndex = newIndex;
      _vibe = widget.vibesList![newIndex];
      _hasPlayed = !_hasAudioOrVideo(); // FIX: Immediate reply for image-only
    });
    
    // Initialize media for new vibe
    if (_vibe!.isVideo && _vibe!.videoUrl != null) {
      _initVideoPlayer(_vibe!.videoUrl!);
    } else {
      // Auto-play audio for non-video vibes
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _playAudio();
      });
    }

    // HYBRID: Auto-load transcription for "Read-First" intake
    _loadTranscription(silent: true);
  }
  
  void _initAnimations() {
    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 500),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeOut),
    );
    _fadeController.forward();

    // NEW: Trigger Ghost Hints after a short delay (Progressive Disclosure)
    // Only show hints if user has never seen them before
    _checkAndShowGhostHints();

    // Pulse animation for "Hold to Reply" hit (always running, applied conditionally)
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    )..repeat(reverse: true);
    
    _pulseAnimation = Tween<double>(begin: 1.0, end: 1.02).animate( // Subtle 2% zoom pulse
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );

    // Initialize video player for video vibes (uses built-in audio, no separate audio service)
    if (_vibe != null && _vibe!.isVideo && _vibe!.videoUrl != null) {
      _initVideoPlayer(_vibe!.videoUrl!);
      // Note: Don't call _playAudio() for video vibes - video has built-in audio
    } else {
      // Photo vibes: Auto-play separate audio on entry
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _playAudio();
      });
    }

    // HYBRID: Auto-load transcription for "Read-First" intake
    _loadTranscription(silent: true);
  }
  
  Future<void> _initVideoPlayer(String videoUrl) async {
    // FIX Issue 3: Track current URL to cancel stale initializations
    _currentVibeUrl = videoUrl;
    
    // Claim Hardware Resource for Video
    if (_vibe != null) {
      ref.read(activeContentIdProvider.notifier).state = _vibe!.id;
    }
    
    final controller = VideoPlayerController.networkUrl(Uri.parse(videoUrl));
    _videoController = controller; // Keep track for dispose()

    try {
      await controller.initialize();
      
      // FIX: Ensure widget is mounted AND the controller is still the current one
      // AND the URL still matches the current target (Issue 3 - prevents stale init)
      if (!mounted || _videoController != controller || _currentVibeUrl != videoUrl) return;

      // FIX Issue 5: Enable looping for short-form video content (TikTok/Locket style)
      controller.setLooping(true);
      controller.setVolume(1.0); 
      
      // FIX: Listen to the controller for state (Buffering/Playing)
      controller.addListener(_videoListener);
      
      if (mounted) {
        setState(() {
          _isVideoInitialized = true;
        });
      }

      // Android Stability: Short delay to ensure surface is ready
      await Future.delayed(const Duration(milliseconds: 100));
      if (mounted && _videoController == controller) {
        await controller.play();
      }
    } catch (e) {
      debugPrint('Error initializing video player: $e');
    }
  }

  // New Listener Method for Video
  void _videoListener() {
    if (!mounted || _videoController == null) return;
    
    // Check playback state via VideoPlayerValue
    final isPlaying = _videoController!.value.isPlaying;
    final isBuffering = _videoController!.value.isBuffering;
    final position = _videoController!.value.position;
    final duration = _videoController!.value.duration;
    
    // FIX: Only show playing if actually playing AND not buffering
    final shouldShowPlaying = isPlaying && !isBuffering;
    
    // Update state if anything changed
    if (_isPlaying != shouldShowPlaying || _isBuffering != isBuffering) {
      if (mounted) {
        setState(() {
          _isPlaying = shouldShowPlaying;
          _isBuffering = isBuffering;
        });
      }
    }
    
    // Handle progress updates
    if (duration.inMilliseconds > 0) {
      if (mounted) {
        setState(() {
          _playbackProgress = position.inMilliseconds / duration.inMilliseconds;
        });
      }
    }

    // Check completion
    // FIX Issue 2: Mark as played at 50% or after 3 seconds (relaxed from 90%)
    // This matches user attention spans for short-form content
    final percentComplete = duration.inMilliseconds > 0 
        ? position.inMilliseconds / duration.inMilliseconds 
        : 0.0;
    final threeSecondsWatched = position.inMilliseconds >= 3000;
        
    if (duration.inMilliseconds > 0 && 
        (percentComplete > 0.5 || threeSecondsWatched)) {
      if (!_hasPlayed) {
        setState(() {
          _hasPlayed = true;
        });
        ref.read(vibeServiceProvider).markAsPlayed(_vibe!.id);
      }
    }
  }
  
  void _onVideoPositionChanged() {
    if (!mounted || _videoController == null) return;
    
    final position = _videoController!.value.position;
    final duration = _videoController!.value.duration;
    
    if (duration.inMilliseconds > 0) {
      setState(() {
        _playbackProgress = position.inMilliseconds / duration.inMilliseconds;
      });
    }
    
    // Check if video completed
    if (_videoController!.value.position >= _videoController!.value.duration &&
        _videoController!.value.duration.inMilliseconds > 0) {
      if (!_hasPlayed) {
        setState(() {
          _isPlaying = false;
          _hasPlayed = true;
        });
        // Mark as played
        ref.read(vibeServiceProvider).markAsPlayed(_vibe!.id);
      }
    }
  }

  @override
  void dispose() {
    // LIFECYCLE FIX: Remove observer
    WidgetsBinding.instance.removeObserver(this);
    
    // FIX: Stop recording if user is currently replying (prevents mic lock on Android)
    if (_isReplying) {
      ref.read(recordingStateProvider.notifier).stopRecording().then((_) {
        debugPrint('Background recording stopped safely during dispose.');
      }).catchError((e) {
        debugPrint('Error cleaning up recording on dispose: $e');
      });
    }

    _recordingLimitTimer?.cancel();
    
    // FIX: Cancel subscriptions to prevent leaks
    _audioStateSubscription?.cancel();
    _audioPositionSubscription?.cancel();
    
    _fadeController.dispose();
    _pulseController.dispose();
    _videoController?.removeListener(_videoListener);
    _videoController?.dispose();
    
    // SWIPE NAVIGATION: Dispose PageController
    _pageController?.dispose();
    
    // NOTE: scopedAudioPlayerProvider is autoDispose, so we don't need manual cleanup
    // unless we want to be explicit.
    _emojiCleanupTimer?.cancel();
    _textReplyController.dispose();
    _textReplyFocusNode.dispose();
    _ghostHintTimer?.cancel();
    
    // FIX: Dispose preview player
    _previewPlayer?.dispose();
    
    super.dispose();
  }

  // LIFECYCLE FIX: Pause media when app is backgrounded
  // Prevents "zombie audio" (sound playing while app is closed)
  // and UI desync (Play button showing "Pause" when video is stopped)
  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused || state == AppLifecycleState.inactive) {
      // Force pause video
      _videoController?.pause();
      
      // Force STOP active audio (if any) by clearing global ID
      ref.read(activeContentIdProvider.notifier).state = null;
      
      // Sync UI state

      if (mounted) {
        setState(() => _isPlaying = false);
      }
      debugPrint('PlayerScreen: Stopped audio on app background to release resources');
    }
  }

  Future<void> _playAudio() async {
    // Prevent duplicate calls if already trying to play
    if (_isPlaying) return;

    HapticFeedback.mediumImpact();

    // 1. Claim Hardware Resource (Stop others)
    ref.read(activeContentIdProvider.notifier).state = _vibe!.id;

    // 2. Get Scoped Player (Auto-disposed when screen closes)
    final audioService = ref.read(scopedAudioPlayerProvider(_vibe!.id));

    // FIX: Cancel old subscriptions first to prevent zombies
    await _audioPositionSubscription?.cancel();
    await _audioStateSubscription?.cancel();

    // FIX: Assign subscription to variable
    // FIX: Access direct `AudioPlayer` getters on the scoped instance
    _audioPositionSubscription = audioService.onPositionChanged.listen((position) {
      if (mounted) {
        setState(() {
          final totalDurationMs = (_vibe!.audioDuration * 1000).toDouble();
          // SAFETY: Check for zero to prevent NaN crash
          if (totalDurationMs > 0) {
            _playbackProgress = (position.inMilliseconds / totalDurationMs).clamp(0.0, 1.0);
          } else {
            _playbackProgress = 0.0;
          }
        });
      }
    });

    // FIX: Assign state subscription and drive _isPlaying from engine events
    // FIX: Access direct `AudioPlayer` getters on the scoped instance
    _audioStateSubscription = audioService.onPlayerStateChanged.listen((state) {
      if (mounted) {
        // Only consider 'playing' if we receive that specific state
        final bool isActuallyPlaying = state.name == 'playing';
        if (_isPlaying != isActuallyPlaying) {
          setState(() => _isPlaying = isActuallyPlaying);
        }
        
        if (state.name == 'completed') {
          setState(() {
            _isPlaying = false;
            _hasPlayed = true;
            // INSTANT REPLY: Show reply focus if opened from notification
            if (widget.fromNotification) {
              _showReplyFocus = true;
            }
          });
          // Mark as played
          ref.read(vibeServiceProvider).markAsPlayed(_vibe!.id);
        }
      }
    });

    // INSTANT REPLY: Pre-warm microphone permission during playback
    // This eliminates the permission dialog delay when user taps reply
    if (!_micPreWarmed) {
      _preWarmMicrophone();
    }

    // ðŸ”´ CRITICAL FIX 1: Ensure audio URL is NOT empty to prevent FileNotFoundException
    // This happens for video vibes or vibes where audio upload failed.
    if (_vibe!.audioUrl.isEmpty) {
      debugPrint('PlayerScreen: Skipping audio playback (audioUrl is empty)');
      return;
    }

    // ðŸ”´ CRITICAL FIX 2: Verify the widget is still on screen before starting playback
    // This prevents "Zombie Audio" if the screen was closed during permissions/warmup
    if (!mounted) return;

    await audioService.play(UrlSource(_vibe!.audioUrl));
  }
  
  /// Pre-warm microphone: Check permission in background during playback
  /// User sees no dialog - just prepares the system for instant recording
  Future<void> _preWarmMicrophone() async {
    try {
      final recorder = AudioRecorder();
      final hasPermission = await recorder.hasPermission();
      if (mounted) {
        setState(() => _micPreWarmed = hasPermission);
      }
      debugPrint('PlayerScreen: Mic pre-warmed, hasPermission: $hasPermission');
    } catch (e) {
      debugPrint('PlayerScreen: Mic pre-warm failed: $e');
    }
  }

  void _togglePlayback() async {
    HapticFeedback.selectionClick();
    
    // FIX: Video vibes - explicit handling with defensive checks
    if (_vibe != null && _vibe!.isVideo) {
      // DEFENSIVE: Check if controller is initialized before attempting toggle
      if (_videoController != null && _videoController!.value.isInitialized) {
        if (_isPlaying) {
          _videoController!.pause();
          setState(() => _isPlaying = false);
        } else {
          // If video ended, seek to start
          if (_videoController!.value.position >= _videoController!.value.duration) {
            await _videoController!.seekTo(Duration.zero);
          }
          _videoController!.play();
          setState(() => _isPlaying = true);
        }
      }
      // CRITICAL: Stop here - do NOT fall through to audio service
      return;
    }
    
    // Photo vibes: Control AudioService
    final audioService = ref.read(scopedAudioPlayerProvider(_vibe!.id));
    
    // Claim resource if not already mine
    ref.read(activeContentIdProvider.notifier).state = _vibe!.id;
    
    if (_isPlaying) {
      await audioService.pause();
      setState(() => _isPlaying = false);
    } else {
      await audioService.resume();
      setState(() => _isPlaying = true);
    }
  }

  void _startReply() {
    // FIX: CRITICAL - Pause all media BEFORE starting recording
    // This prevents the microphone from capturing speaker output (feedback loop)
    // Clear active ID stops all players
    ref.read(activeContentIdProvider.notifier).state = null;
    _videoController?.pause();
    setState(() => _isPlaying = false);
    
    // Now start recording
    setState(() => _isReplying = true);
    ref.read(recordingStateProvider.notifier).startRecording();
    HapticFeedback.heavyImpact();

    // Consistency: Enforce 15s Limit (Sync with Camera)
    _recordingLimitTimer?.cancel();
    _recordingLimitTimer = Timer(const Duration(seconds: 15), () {
      if (_isReplying && mounted) {
        _stopReply(); // Automatically stop recording
        HapticFeedback.heavyImpact(); // Alert user it stopped
      }
    });
  }

  Future<void> _stopReply() async {
    _recordingLimitTimer?.cancel();
    
    try {
      final path = await ref.read(recordingStateProvider.notifier).stopRecording();
      
      if (path != null) {
        // Enter preview mode instead of sending immediately
        setState(() {
          _pendingReplyPath = path;
          _isPreviewingReply = true;
        });
        HapticFeedback.mediumImpact();
      }
    } catch (e) {
      debugPrint('Error stopping recorder: $e');
    } finally {
      if (mounted) {
        setState(() => _isReplying = false);
      }
    }
  }
  
  /// Play the recorded audio preview
  Future<void> _playPreview() async {
    if (_pendingReplyPath == null) return;
    
    try {
      _previewPlayer ??= AudioPlayer();
      await _previewPlayer!.play(DeviceFileSource(_pendingReplyPath!));
      setState(() => _isPlayingPreview = true);
      
      // Listen for completion
      _previewPlayer!.onPlayerComplete.listen((_) {
        if (mounted) {
          setState(() => _isPlayingPreview = false);
        }
      });
    } catch (e) {
      debugPrint('Error playing preview: $e');
    }
  }
  
  /// Pause the preview playback
  Future<void> _pausePreview() async {
    await _previewPlayer?.pause();
    setState(() => _isPlayingPreview = false);
  }
  
  /// Cancel the pending reply
  Future<void> _cancelReply() async {
    // Stop preview if playing
    await _previewPlayer?.stop();
    
    // Delete the recorded file
    if (_pendingReplyPath != null) {
      try {
        await File(_pendingReplyPath!).delete();
      } catch (_) {}
    }
    
    setState(() {
      _pendingReplyPath = null;
      _isPreviewingReply = false;
      _isPlayingPreview = false;
    });
    HapticFeedback.lightImpact();
  }
  
  /// Confirm and send the reply
  Future<void> _confirmSendReply() async {
    if (_pendingReplyPath == null) return;
    
    // Stop preview if playing
    await _previewPlayer?.stop();
    
    final path = _pendingReplyPath!;
    
    // Reset preview state
    setState(() {
      _pendingReplyPath = null;
      _isPreviewingReply = false;
      _isPlayingPreview = false;
    });
    
    // Send the reply
    try {
      await ref.read(vibeServiceProvider).replyToVibe(
        originalVibeId: _vibe!.id,
        receiverId: _vibe!.senderId,
        audioFile: File(path),
        audioDuration: ref.read(recordingDurationProvider),
        waveformData: ref.read(waveformDataProvider),
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Reply sent!'),
            backgroundColor: AppColors.success,
          ),
        );
        
        if (context.canPop()) {
          context.pop();
        } else {
          context.go(AppRoutes.home);
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to send reply: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        backgroundColor: AppColors.background,
        body: Center(
          child: CircularProgressIndicator(color: AppColors.primaryAction),
        ),
      );
    }
    
    if (_error != null || _vibe == null) {
      return Scaffold(
        backgroundColor: AppColors.background,
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.error_outline, color: AppColors.error, size: 48),
              const SizedBox(height: 16),
              Text(
                _error ?? "Vibe unavailable",
                style: AppTypography.bodyMedium.copyWith(color: AppColors.textSecondary),
              ),
              const SizedBox(height: 24),
              ElevatedButton(
                onPressed: () => context.go(AppRoutes.home),
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppColors.primaryAction,
                ),
                child: Text('Go Home', style: AppTypography.buttonText),
              ),
            ],
          ),
        ),
      );
    }

    // Determine content type
    String statusText = _getStatusText();
    Color statusColor = _getStatusColor();

    // Determine content type
    // Determine content type
    final bool isAudioOnly = _vibe!.isAudioOnly;
    final bool isVideo = _vibe!.isVideo && _vibe!.videoUrl != null;
    
    // FIX: Prioritize showing image if it exists, even if isAudioOnly flag is set
    // This prevents "Photo Only" vibes from appearing as "Audio Only" if flags are misconfigured
    final bool hasImage = !isVideo && _vibe!.imageUrl != null && _vibe!.imageUrl!.isNotEmpty;

    // ZOMBIE UI PREVENTION: Watch the scoped player to keep it alive
    ref.watch(scopedAudioPlayerProvider(_vibe!.id));
    
    // LISTEN for focus loss (Active ID changed -> Stop/Pause)
    ref.listen(activeContentIdProvider, (prev, next) {
      if (next != _vibe!.id) {
        // Someone else took audio focus!
        if (_videoController != null && _videoController!.value.isPlaying) {
          _videoController!.pause();
        }
        if (mounted) setState(() => _isPlaying = false);
      }
    });


    return Scaffold(
      backgroundColor: AppColors.background,
      resizeToAvoidBottomInset: false, // FIX: Prevent keyboard from squashing the "Portal"
      body: Builder( // WRAP IN BUILDER TO USE CONTEXT SAFELY
        builder: (context) {
          // REDUNDANT LISTENERS REMOVED: (ref.watch/ref.listen was here and caused crash)
          
          return LayoutBuilder(
            builder: (context, constraints) {
          final scale = constraints.maxWidth / 360;
          
          return GestureDetector(
            // Hold anywhere to reply (after playback)
            onTap: () {
              if (_isTextReplying) {
                _textReplyFocusNode.unfocus();
                setState(() => _isTextReplying = false);
              } else {
                _togglePlayback();
              }
            },
            onDoubleTap: () => _addQuickReaction('â¤ï¸'),
            // SWIPE NAVIGATION: Horizontal drag to navigate between vibes
            onHorizontalDragEnd: _hasSwipeNavigation ? (details) {
              final velocity = details.primaryVelocity ?? 0;
              if (velocity > 300 && _currentVibeIndex > 0) {
                // Swipe right -> previous vibe
                _onVibeChanged(_currentVibeIndex - 1);
              } else if (velocity < -300 && _currentVibeIndex < widget.vibesList!.length - 1) {
                // Swipe left -> next vibe
                _onVibeChanged(_currentVibeIndex + 1);
              }
            } : null,
            // VERTICAL DISMISS: Flick up or down to close the player
            onVerticalDragEnd: (details) {
              final velocity = details.primaryVelocity ?? 0;
              if (velocity.abs() > 500) {
                context.pop();
              }
            },
            child: Stack(
              fit: StackFit.expand,
              children: [
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // BACKGROUND: Different for each content type
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (isVideo && _isVideoInitialized && _videoController != null)
                  _buildVideoBackground(scale)
                else if (isVideo && !_isVideoInitialized && _vibe!.imageUrl != null && _vibe!.imageUrl!.isNotEmpty)
                  _buildImageBackground(scale)
                else if (hasImage)
                  _buildImageBackground(scale)
                else if (isAudioOnly)
                  _buildAudioOnlyBlurredBackground(scale)
                else
                  _buildCyberpunkBackground(scale),



                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NEW: GHOST HINTS (Onboarding discovery)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (_showGhostHints)
                  _buildGhostHints(scale),

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NEW: EMOJI RAIN (Full Screen)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                IgnorePointer(
                  child: Stack(
                    fit: StackFit.expand,
                    children: _floatingEmojis.map((e) => Positioned(
                      left: e.x,
                      top: e.y,
                      child: Opacity(
                        opacity: e.opacity.clamp(0.0, 1.0),
                        child: Text(
                          e.emoji,
                          style: TextStyle(fontSize: 32 * scale),
                        ),
                      ),
                    )).toList(),
                  ),
                ),

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // MAIN CONTENT OVERLAY (Safe Area Column)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                SafeArea(
                  child: Column(
                    children: [
                      _buildLocketTopBar(statusText, statusColor, scale),
                      
                      if (_hasSwipeNavigation)
                        _buildPageIndicator(scale),

                      const Spacer(flex: 1),

                      if (isAudioOnly)
                        _buildCenteredAvatar(scale)
                      else
                        const SizedBox.shrink(),

                      const Spacer(flex: 1),

                      if (_isReplying)
                        RepaintBoundary(
                          child: Consumer(
                            builder: (context, ref, _) {
                              final waveformData = ref.watch(waveformDataProvider);
                              final recordingDuration = ref.watch(recordingDurationProvider);
                              return _buildRecordingReplyUI(recordingDuration, waveformData, scale);
                            },
                          ),
                        )
                      else if (_hasAudioOrVideo())
                        _buildPlaybackUI(scale)
                      else
                        _buildImageOnlyUI(scale),

                      SizedBox(height: 40 * scale),
                    ],
                  ),
                ),
                
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // NEW: HYBRID PORTAL OVERLAYS (Renamed: "The Sticker Layer")
                // Placed LAST to ensure it renders ON TOP of the avatar/video
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                _buildPortalOverlays(scale),
              ],
            ),
          );
        },
      );
    },
  ),
);
  }

  /// Dynamic status text based on current state
  /// SIMPLIFIED: When playing, show nothing (slider is the indicator)
  /// When not playing, show timestamp
  String _getStatusText() {
    if (_isReplying) {
      return 'Recording...';
    } else if (_isPlaying && _hasAudioOrVideo()) {
      // SIMPLIFIED: Don't show "Now playing" - slider indicates this
      return '';
    } else {
      // Paused/Done/Image-only: Show timestamp
      return _formatTime(_vibe!.createdAt);
    }
  }

  /// Dynamic status color
  Color _getStatusColor() {
    if (_isReplying) {
      return Colors.green;
    } else if (_isPlaying && _hasAudioOrVideo()) {
      return Colors.white70;
    } else {
      return Colors.white54;
    }
  }

  /// Check if this vibe has audio or video content to play
  bool _hasAudioOrVideo() {
    if (_vibe == null) return false;
    // Video vibe
    if (_vibe!.isVideo && _vibe!.videoUrl != null && _vibe!.videoUrl!.isNotEmpty) return true;
    // Audio vibe (either audio-only or image+audio)
    if (_vibe!.audioUrl != null && _vibe!.audioUrl!.isNotEmpty) return true;
    return false;
  }

  /// SWIPE NAVIGATION: TikTok-style dots indicator
  Widget _buildPageIndicator(double scale) {
    if (!_hasSwipeNavigation) return const SizedBox.shrink();
    
    final total = widget.vibesList!.length;
    final current = _currentVibeIndex;
    
    // TikTok shows max 7 dots with scrolling window
    const maxDots = 7;
    final showDots = total <= maxDots;
    
    return Padding(
      padding: EdgeInsets.symmetric(vertical: 8 * scale),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: showDots
            ? _buildDots(total, current, scale)
            : _buildScrollingDots(total, current, maxDots, scale),
      ),
    );
  }
  
  /// Build static dots for small lists
  List<Widget> _buildDots(int total, int current, double scaleFactor) {
    return List.generate(total, (index) {
      final isActive = index == current;
      return AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOut,
        margin: EdgeInsets.symmetric(horizontal: 3 * scaleFactor),
        width: isActive ? 8 * scaleFactor : 6 * scaleFactor,
        height: isActive ? 8 * scaleFactor : 6 * scaleFactor,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: isActive 
              ? Colors.white 
              : Colors.white.withOpacity(0.4),
        ),
      );
    });
  }
  
  /// Build scrolling dots for large lists (TikTok style)
  List<Widget> _buildScrollingDots(int total, int current, int maxDots, double scaleFactor) {
    // Calculate visible window
    final halfWindow = maxDots ~/ 2;
    int start = (current - halfWindow).clamp(0, total - maxDots);
    int end = (start + maxDots).clamp(0, total);
    
    return List.generate(end - start, (i) {
      final index = start + i;
      final isActive = index == current;
      
      // Edge dots are smaller (TikTok style fade effect)
      final distanceFromCenter = (index - current).abs();
      final dotScale = distanceFromCenter <= 1 ? 1.0 : 
                       distanceFromCenter == 2 ? 0.8 : 0.6;
      
      return AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOut,
        margin: EdgeInsets.symmetric(horizontal: 3 * scaleFactor),
        width: (isActive ? 8 : 6) * dotScale * scaleFactor,
        height: (isActive ? 8 : 6) * dotScale * scaleFactor,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: isActive 
              ? Colors.white 
              : Colors.white.withOpacity(0.4 * dotScale),
        ),
      );
    });
  }


  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// BACKGROUND BUILDERS - Different for each content type
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// VIDEO BACKGROUND: "Atmospheric Portal" Design
  /// - Blurred version of video fills entire screen (atmosphere)
  /// - Crisp 1:1 square video floats in center (the portal)
  /// - Drop shadow gives depth/polaroid effect
  Widget _buildVideoBackground(double scale) {
    final screenWidth = MediaQuery.of(context).size.width;
    final squareSize = screenWidth; // Match CameraScreen full width 
    final videoSize = _videoController!.value.size;
    
    return Stack(
      fit: StackFit.expand,
      children: [
        // LAYER 0: CYBERPUNK MESH BASE
        _buildCyberpunkBackground(scale),

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LAYER 1: OPTIMIZED BLURRED THUMBNAIL (No Live Video Blur!)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // FIX: Replaced BackdropFilter over VideoPlayer with ImageFiltered over Image
        // This saves GPU resources and prevents jank/battery drain.
        if (_vibe!.imageUrl != null && _vibe!.imageUrl!.isNotEmpty)
          Transform.scale(
            scale: 1.2,
            child: ImageFiltered(
              imageFilter: ImageFilter.blur(sigmaX: 40 * scale, sigmaY: 40 * scale),
              child: CachedNetworkImage(
                imageUrl: _vibe!.imageUrl!,
                fit: BoxFit.cover,
                width: double.infinity,
                height: double.infinity,
                // MEMORY FIX: Decode at low resolution for heavy blur background
                // This saves memory (50x50 bitmap vs 1080p) and speeds up the "Pre-warm"
                memCacheWidth: 50, 
                placeholder: (_, __) => Container(color: const Color(0xFF111111)),
                errorWidget: (_, __, ___) => Container(color: const Color(0xFF111111)),
              ),
            ),
          )
        else
          // Fallback if no thumbnail: just use the cyberpunk mesh
           _buildCyberpunkBackground(scale),

        // Dimming overlay for contrast
        Container(color: Colors.black.withOpacity(0.4)),
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LAYER 2: FLOATING 1:1 SQUARE VIDEO (the portal)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        Center(
          child: GestureDetector(
            onTap: _togglePlayback,
            child: Container(
              width: squareSize,
              height: squareSize,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(24 * scale),
                // Subtle backlight glow only (no drop shadow to avoid banding)
                boxShadow: [
                  BoxShadow(
                    color: AppColors.primaryAction.withOpacity(0.15),
                    blurRadius: 50 * scale,
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(24 * scale),
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    // The crisp 1:1 video (fills the square)
                    FittedBox(
                      fit: BoxFit.cover,
                      child: SizedBox(
                        width: videoSize.width,
                        height: videoSize.height,
                        child: VideoPlayer(_videoController!),
                      ),
                    ),
                    
                    // Subtle inner border for definition
                    Container(
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(24 * scale),
                        border: Border.all(
                          color: Colors.white.withOpacity(0.1),
                          width: 1 * scale,
                        ),
                      ),
                    ),
                    
                    // Standard Play/Pause indicator
                    _buildCenteredPlayIndicator(
                      isPlaying: _isPlaying,
                      showPauseIcon: true,
                      scale: scale,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }

  /// IMAGE + AUDIO BACKGROUND: "Atmospheric Portal" Design
  /// - Blurred version of image fills entire screen (atmosphere)
  /// - Crisp 1:1 square floats in center (the portal)
  /// - Drop shadow gives depth/polaroid effect
  Widget _buildImageBackground(double scale) {
    final screenWidth = MediaQuery.of(context).size.width;
    final squareSize = screenWidth; // Match CameraScreen full width
    
    return Stack(
      fit: StackFit.expand,
      children: [
        // LAYER 0: CYBERPUNK MESH BASE
        _buildCyberpunkBackground(scale),

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LAYER 1: ATMOSPHERIC BLUR (fills entire screen)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Scale to 120% to ensure no gaps at edges when blurred
        Transform.scale(
          scale: 1.2,
          child: CachedNetworkImage(
            imageUrl: _vibe!.imageUrl!,
            fit: BoxFit.cover,
            // FIX: Uses same cache as dashboard - loads instantly
            placeholder: (_, __) => Container(color: AppColors.surface),
            errorWidget: (_, __, ___) => _buildGradientFallback(),
          ),
        ),
        
        // Heavy blur effect (sigma 40 for atmospheric feel)
        BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 40 * scale, sigmaY: 40 * scale),
          child: Container(color: Colors.transparent),
        ),
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LAYER 2: FLOATING 1:1 SQUARE (the portal)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        Center(
          child: GestureDetector(
            onTap: _togglePlayback,
            child: Container(
              width: squareSize,
              height: squareSize,
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(24 * scale),
                // Subtle backlight glow only (no drop shadow to avoid banding)
                boxShadow: [
                  BoxShadow(
                    color: AppColors.primaryAction.withOpacity(0.15),
                    blurRadius: 50 * scale,
                    spreadRadius: 0,
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(24 * scale),
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    // The crisp, uncropped 1:1 image (uses cache from dashboard)
                    CachedNetworkImage(
                      imageUrl: _vibe!.imageUrl!,
                      fit: BoxFit.cover, // Fills the square, may crop slightly
                      // FIX: Uses same cache as dashboard - loads instantly
                      placeholder: (_, __) => Container(color: Colors.grey[900]),
                      errorWidget: (_, __, ___) => Container(
                        color: Colors.grey[900],
                        child: Center(
                          child: Icon(Icons.image_not_supported, color: Colors.white54, size: 48 * scale),
                        ),
                      ),
                    ),
                    
                    // Subtle inner border for definition
                    Container(
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(24 * scale),
                        border: Border.all(
                          color: Colors.white.withOpacity(0.1),
                          width: 1 * scale,
                        ),
                      ),
                    ),
                    
                    // Standard Play/Pause indicator - ONLY if has audio
                    if (_vibe!.audioUrl != null && _vibe!.audioUrl!.isNotEmpty)
                      _buildCenteredPlayIndicator(
                        isPlaying: _isPlaying,
                        isBuffering: _isBuffering, // Pass buffering state
                        showPauseIcon: false, // For photos, usually just show play arrow when paused
                        scale: scale,
                      ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }

  /// AUDIO ONLY BACKGROUND: Blurred avatar with gradient
  Widget _buildAudioOnlyBlurredBackground(double scale) {
    return Stack(
      fit: StackFit.expand,
      children: [
        // LAYER 0: CYBERPUNK MESH BASE
        _buildCyberpunkBackground(scale),

        // Layer 1: Sender's avatar (will be blurred) - uses cache
        if (_vibe?.senderAvatar != null && _vibe!.senderAvatar!.isNotEmpty)
          CachedNetworkImage(
            imageUrl: _vibe!.senderAvatar!,
            fit: BoxFit.cover,
            // FIX: Uses black placeholder to prevent color flash
            placeholder: (_, __) => Container(color: AppColors.surface),
            errorWidget: (_, __, ___) => _buildGradientFallback(),
          )
        else
          _buildGradientFallback(),
        
        // Layer 2: Heavy blur effect
        BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 60, sigmaY: 60),
          child: Container(color: Colors.transparent),
        ),
        
        // Layer 3: Dark gradient overlay
        Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black.withOpacity(0.3),
                Colors.black.withOpacity(0.4),
                Colors.black.withOpacity(0.6),
              ],
            ),
          ),
        ),
      ],
    );
  }

  /// Gradient fallback for audio-only when no avatar
  /// Uses subtle dark gradient to prevent jarring color flash
  Widget _buildGradientFallback() {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topCenter,
          end: Alignment.bottomCenter,
          colors: [
            Colors.grey[900]!,
            AppColors.background,
            Colors.grey[900]!,
          ],
        ),
      ),
    );
  }

  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// CENTER CONTENT BUILDERS - Different for each content type
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// Standardized Play indicator for the "Atmospheric Portal"
  Widget _buildCenteredPlayIndicator({
    required bool isPlaying, 
    required bool showPauseIcon, 
    bool isBuffering = false, // Optional buffering state
    required double scale,
  }) {
    // If buffering, show loading spinner regardless of play state
    if (isBuffering) {
      return Container(
        color: Colors.black.withOpacity(0.2), // Subtle dim
        child: Center(
          child: SizedBox(
            width: 50 * scale,
            height: 50 * scale,
            child: CircularProgressIndicator(
              color: Colors.white,
              strokeWidth: 3 * scale,
            ),
          ),
        ),
      );
    }

    return AnimatedOpacity(
      opacity: isPlaying ? 0.0 : 1.0,
      duration: const Duration(milliseconds: 300),
      child: Container(
        color: Colors.black.withOpacity(0.5),
        child: Center(
          child: Container(
            width: 72 * scale,
            height: 72 * scale,
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.9),
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.2),
                  blurRadius: 20 * scale,
                  spreadRadius: 5 * scale,
                ),
              ],
            ),
            child: Icon(
              isPlaying ? Icons.pause : Icons.play_arrow,
              color: Colors.black,
              size: 40 * scale,
            ),
          ),
        ),
      ),
    );
  }


  /// 2025: Locket-style minimalist top bar: [âŒ„]  Name â€¢ Time  [â€¢â€¢â€¢]
  Widget _buildLocketTopBar(String statusText, Color statusColor, double scale) {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 16 * scale, vertical: 8 * scale),
      child: Row(
        children: [
          // Close button (chevron down)
          GestureDetector(
            onTap: () => context.pop(),
            child: Container(
              width: 40 * scale,
              height: 40 * scale,
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.arrow_back_ios_new,
                color: Colors.white,
                size: 18 * scale,
              ),
            ),
          ),

          SizedBox(width: 12 * scale),

          // Metadata Cluster (Centered or flexible)
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  _vibe!.senderName,
                  style: TextStyle(
                    color: Colors.white,
                    fontSize: 15 * scale,
                    fontWeight: FontWeight.w900,
                    letterSpacing: -0.2 * scale,
                  ),
                ),
                Text(
                  _formatTimeAgo(_vibe!.createdAt),
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.5),
                    fontSize: 11 * scale,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),

          // Options button (three dots)
          GestureDetector(
            onTap: () => _showOptionsSheet(),
            child: Container(
              width: 40 * scale,
              height: 40 * scale,
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.1),
                shape: BoxShape.circle,
              ),
              child: Icon(
                Icons.more_horiz,
                color: Colors.white,
                size: 22 * scale,
              ),
            ),
          ),
        ],
      ),
    );
  }

  /// Centered avatar with pulsing concentric rings (Locket style)
  Widget _buildCenteredAvatar(double scale) {
    final bool showPulse = _isPlaying;
    final double avatarSize = _isReplying ? 100.0 * scale : 120.0 * scale;

    return GestureDetector(
      onTap: _togglePlayback,
      child: SizedBox(
        width: 250 * scale,
        height: 250 * scale,
        child: Stack(
          alignment: Alignment.center,
          children: [
            // Pulsing rings (only when playing)
            if (showPulse) ...[
              // Outer ring
              AnimatedBuilder(
                animation: _pulseController,
                builder: (context, child) {
                  final ringScale = 1.0 + (_pulseController.value * 0.15);
                  final opacity = 1.0 - (_pulseController.value * 0.7);
                  return Transform.scale(
                    scale: ringScale,
                    child: Container(
                      width: avatarSize + (80 * scale),
                      height: avatarSize + (80 * scale),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: Colors.purple.withOpacity(opacity * 0.3),
                          width: 1.5 * scale,
                        ),
                      ),
                    ),
                  );
                },
              ),
              // Middle ring
              AnimatedBuilder(
                animation: _pulseController,
                builder: (context, child) {
                  final ringScale = 1.0 + (_pulseController.value * 0.1);
                  final opacity = 1.0 - (_pulseController.value * 0.5);
                  return Transform.scale(
                    scale: ringScale,
                    child: Container(
                      width: avatarSize + (50 * scale),
                      height: avatarSize + (50 * scale),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: Colors.purple.withOpacity(opacity * 0.4),
                          width: 1.5 * scale,
                        ),
                      ),
                    ),
                  );
                },
              ),
              // Inner ring
              AnimatedBuilder(
                animation: _pulseController,
                builder: (context, child) {
                  final ringScale = 1.0 + (_pulseController.value * 0.05);
                  final opacity = 1.0 - (_pulseController.value * 0.3);
                  return Transform.scale(
                    scale: ringScale,
                    child: Container(
                      width: avatarSize + (20 * scale),
                      height: avatarSize + (20 * scale),
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: Colors.purple.withOpacity(opacity * 0.5),
                          width: 1.5 * scale,
                        ),
                      ),
                    ),
                  );
                },
              ),
            ],

            // Avatar container with white border
            Container(
              width: avatarSize,
              height: avatarSize,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                border: Border.all(color: Colors.white.withOpacity(0.3), width: 3 * scale),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.3),
                    blurRadius: 20 * scale,
                    spreadRadius: 5 * scale,
                  ),
                ],
              ),
              child: ClipOval(
                child: Stack(
                  fit: StackFit.expand,
                  children: [
                    _vibe?.senderAvatar != null && _vibe!.senderAvatar!.isNotEmpty
                        ? Image.network(
                            _vibe!.senderAvatar!,
                            fit: BoxFit.cover,
                            errorBuilder: (_, __, ___) => _buildAvatarPlaceholder(),
                          )
                        : _buildAvatarPlaceholder(),
                    
                    // Standard Play/Pause indicator
                    _buildCenteredPlayIndicator(
                      isPlaying: _isPlaying,
                      showPauseIcon: true,
                      scale: scale,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildAvatarPlaceholder() {
    return Container(
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [Colors.purple.shade400, Colors.pink.shade400],
        ),
      ),
      child: const Icon(
        Icons.person,
        color: Colors.white,
        size: 48,
      ),
    );
  }

  /// Playback UI: Progress bar + Viral Sharing + Reply buttons
  /// SYMMETRY: Consistent 4-button action bar
  Widget _buildPlaybackUI(double scale) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        _buildUnifiedActionPill(scale),
      ],
    );
  }

  /// Image-only vibes UI (same as playback but without audio-specific indicators)
  Widget _buildImageOnlyUI(double scale) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        _buildUnifiedActionPill(scale),
      ],
    );
  }

  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// NEW: UNIFIED ACTION PILL (Gen Z Optimized)
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Widget _buildUnifiedActionPill(double scale) {
    // FIX: Get keyboard height to move pill above keyboard
    final keyboardHeight = MediaQuery.of(context).viewInsets.bottom;
    
    // === PREVIEW MODE UI ===
    if (_isPreviewingReply) {
      return Padding(
        padding: EdgeInsets.only(bottom: math.max(0, (MediaQuery.viewInsetsOf(context).bottom - 20) * scale)),
        child: Container(
          margin: EdgeInsets.symmetric(horizontal: 24 * scale),
          padding: EdgeInsets.symmetric(horizontal: 16 * scale, vertical: 12 * scale),
          decoration: BoxDecoration(
            color: AppColors.surface,
            borderRadius: BorderRadius.circular(32 * scale),
            border: Border.all(
              color: AppColors.primaryAction.withOpacity(0.4),
              width: 1.5 * scale,
            ),
            boxShadow: [
              BoxShadow(
                color: AppColors.primaryAction.withOpacity(0.15),
                blurRadius: 16 * scale,
                spreadRadius: 2 * scale,
              ),
            ],
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              // Cancel Button
              GestureDetector(
                onTap: _cancelReply,
                child: Container(
                  padding: EdgeInsets.all(12 * scale),
                  decoration: BoxDecoration(
                    color: AppColors.error.withOpacity(0.15),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    Icons.close,
                    color: AppColors.error,
                    size: 24 * scale,
                  ),
                ),
              ),
              
              // Play/Pause Preview Button
              GestureDetector(
                onTap: _isPlayingPreview ? _pausePreview : _playPreview,
                child: Container(
                  padding: EdgeInsets.all(16 * scale),
                  decoration: BoxDecoration(
                    color: Colors.white.withOpacity(0.1),
                    shape: BoxShape.circle,
                    border: Border.all(
                      color: Colors.white.withOpacity(0.2),
                      width: 2 * scale,
                    ),
                  ),
                  child: Icon(
                    _isPlayingPreview ? Icons.pause : Icons.play_arrow,
                    color: Colors.white,
                    size: 28 * scale,
                  ),
                ),
              ),
              
              // Send Button
              GestureDetector(
                onTap: _confirmSendReply,
                child: Container(
                  padding: EdgeInsets.all(12 * scale),
                  decoration: BoxDecoration(
                    gradient: AppColors.auraGradient,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    Icons.send,
                    color: Colors.white,
                    size: 24 * scale,
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }
    
    // === NORMAL MODE UI ===
    final bool canReply = _hasPlayed;
    final bool hasText = _textReplyController.text.isNotEmpty;

    return Padding(
      padding: EdgeInsets.only(bottom: math.max(0, (MediaQuery.viewInsetsOf(context).bottom - 20) * scale)),
      child: Stack(
        alignment: Alignment.topCenter,
        children: [
          Container(
            margin: EdgeInsets.symmetric(horizontal: 24 * scale),
            child: GestureDetector(
              onVerticalDragEnd: (details) {
                if (details.primaryVelocity! < -300 && canReply && !_isTextReplying) {
                  _navigateToCameraReply();
                }
              },
              onTap: (canReply && !_isTextReplying) 
                  ? () {
                      setState(() => _isTextReplying = true);
                      _textReplyFocusNode.requestFocus();
                    }
                  : null,
              onLongPressStart: (canReply && !_isTextReplying && !_isPreviewingReply) ? (_) => _startReply() : null,
              onLongPressEnd: (canReply && !_isTextReplying) ? (_) => _stopReply() : null,
              child: AnimatedContainer(
                duration: const Duration(milliseconds: 300),
                padding: EdgeInsets.symmetric(horizontal: 20 * scale, vertical: 12 * scale),
                decoration: BoxDecoration(
                  color: AppColors.surface, 
                  borderRadius: BorderRadius.circular(32 * scale),
                  border: Border.all(
                    color: _isTextReplying 
                        ? AppColors.primaryAction.withOpacity(0.3)
                        : Colors.white.withOpacity(0.08),
                    width: 1 * scale,
                  ),
                  boxShadow: [
                    if (_isReplying)
                      BoxShadow(
                        color: AppColors.error.withOpacity(0.3), // Ã¢Å“Â¨ Thermal Orange Glow
                        blurRadius: 25 * scale,
                        spreadRadius: 8 * scale,
                      ),
                    if (_isTextReplying)
                      BoxShadow(
                        color: AppColors.primaryAction.withOpacity(0.1),
                        blurRadius: 15 * scale,
                        spreadRadius: 2 * scale,
                      ),
                  ],
                ),
                child: Row(
                  children: [
                    // LEFT: Camera Icon
                    GestureDetector(
                      onTap: (canReply && !_isTextReplying) ? _navigateToCameraReply : null,
                      child: Container(
                        padding: EdgeInsets.all(8 * scale),
                        decoration: BoxDecoration(
                          color: Colors.white.withOpacity(0.05),
                          shape: BoxShape.circle,
                        ),
                        child: Icon(
                          Icons.camera_alt,
                          color: Colors.white.withOpacity(canReply ? 0.8 : 0.2),
                          size: 20 * scale,
                        ),
                      ),
                    ),
                    
                    SizedBox(width: 12 * scale),
      
                    // CENTER: Input / Label
                    Expanded(
                      child: _isTextReplying 
                        ? TextField(
                            controller: _textReplyController,
                            focusNode: _textReplyFocusNode,
                            style: TextStyle(color: Colors.white, fontSize: 15 * scale),
                            cursorColor: AppColors.primaryAction,
                            decoration: InputDecoration(
                              hintText: 'Reply...',
                              hintStyle: TextStyle(color: Colors.white24, fontSize: 15 * scale),
                              border: InputBorder.none,
                              isDense: true,
                              contentPadding: EdgeInsets.zero,
                            ),
                            onChanged: (val) => setState(() {}),
                            onSubmitted: (_) => _sendTextReply(),
                          )
                        : Center(
                            child: Text(
                              _isReplying 
                                ? 'RECORDING VIBE...' 
                                : (canReply ? 'Reply or Hold to record' : 'LISTEN FIRST'),
                              style: TextStyle(
                                color: canReply ? Colors.white70 : Colors.white24,
                                fontSize: 13 * scale,
                                fontWeight: FontWeight.w900,
                                letterSpacing: 0.5 * scale,
                              ),
                            ),
                          ),
                    ),
      
                    SizedBox(width: 12 * scale),
      
                    // RIGHT: Mic / Send
                    GestureDetector(
                      onTap: (hasText && _isTextReplying) ? _sendTextReply : null,
                      child: Container(
                        padding: EdgeInsets.all(8 * scale),
                        decoration: BoxDecoration(
                          color: (_isTextReplying && hasText) 
                              ? AppColors.primaryAction.withOpacity(0.2)
                              : Colors.white.withOpacity(0.05),
                          shape: BoxShape.circle,
                        ),
                        child: Icon(
                          (_isTextReplying && hasText) ? Icons.send : Icons.mic,
                          color: (_isTextReplying && hasText) 
                              ? AppColors.primaryAction 
                              : (_isReplying 
                                  ? AppColors.error 
                                  : Colors.white.withOpacity(canReply ? 0.8 : 0.2)),
                          size: 20 * scale,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          // INTEGRATED PROGRESS BAR
          if (_hasAudioOrVideo() && !_isReplying && !_isTextReplying)
            Positioned(
              top: 0,
              left: 56 * scale, 
              right: 56 * scale,
              child: Container(
                height: 2 * scale,
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.05),
                  borderRadius: BorderRadius.circular(1 * scale),
                ),
                child: FractionallySizedBox(
                  alignment: Alignment.centerLeft,
                  widthFactor: _playbackProgress.clamp(0.0, 1.0),
                  child: Container(
                    decoration: BoxDecoration(
                      color: AppColors.primaryAction,
                      borderRadius: BorderRadius.circular(1 * scale),
                      boxShadow: [
                        BoxShadow(
                          color: AppColors.primaryAction.withOpacity(0.5),
                          blurRadius: 4 * scale,
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _navigateToCameraReply() {
    HapticFeedback.mediumImpact();
    context.pushNamed(
      AppRoutes.camera,
      extra: _vibe, // Pass the VibeModel directly for the router to cast
    );
  }

  /// Unified Action Button (Viral / Secondary)
  Widget _buildModernActionButton({
    required IconData icon,
    required Color color,
    required VoidCallback onTap,
    Color? backgroundColor,
    Color? borderColor,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 52,
        height: 52,
        decoration: BoxDecoration(
          color: backgroundColor ?? Colors.white.withOpacity(0.1),
          shape: BoxShape.circle,
          border: borderColor != null ? Border.all(color: borderColor, width: 1) : null,
        ),
        child: Icon(icon, color: color, size: 22),
      ),
    );
  }

  /// Unified Primary Button (Reply Mic)
  Widget _buildPrimaryActionButton({
    required IconData icon,
    required VoidCallback? onTap,
    Color? glowColor,
  }) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 64,
        height: 64,
        decoration: BoxDecoration(
          color: glowColor ?? const Color(0xFF9C5BF5),
          shape: BoxShape.circle,
        ),
        child: Icon(icon, color: onTap != null ? Colors.white : Colors.white24, size: 28),
      ),
    );
  }

  Widget _buildRecordingReplyUI(int duration, List<double> waveformData, double scale) {
    return Padding(
      padding: EdgeInsets.symmetric(horizontal: 24 * scale),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.end, // Force to bottom
        children: [
          // Timer pill (red background)
          Container(
            padding: EdgeInsets.symmetric(horizontal: 16 * scale, vertical: 8 * scale),
            decoration: BoxDecoration(
              color: Colors.red.withOpacity(0.2),
              borderRadius: BorderRadius.circular(20 * scale),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Container(
                  width: 8 * scale,
                  height: 8 * scale,
                  decoration: const BoxDecoration(
                    color: Colors.red,
                    shape: BoxShape.circle,
                  ),
                ),
                SizedBox(width: 8 * scale),
                Text(
                  _formatDuration(duration),
                  style: TextStyle(
                    color: Colors.red,
                    fontSize: 16 * scale,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ],
            ),
          ),

          SizedBox(height: 24 * scale),

          // Waveform visualization
          SizedBox(
            height: 40 * scale,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: List.generate(
                20,
                (index) {
                  double value = 0.5;
                  bool hasData = false;
                  if (waveformData.isNotEmpty) {
                    // Sample the waveform data to match 20 bars
                    final step = waveformData.length / 20;
                    final dataIndex = (index * step).floor().clamp(0, waveformData.length - 1);
                    value = waveformData[dataIndex];
                    hasData = true;
                  }

                  final barHeight = hasData
                      ? (value * 35).clamp(4.0, 35.0) * scale
                      : (5 + (index % 3) * 10).toDouble() * scale;
                  return Container(
                    width: 4 * scale,
                    height: barHeight,
                    margin: EdgeInsets.symmetric(horizontal: 2 * scale),
                    decoration: BoxDecoration(
                      color: Colors.green,
                      borderRadius: BorderRadius.circular(2 * scale),
                    ),
                  );
                },
              ),
            ),
          ),

          SizedBox(height: 32 * scale),

          // Large mic button with glow
          Container(
            width: 80 * scale,
            height: 80 * scale,
            decoration: BoxDecoration(
              color: Colors.green,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: Colors.green.withOpacity(0.4),
                  blurRadius: 30 * scale,
                  spreadRadius: 10 * scale,
                ),
              ],
            ),
            child: Icon(
              Icons.mic,
              color: Colors.white,
              size: 36 * scale,
            ),
          ),

          SizedBox(height: 16 * scale),

          // "Release to send" text
          Text(
            'Release to send',
            style: TextStyle(
              color: Colors.white54,
              fontSize: 14 * scale,
            ),
          ),
        ],
      ),
    );
  }

  /// Format duration as "0:04" style
  String _formatDuration(int seconds) {
    final mins = seconds ~/ 60;
    final secs = seconds % 60;
    return '$mins:${secs.toString().padLeft(2, '0')}';
  }

  

  String _formatTime(DateTime dateTime) {
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inMinutes < 1) {
      return 'Just now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }

  void _showOptionsSheet() {
  showModalBottomSheet(
    context: context,
    backgroundColor: AppColors.surface,
    shape: const RoundedRectangleBorder(
      borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
    ),
    builder: (context) => Container(
      padding: const EdgeInsets.symmetric(vertical: 24, horizontal: 8),
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // AI Transcription Tool
            ListTile(
              leading: const Icon(Icons.text_snippet, color: AppColors.secondaryAction),
              title: const Text('Read AI Transcript', style: TextStyle(color: Colors.white)),
              subtitle: const Text('View voice-to-text conversion', style: TextStyle(color: Colors.white54)),
              onTap: () async {
                Navigator.pop(context);
                await _loadTranscription();
              },
            ),
            const Divider(color: Colors.white10),

            // Social Sharing Options

            ListTile(
              leading: Icon(Icons.movie, color: Colors.purple[400]),
              title: const Text('Instagram Reels', style: TextStyle(color: Colors.white)),
              onTap: () async {
                Navigator.pop(context);
                await _shareToInstagramReels();
              },
            ),

            ListTile(
              leading: const Icon(Icons.video_library, color: AppColors.primaryAction),
              title: const Text('Share Video', style: TextStyle(color: Colors.white)),
              subtitle: const Text('Other platforms (WhatsApp, etc)', style: TextStyle(color: Colors.white54)),
              onTap: () async {
                Navigator.pop(context);
                await _shareAsViralVideo();
              },
            ),
            const Divider(color: Colors.white10),

            // Delete (only for sender)
            if (_vibe!.senderId == ref.read(authServiceProvider).currentUserId)
              ListTile(
                leading: const Icon(Icons.delete_outline, color: AppColors.urgency),
                title: const Text('Delete for Everyone', style: TextStyle(color: AppColors.urgency)),
                subtitle: const Text('Remove from both devices', style: TextStyle(color: Colors.white24, fontSize: 11)),
                onTap: () {
                  Navigator.pop(context);
                  _confirmDeleteVibe();
                },
              ),
            if (_vibe!.senderId == ref.read(authServiceProvider).currentUserId)
              const Divider(color: Colors.white10),

            // Safety
            ListTile(
              leading: const Icon(Icons.flag, color: AppColors.error),
              title: const Text('Report Vibe', style: TextStyle(color: AppColors.error)),
              subtitle: const Text('Inappropriate content', style: TextStyle(color: Colors.white24, fontSize: 11)),
              onTap: () {
                Navigator.pop(context);
                _reportVibe();
              },
            ),
            ListTile(
              leading: const Icon(Icons.block, color: AppColors.error),
              title: const Text('Block User', style: TextStyle(color: AppColors.error)),
              subtitle: Text('Stop seeing ${_vibe?.senderName}\'s vibes', style: const TextStyle(color: Colors.white24, fontSize: 11)),
              onTap: () {
                Navigator.pop(context);
                _blockUser();
              },
            ),
          ],
        ),
      ),
    ),
  );
}

  void _reportVibe() async {
    final vibe = _vibe;
    if (vibe == null) return;
    
    final reasons = ['Inappropriate content', 'Spam', 'Harassment', 'Other'];
    
    final reason = await showModalBottomSheet<String>(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.symmetric(vertical: 24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text(
              'Report Content', 
              style: TextStyle(color: Colors.white, fontSize: 18, fontWeight: FontWeight.bold)
            ),
            const SizedBox(height: 16),
            ...reasons.map((r) => ListTile(
              title: Text(r, style: const TextStyle(color: Colors.white)),
              trailing: const Icon(Icons.chevron_right, color: Colors.white24),
              onTap: () => Navigator.pop(context, r),
            )),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );

    if (reason != null && mounted) {
      try {
        await ref.read(vibeServiceProvider).reportVibe(
          vibeId: vibe.id,
          reporterId: ref.read(authServiceProvider).currentUserId ?? 'unknown',
          reason: reason,
        );
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('Thank you. We will review this vibe within 24 hours.'),
              backgroundColor: Colors.green,
            ),
          );
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error reporting: $e')),
          );
        }
      }
    }
  }

  void _blockUser() async {
    final vibe = _vibe;
    if (vibe == null) return;
    
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: Text('Block ${vibe.senderName}?', style: const TextStyle(color: Colors.white)),
        content: const Text(
          'You will no longer see vibes from this user. This action is permanent.',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel', style: TextStyle(color: Colors.white54)),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('Block', style: TextStyle(color: AppColors.error)),
          ),
        ],
      ),
    );
    
    if (confirmed == true && mounted) {
      try {
        await ref.read(vibeServiceProvider).blockUser(vibe.senderId);
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Blocked ${vibe.senderName}')),
          );
          // Auto-skip to next vibe if available
          if (_hasSwipeNavigation && _currentVibeIndex < widget.vibesList!.length - 1) {
            _pageController?.nextPage(
              duration: const Duration(milliseconds: 300),
              curve: Curves.easeInOut,
            );
          } else {
            Navigator.of(context).pop(); // Exit player if no more vibes
          }
        }
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error blocking: $e')),
          );
        }
      }
    }
  }

  /// Share as a viral video (MP4) for TikTok/Instagram
  Future<void> _shareAsViralVideo() async {
    final imageUrl = _vibe!.imageUrl;
    if (imageUrl == null || imageUrl.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No image available for video')),
      );
      return;
    }

    setState(() {
      _isExportingVideo = true;
      _exportProgress = 0.0;
    });

    // Show progress dialog
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Creating Video', style: TextStyle(color: Colors.white)),
        content: StatefulBuilder(
          builder: (context, setDialogState) {
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Text(
                  'Generating TikTok-ready video...',
                  style: TextStyle(color: Colors.white70),
                ),
                const SizedBox(height: 16),
                LinearProgressIndicator(
                  value: _exportProgress,
                  backgroundColor: AppColors.surfaceLight,
                  valueColor: const AlwaysStoppedAnimation<Color>(AppColors.primaryAction),
                ),
                const SizedBox(height: 8),
                Text(
                  '${(_exportProgress * 100).toInt()}%',
                  style: const TextStyle(color: AppColors.primaryAction),
                ),
              ],
            );
          },
        ),
      ),
    );

    try {
      // Use ViralVideoService which has proper FFmpeg MP4 generation
      // (replaced deleted VideoExportService which only shared separate files)
      final viralVideoService = ref.read(viralVideoServiceProvider);
      final File? videoFile;
      
      if (_vibe!.isVideo && _vibe!.videoUrl != null) {
        videoFile = await viralVideoService.downloadVideo(
          _vibe!.videoUrl!,
          onProgress: (progress) {
            if (mounted) setState(() => _exportProgress = progress);
          },
        );
      } else {
        videoFile = await viralVideoService.generateFromUrls(
          imageUrl: imageUrl,
          audioUrl: _vibe!.audioUrl,
          onProgress: (progress) {
            if (mounted) setState(() => _exportProgress = progress);
          },
        );
      }

      Navigator.pop(context); // Close progress dialog

      if (videoFile != null && mounted) {
        // Share the generated MP4 video
        await viralVideoService.shareToSystem(
          videoFile.path,
          'ðŸŽ¤ Listen to this Vibe from ${_vibe!.senderName}!\n\nDownload Vibe: https://getvibe.app',
        );
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to prepare content')),
        );
      }
    } catch (e) {
      Navigator.pop(context); // Close progress dialog
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    } finally {
      setState(() => _isExportingVideo = false);
    }
  }

  /// Share to Instagram Stories (VIRAL - Full Screen Video)
  Future<void> _shareToInstagramStories() async {
    await _shareViralVideo('instagram');
  }

  /// Share to Instagram Reels
  Future<void> _shareToInstagramReels() async {
    await _shareViralVideo('reels');
  }

  /// Share to TikTok
  Future<void> _shareToTikTok() async {
    await _shareViralVideo('tiktok');
  }

  /// Core viral video sharing method
  Future<void> _shareViralVideo(String platform) async {
    // VIRAL FIX: For audio-only vibes, fallback to sender avatar
    final imageUrl = _vibe!.imageUrl ?? _vibe!.senderAvatar;
    
    if (imageUrl == null || imageUrl.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No image or avatar available for video creation')),
      );
      return;
    }

    setState(() {
      _isExportingVideo = true;
      _exportProgress = 0.0;
    });



    // VIRAL FIX: Background processing (remove blocking dialog)
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Creating ${platform == 'tiktok' ? 'TikTok' : 'Instagram'} video in background...'),
        duration: const Duration(seconds: 2),
        backgroundColor: platform == 'tiktok' ? Colors.cyan.withOpacity(0.8) : Colors.pink.withOpacity(0.8),
      ),
    );

    try {
      final viralService = ref.read(viralVideoServiceProvider);
      
      // Generate or download the video
      final File? videoFile;
      if (_vibe!.isVideo && _vibe!.videoUrl != null) {
        videoFile = await viralService.downloadVideo(
          _vibe!.videoUrl!,
          onProgress: (progress) {
            if (mounted) setState(() => _exportProgress = progress);
          },
        );
      } else {
        videoFile = await viralService.generateFromUrls(
          imageUrl: imageUrl,
          audioUrl: _vibe!.audioUrl,
          onProgress: (progress) {
            if (mounted) setState(() => _exportProgress = progress);
          },
        );
      }

      // Navigator.pop(context); // REMOVED: Blocking dialog

      if (videoFile != null && mounted) {
        // Share to the selected platform
        String result;
        switch (platform) {
          case 'instagram':
            result = await viralService.shareToInstagramStories(
              videoPath: videoFile.path,
              attributionUrl: 'https://getvibe.app',
            );
            break;
          case 'reels':
            result = await viralService.shareToInstagramReels(videoFile.path);
            break;
          case 'tiktok':
            result = await viralService.shareToTikTok(videoFile.path);
            break;
          default:
            result = await viralService.shareToSystem(
              videoFile.path,
              'ðŸŽ¤ Listen to this Vibe from ${_vibe!.senderName}!\n\nDownload Vibe: https://getvibe.app',
            );
        }
        
        debugPrint('Share result: $result');
        
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Video ready!'), backgroundColor: AppColors.success),
          );
        }
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Failed to create video')),
        );
      }
    } catch (e) {
      // Navigator.pop(context); // REMOVED: Blocking dialog
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e')),
        );
      }
    } finally {
      setState(() => _isExportingVideo = false);
    }
  }

  /// Load AI transcription
  /// [silent] is true when auto-loading on entry (no snackbar/dialog)
  Future<void> _loadTranscription({bool silent = false}) async {
    // If transcription already exists on the model, just use it
    if (_vibe?.transcription != null && _vibe!.transcription!.isNotEmpty) {
      if (mounted) {
        setState(() {
          _transcriptionText = _vibe!.transcription;
          _showTranscription = true;
        });
      }
      return;
    }

    if (!silent) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              SizedBox(width: 16),
              Text('Transcribing voice...'),
            ],
          ),
          duration: Duration(seconds: 3),
        ),
      );
    }

    try {
      final transcriptionService = ref.read(transcriptionServiceProvider);
      String? text;

      // Support both audio and video transcription (Whisper handles both)
      final String mediaUrlToTranscribe = _vibe!.audioUrl.isNotEmpty 
          ? _vibe!.audioUrl 
          : (_vibe!.videoUrl ?? '');

      if (mediaUrlToTranscribe.isNotEmpty) {
        text = await transcriptionService.transcribeFromUrl(mediaUrlToTranscribe);
      }

      if (text != null && mounted) {
        setState(() {
          _transcriptionText = text;
          _showTranscription = true;
        });
        
        // PERSISTENCE: Save transcription to Firestore via service
        ref.read(vibeServiceProvider).saveTranscription(_vibe!.id, text);
        
        if (!silent) {
          _showTranscriptionDialog(text);
        }
      } else if (!silent && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Could not transcribe audio')),
        );
      }
    } catch (e) {
      if (!silent && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Transcription error: $e')),
        );
      }
    }
  }

  /// Show transcription in a dialog
  void _showTranscriptionDialog(String text) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: Row(
          children: [
            const Icon(Icons.text_snippet, color: AppColors.primaryAction),
            const SizedBox(width: 8),
            Text(
              'Transcription',
              style: AppTypography.headlineSmall.copyWith(color: Colors.white),
            ),
          ],
        ),
        content: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                'From ${_vibe!.senderName}:',
                style: AppTypography.labelMedium.copyWith(
                  color: AppColors.textSecondary,
                ),
              ),
              const SizedBox(height: 12),
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: AppColors.surfaceLight,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  text,
                  style: AppTypography.bodyLarge.copyWith(
                    color: Colors.white,
                    height: 1.5,
                  ),
                ),
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Clipboard.setData(ClipboardData(text: text));
              Navigator.pop(context);
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('Copied to clipboard')),
              );
            },
            child: const Text('Copy', style: TextStyle(color: AppColors.primaryAction)),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Close', style: TextStyle(color: Colors.white)),
          ),
        ],
      ),
    );
  }

  /// Share the current vibe
  Future<void> _shareVibe() async {
    try {
      // Show loading indicator
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Row(
            children: [
              SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              ),
              SizedBox(width: 16),
              Text('Preparing share...'),
            ],
          ),
          duration: Duration(seconds: 2),
        ),
      );

      // Use share_plus to share actual files
      await _shareVibeFiles();
      
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Share failed: $e')),
        );
      }
    }
  }

  /// Share actual audio/image files (not just text)
  Future<void> _shareVibeFiles() async {
    try {
      final tempDir = await getTemporaryDirectory();
      final files = <XFile>[];
      
      // Download and add image if available
      final imageUrl = _vibe!.imageUrl;
      if (imageUrl != null && imageUrl.isNotEmpty) {
        try {
          final imageFile = File('${tempDir.path}/vibe_share_${_vibe!.id}.jpg');
          if (imageUrl.startsWith('http')) {
            final response = await http.get(Uri.parse(imageUrl));
            await imageFile.writeAsBytes(response.bodyBytes);
          }
          files.add(XFile(imageFile.path));
        } catch (e) {
          debugPrint('Failed to download image: $e');
        }
      }
      
      // Download and add audio if available
      if (_vibe!.audioUrl.isNotEmpty) {
        try {
          final audioFile = File('${tempDir.path}/vibe_audio_${_vibe!.id}.m4a');
          if (_vibe!.audioUrl.startsWith('http')) {
            final response = await http.get(Uri.parse(_vibe!.audioUrl));
            await audioFile.writeAsBytes(response.bodyBytes);
          }
          files.add(XFile(audioFile.path));
        } catch (e) {
          debugPrint('Failed to download audio: $e');
        }
      }

      // Download and add video if available
      if (_vibe!.isVideo && _vibe!.videoUrl != null && _vibe!.videoUrl!.isNotEmpty) {
        try {
          final videoFile = File('${tempDir.path}/vibe_video_${_vibe!.id}.mp4');
          if (_vibe!.videoUrl!.startsWith('http')) {
            final response = await http.get(Uri.parse(_vibe!.videoUrl!));
            await videoFile.writeAsBytes(response.bodyBytes);
          }
          files.add(XFile(videoFile.path));
        } catch (e) {
          debugPrint('Failed to download video: $e');
        }
      }
      
      // Build share message
      final shareText = 'ðŸŽ¤ Listen to this Vibe from ${_vibe!.senderName}!\n\n'
          '${_vibe!.isFromGallery && _vibe!.originalPhotoDate != null 
              ? "ðŸ“… Time Travel from ${_formatDate(_vibe!.originalPhotoDate!)}\n\n" 
              : ""}'
          'Download Vibe to hear it: https://getvibe.app';
      
      // Share files if we have any, otherwise just share text
      if (files.isNotEmpty) {
        await Share.shareXFiles(
          files,
          text: shareText,
          subject: 'Nock from ${_vibe!.senderName}',
        );
      } else {
        await Share.share(
          shareText,
          subject: 'Nock from ${_vibe!.senderName}',
        );
      }
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Shared successfully!')),
        );
      }
    } catch (e) {
      debugPrint('Share error: $e');
      // Fallback to text-only share
      if (mounted) {
        await Share.share(
          'ðŸŽ¤ Listen to this Vibe from ${_vibe!.senderName}!\n\nDownload Vibe: https://getvibe.app',
          subject: 'Nock from ${_vibe!.senderName}',
        );
      }
    }
  }

  Future<void> _shareAppLink() async {
    const shareText = 'âœ¨ I\'m using Vibe to send voice messages that appear on my friends\' home screens!\n\n'
        'Download Vibe: https://getvibe.app';
    await Share.share(shareText, subject: 'Check out Vibe!');
  }

  String _formatDate(DateTime date) {
    final months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
    return '${months[date.month - 1]} ${date.day}, ${date.year}';
  }

  String _formatTimeAgo(DateTime dateTime) {
    final now = DateTime.now();
    final diff = now.difference(dateTime);

    if (diff.inMinutes < 1) return 'now';
    if (diff.inMinutes < 60) return '${diff.inMinutes}m ago';
    if (diff.inHours < 24) return '${diff.inHours}h ago';
    if (diff.inDays < 7) return '${diff.inDays}d ago';
    return '${(diff.inDays / 7).floor()}w ago';
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HYBRID MULTIMODAL HELPERS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  void _startTextReply() {
    setState(() {
      _isTextReplying = true;
    });
    _textReplyFocusNode.requestFocus();
    HapticFeedback.lightImpact();
  }

  Future<void> _sendTextReply() async {
    final text = _textReplyController.text.trim();
    if (text.isEmpty) return;

    final vibeId = _vibe!.id;
    final currentUser = ref.read(currentUserProvider).valueOrNull;
    
    _textReplyFocusNode.unfocus();
    _textReplyController.clear();
    
    // FIX: OPTIMISTIC UPDATE - Add reply to local state immediately
    // This prevents "Ghost Replies" where user sends but doesn't see the result
    final newReply = TextReply(
      senderId: currentUser?.id ?? '',
      senderName: currentUser?.displayName ?? 'You',
      text: text,
      createdAt: DateTime.now(),
    );
    
    setState(() {
      _isTextReplying = false;
      _vibe = _vibe!.copyWith(
        textReplies: [..._vibe!.textReplies, newReply],
      );
    });

    try {
      await ref.read(vibeServiceProvider).sendTextReply(vibeId, text);
      HapticFeedback.mediumImpact();
    } catch (e) {
      debugPrint('Error sending text reply: $e');
      // Optionally: Revert optimistic update on error
    }
  }

  void _addQuickReaction(String emoji) {
    HapticFeedback.mediumImpact();
    
    // Send to service
    ref.read(vibeServiceProvider).addReaction(_vibe!.id, emoji);
    
    // Trigger local animation (Emoji Rain)
    _triggerEmojiRain(emoji);
  }

  void _triggerEmojiRain(String emoji) {
    final random = math.Random();
    final screenWidth = MediaQuery.of(context).size.width;
    
    setState(() {
      for (int i = 0; i < 15; i++) {
        _floatingEmojis.add(FloatingEmoji(
          emoji: emoji,
          x: random.nextDouble() * screenWidth,
          y: -50.0, // Start ABOVE screen for "cascade down" effect
          speed: 3.0 + random.nextDouble() * 5.0, // Slightly faster fall
          opacity: 1.0,
        ));
      }
    });

    // Start cleanup timer if not running
    if (_emojiCleanupTimer == null || !_emojiCleanupTimer!.isActive) {
      _emojiCleanupTimer = Timer.periodic(const Duration(milliseconds: 16), (timer) {
        if (!mounted) {
          timer.cancel();
          return;
        }

        setState(() {
          final screenHeight = MediaQuery.of(context).size.height;
          for (var emoji in _floatingEmojis) {
            emoji.y += emoji.speed; // REVERSED GRAVITY: Move DOWN
            emoji.opacity -= 0.005; // Slower fade
          }
          _floatingEmojis.removeWhere((e) => e.y > screenHeight + 50 || e.opacity <= 0);
        });

        if (_floatingEmojis.isEmpty) {
          timer.cancel();
          _emojiCleanupTimer = null;
        }
      });
    }
  }

  Widget _buildPortalOverlays(double scale) {
    final screenWidth = MediaQuery.of(context).size.width;
    final squareSize = screenWidth * 0.9;

    return Center(
      child: SizedBox(
        width: squareSize,
        height: squareSize,
        child: Stack(
          alignment: Alignment.center,
          children: [
            // 1. DYNAMIC KARAOKE SUBTITLES (Transcription)
            if (_showTranscription && _transcriptionText != null)
              Positioned(
                bottom: 40 * scale,
                left: 24 * scale,
                right: 24 * scale,
                child: AnimatedOpacity(
                  duration: const Duration(milliseconds: 300),
                  opacity: _isPlaying ? 1.0 : 0.6,
                  child: Container(
                    padding: EdgeInsets.symmetric(horizontal: 16 * scale, vertical: 12 * scale),
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        colors: [Colors.black.withOpacity(0.0), Colors.black.withOpacity(0.4), Colors.black.withOpacity(0.0)],
                      ),
                    ),
                    child: Text(
                      _transcriptionText!,
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 18 * scale,
                        fontWeight: FontWeight.bold,
                        fontStyle: FontStyle.italic,
                        shadows: [
                          Shadow(color: Colors.black, blurRadius: 10 * scale),
                        ],
                        height: 1.2,
                      ),
                    ),
                  ),
                ),
              ),

            // 2. STICKY NOTES (Visual Whispers)
            if (_vibe != null && _vibe!.textReplies.isNotEmpty)
              ..._buildStickyNotes(scale),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildStickyNotes(double scale) {
    if (_vibe!.textReplies.isEmpty) return [];
    
    // 1. Show only the LATEST note
    final latestReply = _vibe!.textReplies.last;
    final count = _vibe!.textReplies.length;

    return [
      Positioned(
        bottom: 120 * scale, // Position above the pill
        left: 32 * scale,    // Slightly more margin
        child: Transform.rotate(
          angle: -0.025, // Subtle 1.5 degree rotation for "Sticky Note" feel
          child: GestureDetector(
            onTap: () => _showAllCommentsSheet(), 
            child: Stack(
              clipBehavior: Clip.none,
              children: [
                // The Note (Sticky Note Style)
                GlassContainer(
                  padding: EdgeInsets.symmetric(horizontal: 14 * scale, vertical: 12 * scale),
                  // Standardized glass aesthetic (Removed yellow tint)
                  backgroundColor: AppColors.glassBackground, 
                  borderRadius: 12 * scale,
                  borderColor: AppColors.glassBorder,
                  showGlow: true, 
                  useSmallGlow: true, 
                  glowColor: AppColors.primaryAction.withOpacity(0.1),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                          latestReply.senderName.toUpperCase(), 
                          style: TextStyle(
                            fontSize: 7 * scale, 
                            fontWeight: FontWeight.w900, 
                            color: Colors.white.withOpacity(0.7),
                            letterSpacing: 1 * scale,
                          )
                      ),
                      SizedBox(height: 4 * scale),
                      Text(
                          latestReply.text, 
                          style: TextStyle(
                            color: Colors.white, 
                            fontSize: 14 * scale,
                            fontWeight: FontWeight.w500,
                            letterSpacing: -0.2 * scale,
                          )
                      ),
                    ],
                  ),
                ),
                
                // The Counter Badge (if more than 1) - Positioned relative to the rotated note
                if (count > 1)
                  Positioned(
                    right: -6 * scale,
                    top: -6 * scale,
                    child: Container(
                      padding: EdgeInsets.all(6 * scale),
                      decoration: BoxDecoration(
                        color: AppColors.primaryAction, 
                        shape: BoxShape.circle,
                        boxShadow: [
                          BoxShadow(color: Colors.black26, blurRadius: 4 * scale, spreadRadius: 1 * scale),
                        ],
                      ),
                      child: Text(
                        '+${count - 1}', 
                        style: TextStyle(color: Colors.white, fontSize: 9 * scale, fontWeight: FontWeight.bold)
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      )
    ];
  }

  void _showAllCommentsSheet() {
    showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => ListView.builder(
        padding: const EdgeInsets.all(24),
        itemCount: _vibe!.textReplies.length,
        itemBuilder: (context, index) {
          final r = _vibe!.textReplies[index];
          return ListTile(
            contentPadding: const EdgeInsets.symmetric(vertical: 8),
            title: Text(r.senderName, style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
            subtitle: Text(r.text, style: const TextStyle(color: Colors.white70)),
            leading: CircleAvatar(
              backgroundColor: Colors.white10,
              child: Text(r.senderName[0].toUpperCase(), style: const TextStyle(color: Colors.white)),
            ),
          );
        },
      ),
    );
  }


  Widget _buildReactionsRow() {
    // Unique list of emojis to avoid clutter
    final uniqueEmojis = _vibe!.reactions.map((r) => r.emoji).toSet().toList();
    // Limit to 4 for clean UI
    final displayEmojis = uniqueEmojis.take(4).toList();
    final count = _vibe!.reactions.length;

    return Padding(
      padding: const EdgeInsets.only(top: 4),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
        decoration: BoxDecoration(
          color: Colors.white.withOpacity(0.08),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            ...displayEmojis.map((e) => Padding(
              padding: const EdgeInsets.symmetric(horizontal: 1),
              child: Text(e, style: const TextStyle(fontSize: 12)),
            )),
            if (count > displayEmojis.length)
              Padding(
                padding: const EdgeInsets.only(left: 2),
                child: Text(
                  '+${count - displayEmojis.length}',
                  style: const TextStyle(
                    color: Colors.white70,
                    fontSize: 10,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }





  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  /// GHOST HINTS (Onboarding discovery) - Progressive Disclosure
  /// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  /// Check SharedPreferences and only show hints if user hasn't seen them
  Future<void> _checkAndShowGhostHints() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final hasSeenHints = prefs.getBool(_ghostHintsSeenKey) ?? false;
      
      if (hasSeenHints) {
        // User has already seen hints - don't show again (Progressive Disclosure)
        debugPrint('PlayerScreen: Ghost hints already seen, skipping');
        return;
      }
      
      // Show hints after delay for first-time users
      _ghostHintTimer = Timer(const Duration(seconds: 2), () {
        if (mounted && !_hasPlayed) {
          setState(() => _showGhostHints = true);
          // Mark as seen after showing
          _markGhostHintsSeen();
        }
      });
    } catch (e) {
      debugPrint('PlayerScreen: Error checking ghost hints preference: $e');
    }
  }

  /// Mark ghost hints as seen in SharedPreferences (Progressive Disclosure)
  Future<void> _markGhostHintsSeen() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool(_ghostHintsSeenKey, true);
      debugPrint('PlayerScreen: Ghost hints marked as seen');
    } catch (e) {
      debugPrint('PlayerScreen: Error saving ghost hints preference: $e');
    }
  }

  Widget _buildGhostHints(double scale) {
    return Positioned.fill(
      child: IgnorePointer(
        child: Stack(
          children: [
            // HOLD HINT (Pill pulsing)
            Positioned(
              bottom: 120 * scale,
              left: 0,
              right: 0,
              child: Center(
                child: _buildHintBubble('Hold middle to record voice reply', scale),
              ),
            ),
            
            // SWIPE HINT (Up arrow)
            Positioned(
              bottom: 180 * scale,
              left: 40 * scale,
              child: Column(
                children: [
                  Icon(Icons.keyboard_arrow_up, color: Colors.white, size: 32 * scale),
                  SizedBox(height: 8 * scale),
                  Text(
                    'Swipe for Camera',
                    style: TextStyle(color: Colors.white, fontSize: 10 * scale, fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHintBubble(String text, double scale) {
    return AnimatedOpacity(
      duration: const Duration(seconds: 1),
      opacity: _showGhostHints ? 0.8 : 0.0,
      child: GlassContainer(
        padding: EdgeInsets.symmetric(horizontal: 16 * scale, vertical: 8 * scale),
        borderRadius: 20 * scale,
        child: Text(
          text,
          style: TextStyle(color: Colors.white, fontSize: 12 * scale, fontWeight: FontWeight.bold),
        ),
      ),
    );
  }
  Widget _buildCyberpunkBackground(double scale) {
    return Container(
      color: AppColors.background,
      child: CustomPaint(
        painter: GridPainter(
          color: Colors.white.withOpacity(0.05),
          scale: scale,
        ),
      ),
    );
  }

  /// Confirm delete vibe dialog
  Future<void> _confirmDeleteVibe() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Delete Vibe?', style: TextStyle(color: Colors.white)),
        content: Text(
          'This will delete the vibe for both you and ${_vibe!.senderName}. This cannot be undone.',
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: AppColors.urgency),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await _deleteVibe();
    }
  }
  
  /// Delete vibe for everyone
  Future<void> _deleteVibe() async {
    try {
      await ref.read(vibeServiceProvider).deleteVibeForEveryone(_vibe!.id);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Vibe deleted'),
            backgroundColor: AppColors.success,
          ),
        );
        
        if (context.canPop()) {
          context.pop();
        } else {
          context.go(AppRoutes.home);
        }
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to delete: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }
}

/// Helper for reaction animations
class FloatingEmoji {
  final String emoji;
  final double x;
  double y;
  final double speed;
  double opacity;

  FloatingEmoji({
    required this.emoji,
    required this.x,
    required this.y,
    required this.speed,
    this.opacity = 1.0,
  });
}

/// A custom painter that draws a faint cyberpunk tech grid
class GridPainter extends CustomPainter {
  final Color color;
  final double scale;
  
  GridPainter({
    required this.color,
    required this.scale,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 0.5 * scale;

    final double spacing = 40.0 * scale;

    // Draw vertical lines
    for (double x = 0; x < size.width; x += spacing) {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), paint);
    }

    // Draw horizontal lines
    for (double y = 0; y < size.height; y += spacing) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), paint);
    }
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}



========================================

FILE #60: E:\Vive\lib\features\squad\presentation\add_friends_screen.dart

========================================


import 'dart:async';
import 'dart:io';
import 'package:url_launcher/url_launcher.dart';
import 'package:share_plus/share_plus.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:nock/shared/widgets/permission_guard.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:nock/core/services/invite_service.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/services/share_service.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/constants/app_constants.dart';
import 'package:nock/core/models/user_model.dart';
import 'package:nock/core/services/contacts_sync_service.dart';
import 'package:nock/shared/widgets/qr_invite_card.dart';

/// Unified Add Friends Screen
/// 
/// Combines:
/// 1. Visual invite cards (invite new users)
/// 2. Social sharing (viral growth)
/// 3. Contact syncing (find friends)
/// 
/// Layout:
/// - QR Code at top
/// - Quick share icons (Messenger, Instagram, Messages, etc.)
/// - Contact Sync section
/// - Full invite options list
class AddFriendsScreen extends ConsumerStatefulWidget {
  const AddFriendsScreen({super.key});

  @override
  ConsumerState<AddFriendsScreen> createState() => _AddFriendsScreenState();
}

class _AddFriendsScreenState extends ConsumerState<AddFriendsScreen>
    with SingleTickerProviderStateMixin {
  final GlobalKey _inviteCardKey = GlobalKey();
  bool _isGeneratingCard = false;
  bool _isSharing = false;  // LAZY LOAD FIX: Prevents double-clicks during share
  File? _generatedCardFile;
  List<SyncedContact> _syncedContacts = [];  // All contacts with match status
  bool _isSyncingContacts = false;
  
  late AnimationController _animController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _animController = AnimationController(
      duration: const Duration(milliseconds: 600),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animController,
      curve: Curves.easeOut,
    );
    _animController.forward();
  }

  @override
  void dispose() {
    _animController.dispose();
    super.dispose();
  }


  Future<void> _addFriend(UserModel friend) async {
    final authService = ref.read(authServiceProvider);
    final currentUserId = authService.currentUserId;
    if (currentUserId == null) return;

    // Check if already friends
    final currentUser = ref.read(currentUserProvider).valueOrNull;
    if (currentUser?.friendIds.contains(friend.id) ?? false) {
      _showError('${friend.displayName} is already in your squad!');
      return;
    }

    try {
      // Add to both users' friend lists
      await FirebaseFirestore.instance
          .collection(AppConstants.usersCollection)
          .doc(currentUserId)
          .update({
        'friendIds': FieldValue.arrayUnion([friend.id]),
      });

      await FirebaseFirestore.instance
          .collection(AppConstants.usersCollection)
          .doc(friend.id)
          .update({
        'friendIds': FieldValue.arrayUnion([currentUserId]),
      });

      if (mounted) {
        HapticFeedback.mediumImpact();
        _showSuccess('Added ${friend.displayName} to your squad!');
      }
    } catch (e) {
      _showError('Failed to add friend. Please try again.');
    }
  }

  // ==================== INVITE CARD FUNCTIONALITY ====================

  Future<File?> _generateInviteCard() async {
    if (_isGeneratingCard) return null;
    
    setState(() => _isGeneratingCard = true);
    
    final completer = Completer<File?>();
    
    // Wait for a short moment to ensure UI shows loading state
    await Future.delayed(const Duration(milliseconds: 100));
    
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      if (!mounted) {
        completer.complete(null);
        return;
      }
      
      try {
        // MEMORY FIX: Use dynamic pixel ratio capped at 2.0
        final deviceRatio = MediaQuery.of(context).devicePixelRatio;
        final safeRatio = deviceRatio > 2.0 ? 2.0 : deviceRatio;
        
        // Try widget-based capture first
        var file = await InviteCardGenerator.captureInviteCard(
          cardKey: _inviteCardKey,
          pixelRatio: safeRatio,
        );
        
        // If widget capture failed, use offscreen rendering
        if (file == null) {
          debugPrint('AddFriendsScreen: Widget capture failed, trying offscreen render...');
          
          final userModel = ref.read(currentUserProvider).valueOrNull;
          final firebaseUser = ref.read(authStateProvider).valueOrNull;
          
          final displayName = userModel?.displayName.isNotEmpty == true 
              ? userModel!.displayName 
              : (firebaseUser?.displayName ?? 'Nock User');
          final username = userModel?.username ?? 
              (firebaseUser?.uid.substring(0, 8) ?? 'viber');
          
          file = await InviteCardGenerator.renderInviteCardOffscreen(
            senderName: displayName,
            username: username,
            pixelRatio: safeRatio,
          );
        }
        
        if (mounted) {
          setState(() {
            _generatedCardFile = file;
            _isGeneratingCard = false;
          });
        }
        completer.complete(file);
      } catch (e) {
        debugPrint('AddFriendsScreen: Error generating card: $e');
        if (mounted) {
          setState(() => _isGeneratingCard = false);
        }
        completer.complete(null);
      }
    });

    return completer.future;
  }

  Future<void> _shareToTarget(InviteTarget target) async {
    // Try to get user from Firestore first
    final userModel = ref.read(currentUserProvider).valueOrNull;
    
    // Fallback to Firebase Auth if Firestore user not available
    // (This can happen if Firestore API is disabled or user just signed up)
    final firebaseUser = ref.read(authStateProvider).valueOrNull;
    
    if (userModel == null && firebaseUser == null) {
      _showError('Please sign in to invite friends');
      return;
    }
    
    // Use Firestore user data if available, otherwise fallback to Firebase Auth
    final userId = userModel?.id ?? firebaseUser!.uid;
    final displayName = userModel?.displayName.isNotEmpty == true 
        ? userModel!.displayName 
        : (firebaseUser?.displayName ?? 'Nock User');
    
    HapticFeedback.mediumImpact();
    
    if (_generatedCardFile == null) {
      final file = await _generateInviteCard();
      if (file == null) {
        _showError('Failed to generate invite card');
        return;
      }
    }
    
    final inviteService = ref.read(inviteServiceProvider);
    final message = inviteService.generateInviteMessage(senderName: displayName);
    // Use Firebase UID for the invite link
    final link = inviteService.generateInviteLink(userId);
    final fullMessage = '$message\n$link';
    
    bool success = false;
    
    switch (target) {
      case InviteTarget.instagramStory:
        success = await inviteService.shareToInstagramStory(
          imagePath: _generatedCardFile!.path,
          senderName: displayName,
        );
        break;
      case InviteTarget.instagramDm:
        success = await inviteService.shareToInstagramDm(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
      case InviteTarget.snapchat:
        success = await inviteService.shareToSnapchat(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
      case InviteTarget.whatsapp:
        success = await inviteService.shareToWhatsApp(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
      case InviteTarget.messenger:
        success = await inviteService.shareToMessenger(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
      case InviteTarget.telegram:
        success = await inviteService.shareToTelegram(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
      case InviteTarget.messages:
        success = await inviteService.shareToMessages(
          message: fullMessage,
          imagePath: _generatedCardFile!.path,
        );
        break;
      case InviteTarget.other:
        success = await inviteService.shareToSystem(
          imagePath: _generatedCardFile!.path,
          message: fullMessage,
        );
        break;
    }
    
    if (!mounted) return;
    
    if (success) {
      // Show success - note: for system share (Messenger, Snapchat, Messages, Other)
      // success means the share sheet opened, not that user actually shared
      if (target == InviteTarget.other || 
          target == InviteTarget.messenger || 
          target == InviteTarget.snapchat ||
          target == InviteTarget.messages) {
        // For system share, don't claim "sent" - just opened share sheet
        _showSuccess('Share sheet opened!');
      } else {
        _showSuccess('Opened ${target.displayName}!');
      }
    } else {
      // Only show error for direct share apps that completely failed
      if (target == InviteTarget.instagramStory) {
        _showError('Instagram not installed. Try another option!');
      }
      // For other failures, they already fell back to system share
    }
  }

  // ==================== UI HELPERS ====================

  void _showError(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red.shade700,
      ),
    );
  }

  void _showSuccess(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.check_circle, color: Colors.white),
            const SizedBox(width: 8),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.green.shade700,
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }

  // ==================== BUILD ====================

  @override
  Widget build(BuildContext context) {
    final userAsync = ref.watch(currentUserProvider);
    
    return Scaffold(
      backgroundColor: AppColors.vibeBackground,
      body: Stack(
        children: [
          SafeArea(
            child: FadeTransition(
              opacity: _fadeAnimation,
              child: CustomScrollView(
                slivers: [
                  // Header
                  SliverToBoxAdapter(
                  child: userAsync.when(
                      data: (user) => _buildHeader(user?.friendIds.length ?? 0),
                      loading: () => _buildHeader(0),
                      error: (_, __) => _buildHeader(0),
                    ),
                  ),
                  
                  // QR Code Invite Card (replaces search bar)
                  SliverToBoxAdapter(
                    child: userAsync.when(
                      data: (user) => QRInviteCard(
                        username: user?.username ?? user?.id.substring(0, 8) ?? 'user',
                        userId: user?.id,
                        displayName: user?.displayName,
                      ),
                      loading: () => const Center(
                        child: Padding(
                          padding: EdgeInsets.all(40),
                          child: CircularProgressIndicator(color: AppColors.vibePrimary),
                        ),
                      ),
                      error: (_, __) => QRInviteCard(
                        username: 'user',
                        userId: null,
                        displayName: null,
                      ),
                    ),
                  ),
                  
                  // 3-button social share row + Sync Contacts
                  SliverToBoxAdapter(
                    child: _buildFindFriendsSection(),
                  ),
                  
                  const SliverToBoxAdapter(
                    child: SizedBox(height: 100),
                  ),
                ],
              ),
            ),
          ),
          
          // Hidden invite card for capture
          // FIX: Use Opacity(0.0) instead of left: -2000
          // Some Android OEMs (Samsung/Xiaomi) cull widgets positioned completely
          // off-screen, causing RepaintBoundary.toImage() to capture a blank image.
          // The Opacity approach keeps the widget rendered but invisible.
          Positioned(
            left: 0,
            top: 0,
            child: IgnorePointer(
              child: Opacity(
                opacity: 0.0,
                child: RepaintBoundary(
                  key: _inviteCardKey,
                  child: Builder(
                    builder: (context) {
                      final screenWidth = MediaQuery.sizeOf(context).width;
                      final captureWidth = screenWidth > 500 ? 500.0 : screenWidth;
                      
                      return SizedBox(
                        width: captureWidth,
                        height: captureWidth * 16 / 9,
                        child: userAsync.when(
                      data: (user) => InviteCardGenerator.buildInviteCard(
                        senderName: user?.displayName ?? 'Nock User',
                        username: user?.username ?? user?.id.substring(0, 8) ?? 'user',
                        primaryColor: AppColors.vibePrimary,
                        secondaryColor: AppColors.vibeSecondary,
                      ),
                      loading: () => InviteCardGenerator.buildInviteCard(
                        senderName: 'Loading...',
                        username: 'user',
                        primaryColor: AppColors.vibePrimary,
                        secondaryColor: AppColors.vibeSecondary,
                      ),
                      error: (_, __) => InviteCardGenerator.buildInviteCard(
                        senderName: 'Nock User',
                        username: 'user',
                        primaryColor: AppColors.vibePrimary,
                        secondaryColor: AppColors.vibeSecondary,
                      ),
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
          
          // Loading overlay
          if (_isGeneratingCard)
            Container(
              color: Colors.black54,
              child: const Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    CircularProgressIndicator(color: AppColors.vibePrimary),
                    SizedBox(height: 16),
                    Text(
                      'Creating your invite...',
                      style: TextStyle(color: Colors.white),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildHeader(int friendCount) {
    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        children: [
          Row(
            children: [
              IconButton(
                onPressed: () => Navigator.pop(context),
                icon: const Icon(Icons.arrow_back, color: Colors.white),
              ),
              const SizedBox(width: 8),
              const Text(
                'Invite Friends',
                style: TextStyle(
                  fontSize: 24,
                  fontWeight: FontWeight.bold,
                  color: Colors.white,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            'Share your QR code or invite via social media',
            style: TextStyle(
              fontSize: 14,
              color: Colors.white.withOpacity(0.6),
            ),
          ),
        ],
      ),
    );
  }


  Future<void> _handleSyncContacts() async {
    if (_isSyncingContacts) return;
    
    setState(() => _isSyncingContacts = true);
    HapticFeedback.mediumImpact();
    
    try {
      final contactsService = ref.read(contactsSyncServiceProvider);
      final allContacts = await contactsService.syncContacts();
      
      if (!mounted) return;

      // Filter out users who are already friends
      final currentUser = ref.read(currentUserProvider).valueOrNull;
      final friendIds = currentUser?.friendIds ?? [];
      
      // Remove contacts where the matched user is already a friend
      final filteredContacts = allContacts.where((c) {
        if (c.isOnNock && friendIds.contains(c.matchedUser!.id)) {
          return false; // Already friends
        }
        return true;
      }).toList();
      
      setState(() {
        _syncedContacts = filteredContacts;
        _isSyncingContacts = false;
      });
      
      final matchCount = filteredContacts.where((c) => c.isOnNock).length;
      final inviteCount = filteredContacts.where((c) => !c.isOnNock).length;
      
      if (matchCount > 0) {
        _showSuccess('Found $matchCount friends on Nock! $inviteCount to invite.');
      } else {
        _showSuccess('$inviteCount contacts ready to invite!');
      }
    } catch (e) {
      setState(() => _isSyncingContacts = false);
      _showError('Failed to sync contacts: $e');
      debugPrint('ContactSync error: $e');
    }
  }

  Widget _buildSyncedContactsSection() {
    final matchCount = _syncedContacts.where((c) => c.isOnNock).length;
    final inviteCount = _syncedContacts.where((c) => !c.isOnNock).length;
    
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 12),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.contacts, color: Colors.green.shade400, size: 18),
              const SizedBox(width: 8),
              Text(
                'Your Contacts',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w600,
                  color: Colors.green.shade400,
                ),
              ),
              const Spacer(),
              if (matchCount > 0)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                  decoration: BoxDecoration(
                    color: Colors.green.withOpacity(0.2),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Text(
                    '$matchCount on Nock',
                    style: const TextStyle(fontSize: 11, color: Colors.green),
                  ),
                ),
              const SizedBox(width: 6),
              Text(
                '$inviteCount to invite',
                style: TextStyle(
                  fontSize: 11,
                  color: Colors.white.withOpacity(0.5),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Container(
            constraints: const BoxConstraints(maxHeight: 350), // Limit height
            decoration: BoxDecoration(
              color: Colors.white.withOpacity(0.05),
              borderRadius: BorderRadius.circular(12),
              border: Border.all(color: Colors.white.withOpacity(0.1)),
            ),
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: _syncedContacts.length,
              itemBuilder: (context, index) {
                final contact = _syncedContacts[index];
                return _buildContactItem(contact);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildContactItem(SyncedContact contact) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        border: Border(
          bottom: BorderSide(color: Colors.white.withOpacity(0.05)),
        ),
      ),
      child: Row(
        children: [
          // Avatar
          CircleAvatar(
            radius: 22,
            backgroundColor: contact.isOnNock 
                ? AppColors.vibePrimary 
                : Colors.grey.shade700,
            backgroundImage: contact.matchedUser?.avatarUrl != null 
                ? NetworkImage(contact.matchedUser!.avatarUrl!) 
                : null,
            child: contact.matchedUser?.avatarUrl == null 
                ? Text(
                    contact.displayName.isNotEmpty 
                        ? contact.displayName[0].toUpperCase() 
                        : '?',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  )
                : null,
          ),
          const SizedBox(width: 12),
          
          // Contact info
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  contact.displayName,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 15,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                Text(
                  contact.phoneNumber,
                  style: TextStyle(
                    color: Colors.white.withOpacity(0.4),
                    fontSize: 12,
                  ),
                ),
              ],
            ),
          ),
          
          // Action button
          if (contact.isOnNock)
            ElevatedButton(
              onPressed: () => _addFriend(contact.matchedUser!),
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.vibePrimary,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
              ),
              child: const Text('Add', style: TextStyle(fontSize: 13)),
            )
          else
            OutlinedButton(
              onPressed: () => _inviteViaSms(contact),
              style: OutlinedButton.styleFrom(
                foregroundColor: Colors.white,
                side: BorderSide(color: Colors.white.withOpacity(0.3)),
                padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 8),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(20),
                ),
              ),
              child: const Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(Icons.send, size: 14),
                  SizedBox(width: 4),
                  Text('Invite', style: TextStyle(fontSize: 13)),
                ],
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _inviteViaSms(SyncedContact contact) async {
    HapticFeedback.lightImpact();
    
    // Get current user for invite link
    final userModel = ref.read(currentUserProvider).valueOrNull;
    final userId = userModel?.id ?? '';
    
    final inviteService = ref.read(inviteServiceProvider);
    final message = inviteService.generateInviteMessage(
      senderName: userModel?.displayName ?? 'A friend',
    );
    final link = inviteService.generateInviteLink(userId);
    final fullMessage = '$message\n$link';
    
    // Clean phone number (keep only digits and +)
    final cleanPhone = contact.phoneNumber.replaceAll(RegExp(r'[^\d+]'), '');
    
    // Build SMS URI using proper Uri constructor
    final Uri smsUri = Uri(
      scheme: 'sms',
      path: cleanPhone,
      queryParameters: <String, String>{
        'body': fullMessage,
      },
    );
    
    try {
      if (await canLaunchUrl(smsUri)) {
        if (!mounted) return;
        await launchUrl(smsUri);
        if (!mounted) return;
        _showSuccess('Opening SMS to ${contact.displayName}...');
      } else {
        if (!mounted) return;
        _showError('Could not open SMS app');
      }
    } catch (e) {
      debugPrint('SMS launch error: $e');
      _showError('Failed to open SMS: $e');
    }
  }

  Widget _buildFindFriendsSection() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Section Header
          Row(
            children: [
              Icon(Icons.share, color: Colors.white.withOpacity(0.7), size: 18),
              const SizedBox(width: 8),
              Text(
                'Share with friends',
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.white.withOpacity(0.7),
                ),
              ),
            ],
          ),
          const SizedBox(height: 20),

          // ================================
          // 3-BUTTON SOCIAL SHARE ROW
          // ================================
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              // 1. INSTAGRAM BUTTON
              _buildSocialShareButton(
                icon: Icons.camera_alt_rounded,
                label: 'Instagram',
                gradient: const LinearGradient(
                  colors: [Color(0xFFF58529), Color(0xFFDD2A7B), Color(0xFF8134AF)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                onTap: () => _handleInstagramShare(),
              ),
              
              const SizedBox(width: 28),

              // 2. TIKTOK BUTTON  
              _buildSocialShareButton(
                icon: Icons.music_note_rounded,
                label: 'TikTok',
                color: Colors.black,
                borderColor: Colors.white.withOpacity(0.3),
                onTap: () => _handleTikTokTap(),
              ),
              
              const SizedBox(width: 28),

              // 3. SHARE BUTTON
              _buildSocialShareButton(
                icon: Icons.ios_share_rounded,
                label: 'Share',
                color: Colors.white,
                iconColor: Colors.black,
                onTap: () => _handleGenericShare(),
              ),
            ],
          ),

          const SizedBox(height: 32),

          // ================================
          // SYNC CONTACTS BUTTON (Opens Bottom Sheet)
          // ================================
          GestureDetector(
            onTap: () => _showContactsBottomSheet(),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.08),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(color: Colors.white.withOpacity(0.1)),
              ),
              child: Row(
                children: [
                  Container(
                    padding: const EdgeInsets.all(10),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.2),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.contacts, color: Colors.green, size: 22),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        const Text(
                          'Sync Contacts',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 16,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                        const SizedBox(height: 2),
                        Text(
                          'Find friends already on Nock',
                          style: TextStyle(
                            color: Colors.white.withOpacity(0.5),
                            fontSize: 13,
                          ),
                        ),
                      ],
                    ),
                  ),
                  Container(
                    padding: const EdgeInsets.all(8),
                    decoration: BoxDecoration(
                      color: Colors.white.withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(Icons.arrow_forward_ios, color: Colors.white54, size: 14),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  // ================================
  // SOCIAL SHARE BUTTON WIDGET
  // ================================
  Widget _buildSocialShareButton({
    required IconData icon,
    required String label,
    required VoidCallback onTap,
    Gradient? gradient,
    Color? color,
    Color? borderColor,
    Color iconColor = Colors.white,
  }) {
    return GestureDetector(
      onTap: () {
        HapticFeedback.mediumImpact();
        onTap();
      },
      child: Column(
        children: [
          Container(
            width: 64,
            height: 64,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              gradient: gradient,
              color: color,
              border: borderColor != null 
                  ? Border.all(color: borderColor, width: 2) 
                  : null,
              boxShadow: [
                BoxShadow(
                  color: (gradient != null 
                      ? const Color(0xFFDD2A7B) 
                      : (color ?? Colors.white)).withOpacity(0.3),
                  blurRadius: 16,
                  offset: const Offset(0, 6),
                ),
              ],
            ),
            child: Icon(icon, color: iconColor, size: 28),
          ),
          const SizedBox(height: 10),
          Text(
            label,
            style: TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.w500,
              color: Colors.white.withOpacity(0.9),
            ),
          ),
        ],
      ),
    );
  }

  // ================================
  // SHARE HANDLERS
  // ================================

  Future<void> _handleInstagramShare() async {
    // LAZY LOAD FIX: Prevent double-clicks during share
    if (_isSharing) return;
    setState(() => _isSharing = true);
    
    try {
      // Generate invite card first
      if (_generatedCardFile == null) {
        final file = await _generateInviteCard();
        if (file == null) {
          _showError('Failed to generate invite card');
          return;
        }
      }
      
      final shareService = ref.read(shareServiceProvider);
      
      // Check if Instagram is installed first
      final isInstalled = await shareService.isInstagramInstalled();
      if (!isInstalled) {
        _showError('Instagram is not installed');
        return;
      }
      
      // Open Instagram directly with explicit intent
      // This shows ONLY Instagram's picker (Feed, Messages, Reels, Stories) - NOT all apps!
      final success = await shareService.shareToInstagramDirect(_generatedCardFile!);
      
      if (!mounted) return;

      if (success) {
        _showSuccess('Opening Instagram...');
      } else {
        // Instagram not installed or failed to open
        _showError('Failed to open Instagram. Try the Share button instead!');
      }
    } finally {
      if (mounted) setState(() => _isSharing = false);
    }
  }

  Future<void> _handleTikTokTap() async {
    // LAZY LOAD FIX: Prevent double-clicks during share
    if (_isSharing) return;
    setState(() => _isSharing = true);
    
    try {
      // Generate invite card first (same as Instagram)
      if (_generatedCardFile == null) {
        final file = await _generateInviteCard();
        if (file == null) {
          _showError('Failed to generate invite card');
          return;
        }
      }
      
      final shareService = ref.read(shareServiceProvider);
      
      // Check if TikTok is installed
      final isInstalled = await shareService.isTikTokInstalled();
      if (!isInstalled) {
        _showError('TikTok is not installed');
        return;
      }
      
      // Share image to TikTok directly (bypasses system share sheet)
      final success = await shareService.shareToTikTok(_generatedCardFile!);
      
      if (!mounted) return;

      if (success) {
        _showSuccess('Opening TikTok...');
      } else {
        _showError('Failed to open TikTok. Try the Share button instead!');
      }
    } finally {
      if (mounted) setState(() => _isSharing = false);
    }
  }

  Future<void> _handleGenericShare() async {
    // LAZY LOAD FIX: Prevent double-clicks during share
    if (_isSharing) return;
    setState(() => _isSharing = true);
    
    try {
      // Generate invite card first
      if (_generatedCardFile == null) {
        await _generateInviteCard();
      }
      
      final userModel = ref.read(currentUserProvider).valueOrNull;
      final displayName = userModel?.displayName ?? 'A friend';
      final inviteService = ref.read(inviteServiceProvider);
      final message = inviteService.generateInviteMessage(senderName: displayName);
      
      // Open native share sheet with all options
      await Share.shareXFiles(
        _generatedCardFile != null ? [XFile(_generatedCardFile!.path)] : [],
        text: message,
        subject: 'Join me on Nock!',
      );
    } finally {
      if (mounted) setState(() => _isSharing = false);
    }
  }

  // ================================
  // CONTACTS BOTTOM SHEET
  // ================================

  void _showContactsBottomSheet() {
    HapticFeedback.mediumImpact();
    
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.transparent,
      builder: (context) => DraggableScrollableSheet(
        initialChildSize: 0.85,
        minChildSize: 0.5,
        maxChildSize: 0.95,
        builder: (context, scrollController) => Container(
          decoration: const BoxDecoration(
            color: Color(0xFF1A1A1A),
            borderRadius: BorderRadius.vertical(top: Radius.circular(28)),
          ),
          child: Column(
            children: [
              // Drag handle
              Center(
                child: Container(
                  margin: const EdgeInsets.only(top: 12, bottom: 16),
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.white24,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
              ),
              
              // Header
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text(
                      'Contacts on Nock',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 22,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    TextButton(
                      onPressed: () => Navigator.pop(context),
                      child: const Text(
                        'Done',
                        style: TextStyle(
                          color: AppColors.vibePrimary,
                          fontSize: 16,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
              
              const Divider(color: Colors.white10, height: 24),

              // Sync button if contacts not loaded yet
              if (_syncedContacts.isEmpty && !_isSyncingContacts)
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
                  child: GestureDetector(
                    onTap: () async {
                      final proceed = await _showContactDisclosure();
                      if (proceed == true) {
                        await _handleSyncContacts();
                        setState(() {}); // Refresh bottom sheet
                      }
                    },
                    child: Container(
                      width: double.infinity,
                      padding: const EdgeInsets.symmetric(vertical: 16),
                      decoration: BoxDecoration(
                        gradient: const LinearGradient(
                          colors: [AppColors.vibePrimary, AppColors.vibeSecondary],
                        ),
                        borderRadius: BorderRadius.circular(16),
                      ),
                      child: const Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.sync, color: Colors.white),
                          SizedBox(width: 8),
                          Text(
                            'Sync Contacts Now',
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),

              // Loading state
              if (_isSyncingContacts)
                const Expanded(
                  child: Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        CircularProgressIndicator(color: AppColors.vibePrimary),
                        SizedBox(height: 16),
                        Text(
                          'Syncing your contacts...',
                          style: TextStyle(color: Colors.white54),
                        ),
                      ],
                    ),
                  ),
                ),

              // Contacts list
              if (_syncedContacts.isNotEmpty)
                Expanded(
                  child: ListView.builder(
                    controller: scrollController,
                    padding: const EdgeInsets.symmetric(horizontal: 20),
                    itemCount: _syncedContacts.length,
                    itemBuilder: (context, index) {
                      final contact = _syncedContacts[index];
                      return _buildContactItem(contact);
                    },
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
  // ================================
  // CONTACT DISCLOSURE (2025 COMPLIANCE)
  // ================================

  Future<bool?> _showContactDisclosure() async {
    return await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF222222),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(24)),
        title: const Row(
          children: [
            Icon(Icons.privacy_tip, color: AppColors.vibePrimary),
            SizedBox(width: 12),
            Text(
              'Your Privacy',
              style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            ),
          ],
        ),
        content: const Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              'Nock uploads your contacts to our servers to help you find friends already on the app.',
              style: TextStyle(color: Colors.white, fontSize: 16),
            ),
            SizedBox(height: 12),
            Text(
              'Your data is encrypted and never shared with 3rd parties. You can disconnect at any time in Settings.',
              style: TextStyle(color: Colors.white70, fontSize: 14),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Not Now', style: TextStyle(color: Colors.white54)),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.vibePrimary,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
            ),
            child: const Text('Agree & Sync', style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
    );
  }

  Widget _buildQuickShareButton(
    String label,
    IconData icon,
    Color color,
    VoidCallback onTap,
  ) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            width: 56,
            height: 56,
            decoration: BoxDecoration(
              color: color,
              shape: BoxShape.circle,
              boxShadow: [
                BoxShadow(
                  color: color.withOpacity(0.3),
                  blurRadius: 12,
                  spreadRadius: 2,
                ),
              ],
            ),
            child: Icon(icon, color: Colors.white, size: 24),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: TextStyle(
              fontSize: 12,
              color: Colors.white.withOpacity(0.8),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInviteSection() {
    return Padding(
      padding: const EdgeInsets.all(20),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.send, color: Colors.white.withOpacity(0.7), size: 18),
              const SizedBox(width: 8),
              Text(
                'All invite options',
                style: TextStyle(
                  fontSize: 14,
                  color: Colors.white.withOpacity(0.7),
                ),
              ),
            ],
          ),
          const SizedBox(height: 16),
          
          _buildInviteOption(InviteTarget.instagramStory),
          _buildInviteOption(InviteTarget.instagramDm),
          _buildInviteOption(InviteTarget.messenger),
          _buildInviteOption(InviteTarget.whatsapp),
          _buildInviteOption(InviteTarget.snapchat),
          _buildInviteOption(InviteTarget.telegram),
          _buildInviteOption(InviteTarget.messages),
          _buildInviteOption(InviteTarget.other),
        ],
      ),
    );
  }

  Widget _buildInviteOption(InviteTarget target) {
    return GestureDetector(
      onTap: () => _shareToTarget(target),
      child: Container(
        margin: const EdgeInsets.only(bottom: 8),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
        decoration: BoxDecoration(
          color: Colors.white.withOpacity(0.05),
          borderRadius: BorderRadius.circular(12),
        ),
        child: Row(
          children: [
            Container(
              width: 40,
              height: 40,
              decoration: BoxDecoration(
                color: target.color,
                shape: BoxShape.circle,
              ),
              child: Icon(target.icon, color: Colors.white, size: 20),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    target.displayName,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    _getInviteDescription(target),
                    style: TextStyle(
                      color: Colors.white.withOpacity(0.5),
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
            ),
            Icon(
              Icons.chevron_right,
              color: Colors.white.withOpacity(0.5),
            ),
          ],
        ),
      ),
    );
  }

  String _getInviteDescription(InviteTarget target) {
    switch (target) {
      case InviteTarget.instagramStory:
        return 'Share to your Story';
      case InviteTarget.instagramDm:
        return 'Send via Direct Message';
      case InviteTarget.messenger:
        return 'Send via Facebook Messenger';
      case InviteTarget.whatsapp:
        return 'Send via WhatsApp chat';
      case InviteTarget.snapchat:
        return 'Share as a Snap';
      case InviteTarget.telegram:
        return 'Send via Telegram';
      case InviteTarget.messages:
        return 'Send as iMessage or SMS';
      case InviteTarget.other:
        return 'Use system share sheet';
    }
  }
}



========================================

FILE #61: E:\Vive\lib\features\squad\presentation\squad_screen.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/core/constants/app_constants.dart';
import 'package:nock/core/constants/app_routes.dart';
import 'package:nock/core/services/auth_service.dart';
import 'package:nock/core/services/vibe_service.dart';
import 'package:nock/core/models/user_model.dart';
import 'package:nock/core/models/squad_model.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/shared/widgets/aura_visualization.dart';
import 'package:rxdart/rxdart.dart'; // <--- ADD THIS LINE

/// Friends provider (basic - just user models)
/// FIX: Batch query to handle Firestore whereIn limit of 10
final friendsProvider = StreamProvider<List<UserModel>>((ref) {
  final currentUser = ref.watch(currentUserProvider);
  
  return currentUser.when(
    data: (user) {
      if (user == null || user.friendIds.isEmpty) {
        return Stream.value([]);
      }
      
      // FIX: Batch queries for friends beyond the whereIn limit of 10
      final friendIds = user.friendIds.toList();
      
      // Split into chunks of 10
      final chunks = <List<String>>[];
      for (var i = 0; i < friendIds.length; i += 10) {
        chunks.add(friendIds.sublist(
          i, 
          i + 10 > friendIds.length ? friendIds.length : i + 10,
        ));
      }
      
      // Create a stream for each chunk
      final streams = chunks.map((chunk) {
        return FirebaseFirestore.instance
            .collection(AppConstants.usersCollection)
            .where(FieldPath.documentId, whereIn: chunk)
            .snapshots()
            .map((snapshot) =>
                snapshot.docs.map((doc) => UserModel.fromFirestore(doc)).toList());
      }).toList();
      
      // Merge all streams
      if (streams.isEmpty) return Stream.value([]);
      if (streams.length == 1) return streams.first;
      
      // INDUSTRY BEST PRACTICE: Use CombineLatestStream for clean state management
      // This prevents duplicate accumulation and ensures UI shows exact DB state
      if (streams.length == 1) return streams.first;
      
      // CombineLatest emits whenever ANY chunk updates, with fresh complete list
      return CombineLatestStream.list(streams).map((listOfLists) {
        // Flatten List<List<UserModel>> into single List<UserModel>
        return listOfLists.expand((batch) => batch).toList();
      });
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
});

/// Squad member with health info combined
class SquadMember {
  final UserModel user;
  final VibeLevel vibeLevel;
  final DateTime? lastVibeAt;
  
  SquadMember({
    required this.user,
    required this.vibeLevel,
    this.lastVibeAt,
  });
}

/// Compute vibe level based on history
/// POSITIVE FRAMING: Connections are "Bloom", "Steady", or "Chill"
VibeLevel _computeVibeLevel(DateTime? lastActive) {
  // Null means no vibes yet - ready for first chill bloom!
  if (lastActive == null) return VibeLevel.chill;
  
  final now = DateTime.now();
  final daysSinceActive = now.difference(lastActive).inDays;
  
  if (daysSinceActive <= 1) {
    return VibeLevel.bloom;   // ðŸŒ¸ Active connection
  } else if (daysSinceActive <= 3) {
    return VibeLevel.steady;  // âš¡ Building history
  } else {
    return VibeLevel.chill;   // ðŸŒ«ï¸ Low-key / resting
  }
}

/// Enhanced friends provider with health status (Tamagotchi effect)
/// FIX: Batch query to handle Firestore whereIn limit of 30
final squadWithHealthProvider = StreamProvider<List<SquadMember>>((ref) {
  final currentUser = ref.watch(currentUserProvider);
  
  return currentUser.when(
    data: (user) {
      if (user == null || user.friendIds.isEmpty) {
        return Stream.value([]);
      }
      
      // FIX: Batch queries for friends beyond the whereIn limit of 30
      final friendIds = user.friendIds.toList();
      
      // Split into chunks of 10 (conservative, Firestore limit is 30)
      final chunks = <List<String>>[];
      for (var i = 0; i < friendIds.length; i += 10) {
        chunks.add(friendIds.sublist(
          i, 
          i + 10 > friendIds.length ? friendIds.length : i + 10,
        ));
      }
      
      // Create a stream for each chunk
      final streams = chunks.map((chunk) {
        return FirebaseFirestore.instance
            .collection(AppConstants.usersCollection)
            .where(FieldPath.documentId, whereIn: chunk)
            .snapshots()
            .map((snapshot) {
              return snapshot.docs.map((doc) {
                final userModel = UserModel.fromFirestore(doc);
                final vibeLevel = _computeVibeLevel(userModel.lastActive);
                return SquadMember(
                  user: userModel,
                  vibeLevel: vibeLevel,
                  lastVibeAt: userModel.lastActive,
                );
              }).toList();
            });
      }).toList();
      
      // Merge all streams using CombineLatestStream (same pattern as friendsProvider)
      if (streams.isEmpty) return Stream.value([]);
      if (streams.length == 1) return streams.first;
      
      // CombineLatest emits whenever ANY chunk updates, with fresh complete list
      return CombineLatestStream.list(streams).map((listOfLists) {
        // Flatten List<List<SquadMember>> into single List<SquadMember>
        return listOfLists.expand((batch) => batch).toList();
      });
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
});


/// Squad Screen - 2025 Modern UI/UX
/// 
/// Key Changes:
/// - FAB moved to bottom thumb zone for reachability
/// - Health-based visual hierarchy (glowing cards)
/// - Fluid animations and haptic feedback
class SquadScreen extends ConsumerStatefulWidget {
  const SquadScreen({super.key});

  @override
  ConsumerState<SquadScreen> createState() => _SquadScreenState();
}

class _SquadScreenState extends ConsumerState<SquadScreen> {
  @override
  Widget build(BuildContext context) {
    final squadMembers = ref.watch(squadWithHealthProvider);
    final currentUser = ref.watch(currentUserProvider);

    return Scaffold(
      backgroundColor: AppColors.background,
      // 2025 FIX: FAB at bottom for thumb reachability
      floatingActionButton: _buildAddFriendFAB(),
      floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
      body: SafeArea(
        child: Column(
          children: [
            // Header - Simplified, no action buttons in hard-to-reach zone
            Padding(
              padding: const EdgeInsets.fromLTRB(24, 16, 24, 8),
              child: Row(
                children: [
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Your Squad',
                          style: AppTypography.headlineLarge,
                        ),
                        const SizedBox(height: 4),
                        currentUser.when(
                          data: (user) => Text(
                            '${user?.friendIds.length ?? 0}/${AppConstants.maxFriendsCount} friends',
                            style: AppTypography.bodySmall,
                          ),
                          loading: () => const SizedBox(),
                          error: (_, __) => const SizedBox(),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),

            const SizedBox(height: 8),

            // Squad list with health indicators
            Expanded(
              child: squadMembers.when(
                data: (members) {
                  if (members.isEmpty) {
                    return _buildEmptyState();
                  }
                  
                  // 2025: Sort by recency, not "decay"
                  final sortedMembers = List<SquadMember>.from(members)
                    ..sort((a, b) {
                      final timeA = a.lastVibeAt ?? DateTime(0);
                      final timeB = b.lastVibeAt ?? DateTime(0);
                      return timeB.compareTo(timeA);
                    });
                  
                  return ListView.builder(
                    padding: const EdgeInsets.fromLTRB(24, 8, 24, 100),
                    itemCount: sortedMembers.length,
                    itemBuilder: (context, index) {
                      return _buildSquadMemberCard(sortedMembers[index]);
                    },
                  );
                },
                loading: () => const Center(
                  child: CircularProgressIndicator(
                    color: AppColors.primaryAction,
                  ),
                ),
                error: (_, __) => Center(
                  child: Text(
                    'Unable to load squad',
                    style: AppTypography.bodyMedium.copyWith(
                      color: AppColors.textSecondary,
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// 2025 FIX: Full-width FAB at bottom for thumb reachability
  Widget _buildAddFriendFAB() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24),
      child: SizedBox(
        width: double.infinity,
        height: 56,
        child: FloatingActionButton.extended(
          onPressed: () {
            HapticFeedback.mediumImpact();
            context.push(AppRoutes.addFriends);
          },
          backgroundColor: AppColors.primaryAction,
          icon: const Icon(Icons.person_add_rounded, color: Colors.black),
          label: Text(
            'Add Friends',
            style: AppTypography.buttonText.copyWith(color: Colors.black),
          ),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
        ),
      ),
    );
  }


  Widget _buildEmptyState() {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const AuraVisualization(
              size: 150,
              mood: AuraMood.calm,
            ),
            const SizedBox(height: 32),
            Text(
              'Your squad is empty',
              style: AppTypography.headlineMedium,
            ),
            const SizedBox(height: 8),
            Text(
              'Add friends to start sharing vibes',
              style: AppTypography.bodyMedium.copyWith(
                color: AppColors.textSecondary,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            // Explicit CTA at thumb level
            Text(
              'ðŸ‘‡ Tap below to add friends',
              style: AppTypography.bodySmall.copyWith(
                color: AppColors.primaryAction,
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// 2025 Card with history-based styling
  Widget _buildSquadMemberCard(SquadMember member) {
    final friend = member.user;
    final level = member.vibeLevel;
    
    return GestureDetector(
      onLongPress: () => _showFriendOptions(context, member),
      child: GlassContainer(
        margin: const EdgeInsets.only(bottom: 12),
        padding: const EdgeInsets.all(16),
        // LUMINOUS ARCHITECTURE: Use gradient borders instead of colored borders
        useLuminousBorder: true,
        // Move semantic color to subtle background tint
        backgroundColor: _getLevelColor(level).withOpacity(0.05),
        showGlow: level == VibeLevel.bloom || 
                  friend.status == UserStatus.online ||
                  friend.status == UserStatus.recording,
        useSmallGlow: true,
        glowColor: level == VibeLevel.bloom 
            ? AppColors.statusLive 
            : _getStatusColor(friend.status),
        child: Opacity(
          opacity: _getLevelOpacity(level),
          child: Row(
            children: [
              // Avatar with vibe ring
              _buildVibeAvatar(friend, level),
              
              const SizedBox(width: 16),
   
              // Friend info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      friend.displayName,
                      style: AppTypography.headlineSmall,
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        if (friend.status == UserStatus.recording)
                          _buildRecordingIndicator()
                        else if (level == VibeLevel.chill)
                          _buildChillNudge()  // ðŸŒ«ï¸ Low-key nudge
                        else
                          Text(
                            _getStatusText(friend),
                            style: AppTypography.bodySmall,
                          ),
                      ],
                    ),
                  ],
                ),
              ),
   
   
              const SizedBox(width: 12),
   
              // Quick Send
              GestureDetector(
                onTap: () {
                  HapticFeedback.mediumImpact();
                  context.push(AppRoutes.camera);
                },
                child: GlassButton(
                  width: 44,
                  height: 44,
                  onPressed: () {
                    HapticFeedback.mediumImpact();
                    context.push(AppRoutes.camera);
                  },
                  child: const Icon(
                    Icons.electric_bolt_rounded, // âš¡ Bolt instead of camera for "Quick Vibe"
                    color: AppColors.primaryAction,
                    size: 20,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildVibeAvatar(UserModel friend, VibeLevel level) {
    final levelColor = _getLevelColor(level);
    
    return Stack(
      children: [
        // Vibe ring glow with luminous border
        CustomPaint(
          painter: CircularLuminousBorderPainter(
            strokeWidth: 3,
            baseColor: levelColor,
          ),
          child: Container(
            width: 60,
            height: 60,
            decoration: BoxDecoration(
              shape: BoxShape.circle,
              boxShadow: level == VibeLevel.bloom
                  ? [
                      BoxShadow(
                        color: AppColors.statusLive.withAlpha(76),
                        blurRadius: 12,
                        spreadRadius: 2,
                      ),
                    ]
                  : null,
            ),
            child: Container(
              margin: const EdgeInsets.all(3),
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: AppColors.auraGradient,
              ),
              child: friend.avatarUrl != null
                  ? ClipOval(
                      child: Image.network(
                        friend.avatarUrl!,
                        fit: BoxFit.cover,
                      ),
                    )
                  : const Icon(
                      Icons.person,
                      size: 24,
                      color: Colors.white,
                    ),
            ),
          ),
        ),
        // Status dot
        Positioned(
          bottom: 0,
          right: 0,
          child: Container(
            width: 16,
            height: 16,
            decoration: BoxDecoration(
              color: _getStatusColor(friend.status),
              shape: BoxShape.circle,
              border: Border.all(
                color: AppColors.background,
                width: 2,
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildRecordingIndicator() {
    return Row(
      children: [
        Container(
          width: 8,
          height: 8,
          decoration: const BoxDecoration(
            color: AppColors.statusRecording,
            shape: BoxShape.circle,
          ),
        ),
        const SizedBox(width: 6),
        Text(
          'Recording...',
          style: AppTypography.statusText.copyWith(
            color: AppColors.statusRecording,
          ),
        ),
      ],
    );
  }

  /// ðŸŒ«ï¸ Chill nudge - Positive framing
  Widget _buildChillNudge() {
    return Row(
      children: [
        Icon(
          Icons.water_drop_rounded, // ðŸ’§ Water Drop (Needs care)
          size: 14,
          color: AppColors.primaryAction.withOpacity(0.7), // Blue/Cyan tint
        ),
        const SizedBox(width: 4),
        Text(
          'Water the garden ðŸŒ±', // Nurturing CTA
          style: AppTypography.bodySmall.copyWith(
            color: AppColors.textSecondary,
            fontStyle: FontStyle.italic,
          ),
        ),
      ],
    );
  }


  // Vibe level helpers (positive framing)
  Color _getLevelColor(VibeLevel level) {
    switch (level) {
      case VibeLevel.bloom:  // ðŸŒ¸ Active
        return AppColors.statusLive;
      case VibeLevel.steady: // âš¡ Steady
        return AppColors.primaryAction;
      case VibeLevel.chill:  // ðŸŒ«ï¸ Chill
        return Colors.grey;
    }
  }

  Color _getLevelBorderColor(VibeLevel level) {
    switch (level) {
      case VibeLevel.bloom:
        return AppColors.statusLive.withAlpha(76);
      case VibeLevel.steady:
        return AppColors.primaryAction.withAlpha(76);
      case VibeLevel.chill:
        return Colors.grey.withAlpha(76);
    }
  }

  double _getLevelOpacity(VibeLevel level) {
    switch (level) {
      case VibeLevel.bloom:
        return 1.0;
      case VibeLevel.steady:
        return 0.95;
      case VibeLevel.chill:
        return 0.85;
    }
  }

  Color _getStatusColor(UserStatus status) {
    switch (status) {
      case UserStatus.online:
        return AppColors.statusLive;
      case UserStatus.recording:
        return AppColors.statusRecording;
      case UserStatus.listening:
        return AppColors.primaryAction;
      case UserStatus.offline:
        return AppColors.statusOffline;
    }
  }

  String _getStatusText(UserModel friend) {
    final now = DateTime.now();
    final lastActive = friend.lastActive;
    final difference = now.difference(lastActive);

    if (friend.status == UserStatus.online) {
      return 'Online now';
    } else if (difference.inMinutes < 5) {
      return 'Just now';
    } else if (difference.inHours < 1) {
      return '${difference.inMinutes}m ago';
    } else if (difference.inDays < 1) {
      return '${difference.inHours}h ago';
    } else {
      return '${difference.inDays}d ago';
    }
  }

  /// Show friend management options
  Future<void> _showFriendOptions(BuildContext context, SquadMember member) async {
    await showModalBottomSheet(
      context: context,
      backgroundColor: AppColors.surface,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(24)),
      ),
      builder: (context) => Container(
        padding: const EdgeInsets.symmetric(vertical: 24, horizontal: 8),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Friend info header
            ListTile(
              leading: CircleAvatar(
                backgroundImage: member.user.avatarUrl != null 
                    ? NetworkImage(member.user.avatarUrl!) 
                    : null,
                child: member.user.avatarUrl == null 
                    ? const Icon(Icons.person) 
                    : null,
              ),
              title: Text(
                member.user.displayName,
                style: AppTypography.headlineSmall,
              ),
            ),
            const Divider(color: Colors.white10),
            
            // Remove Friend (soft exit)
            ListTile(
              leading: const Icon(Icons.person_remove_outlined, color: AppColors.textSecondary),
              title: const Text('Remove Friend', style: TextStyle(color: Colors.white)),
              subtitle: const Text('They won\'t be notified', style: TextStyle(color: Colors.white54, fontSize: 12)),
              onTap: () {
                Navigator.pop(context);
                _confirmRemoveFriend(context, member);
              },
            ),
            
            // Block (aggressive)
            ListTile(
              leading: const Icon(Icons.block, color: AppColors.urgency),
              title: const Text('Block', style: TextStyle(color: AppColors.urgency)),
              subtitle: const Text('Hides all content from this person', style: TextStyle(color: Colors.white24, fontSize: 12)),
              onTap: () {
                Navigator.pop(context);
                _confirmBlock(context, member);
              },
            ),
          ],
        ),
      ),
    );
  }
  
  /// Confirm remove friend
  Future<void> _confirmRemoveFriend(BuildContext context, SquadMember member) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Remove Friend?', style: TextStyle(color: Colors.white)),
        content: Text(
          'Remove ${member.user.displayName} from your friend list? They won\'t be notified.',
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: AppColors.textSecondary),
            child: const Text('Remove'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await _removeFriend(member.user.id);
    }
  }
  
  /// Confirm block user
  Future<void> _confirmBlock(BuildContext context, SquadMember member) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        title: const Text('Block User?', style: TextStyle(color: Colors.white)),
        content: Text(
          'Block ${member.user.displayName}? You won\'t see their vibes anymore.',
          style: const TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            style: TextButton.styleFrom(foregroundColor: AppColors.urgency),
            child: const Text('Block'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await _blockUser(member.user.id);
    }
  }
  
  /// Remove friend (silent)
  Future<void> _removeFriend(String friendId) async {
    try {
      await ref.read(authServiceProvider).removeFriend(friendId);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Friend removed'),
            backgroundColor: AppColors.success,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to remove friend: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }
  
  /// Block user
  Future<void> _blockUser(String userId) async {
    try {
      await ref.read(vibeServiceProvider).blockUser(userId);
      
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('User blocked'),
            backgroundColor: AppColors.success,
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to block user: $e'),
            backgroundColor: AppColors.error,
          ),
        );
      }
    }
  }
}



========================================

FILE #62: E:\Vive\lib\features\subscription\presentation\subscription_screen.dart

========================================


import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';
import 'package:nock/shared/widgets/glass_container.dart';
import 'package:nock/core/constants/app_constants.dart';
import '../../../core/services/subscription_service.dart';

/// Subscription Screen - Premium upgrade paywall
class SubscriptionScreen extends ConsumerStatefulWidget {
  const SubscriptionScreen({super.key});

  @override
  ConsumerState<SubscriptionScreen> createState() => _SubscriptionScreenState();
}

class _SubscriptionScreenState extends ConsumerState<SubscriptionScreen> {
  bool _isLoading = false;
  String _selectedProductId = AppConstants.subscriptionMonthlyId;

  Future<void> _handleRestore() async {
    setState(() => _isLoading = true);
    try {
      final isPremium = await ref.read(subscriptionServiceProvider).restorePurchases();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(isPremium 
              ? 'Purchases restored successfully! Access granted.' 
              : 'No active subscriptions found to restore.'),
          ),
        );
      }
    } on PlatformException catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error restoring purchases: ${e.message}')),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _handleSubscribe() async {
    setState(() => _isLoading = true);
    try {
      final isPremium = await ref.read(subscriptionServiceProvider).purchasePackage(_selectedProductId);
      if (isPremium && mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Welcome to VIBE+! Your memories are now safe.')),
        );
        context.pop();
      }
    } on PlatformException catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: ${e.message}')),
        );
      }
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppColors.voidNavy,
      appBar: AppBar(
        backgroundColor: Colors.transparent,
        automaticallyImplyLeading: false,
        actions: [
          IconButton(
            onPressed: () => context.pop(),
            icon: const Icon(Icons.close, color: Colors.white),
          ),
        ],
        leading: TextButton(
          onPressed: _isLoading ? null : _handleRestore,
          child: const Text(
            'Restore Purchases',
            style: TextStyle(
              color: Colors.white70,
              fontSize: 10,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        leadingWidth: 120,
      ),
      body: SafeArea(
        child: LayoutBuilder(
          builder: (context, constraints) {
            return SingleChildScrollView(
              padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              child: ConstrainedBox(
                constraints: BoxConstraints(minHeight: constraints.maxHeight - 24),
                child: IntrinsicHeight(
                  child: Column(
                    children: [
                      const Spacer(),
                      
                      // Logo
                      ShaderMask(
                        shaderCallback: (bounds) => const LinearGradient(
                          colors: [AppColors.primaryAction, AppColors.secondaryAction],
                        ).createShader(bounds),
                        child: Text(
                          'VIBE+',
                          style: AppTypography.displayLarge.copyWith(height: 1.0),
                        ),
                      ),
                      
                      const SizedBox(height: 32),
                      
                      // Features - Loss Aversion Messaging
                      _buildFeature(Icons.history, 'Don\'t let your history fade'),
                      _buildFeature(Icons.all_inclusive, 'Unlock all memories in the vault'),
                      _buildFeature(Icons.verified_user, 'Preserve your moments forever'),
                      _buildFeature(Icons.auto_awesome, 'Coming Soon: Retro Rewinds'),
                      
                      const Spacer(),
                      
                      // Tier Selection
                      Row(
                        children: [
                          _buildTierCard(
                            id: AppConstants.subscriptionWeeklyId,
                            title: 'Weekly',
                            price: '\$0.99',
                            subtitle: 'Impulse Pass',
                          ),
                          const SizedBox(width: 12),
                          _buildTierCard(
                            id: AppConstants.subscriptionMonthlyId,
                            title: 'Monthly',
                            price: '\$4.99',
                            subtitle: 'Popular',
                            isPopular: true,
                          ),
                          const SizedBox(width: 12),
                          _buildTierCard(
                            id: AppConstants.subscriptionAnnualId,
                            title: 'Annual',
                            price: '\$29.99',
                            subtitle: 'Best Value',
                          ),
                        ],
                      ),
                      
                      const SizedBox(height: 16),
                      
                      Text(
                        'Preserve your history. One tap to unlock.',
                        style: AppTypography.bodySmall.copyWith(color: Colors.white70),
                      ),
                      
                      const SizedBox(height: 24),
                      
                      // Subscribe button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton(
                          onPressed: _isLoading ? null : _handleSubscribe,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: AppColors.secondaryAction,
                            padding: const EdgeInsets.symmetric(vertical: 20),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(16),
                            ),
                            elevation: 8,
                            shadowColor: AppColors.secondaryAction.withValues(alpha: 0.5),
                          ),
                          child: _isLoading
                              ? const SizedBox(
                                  height: 20,
                                  width: 20,
                                  child: CircularProgressIndicator(
                                    color: Colors.white,
                                    strokeWidth: 2,
                                  ),
                                )
                              : Text(
                                  _selectedProductId == AppConstants.subscriptionAnnualId 
                                      ? 'Secure My Memories' 
                                      : 'Unlock Memory Vault',
                                  style: AppTypography.headlineMedium.copyWith(
                                    color: Colors.white,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                        ),
                      ),
                      
                      const SizedBox(height: 24),
                      
                      // Legal Links - Required by App Store
                      Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          GestureDetector(
                            onTap: _isLoading ? null : _handleRestore,
                            child: const Text(
                              'Restore Purchases',
                              style: TextStyle(
                                color: Colors.grey,
                                fontSize: 10,
                                decoration: TextDecoration.underline,
                              ),
                            ),
                          ),
                          const SizedBox(width: 24),
                          GestureDetector(
                            onTap: () {
                              // TODO: Open Terms
                            },
                            child: const Text(
                              'Terms of Service',
                              style: TextStyle(
                                color: Colors.grey,
                                fontSize: 10,
                                decoration: TextDecoration.underline,
                              ),
                            ),
                          ),
                          const SizedBox(width: 24),
                          GestureDetector(
                            onTap: () {
                              // TODO: Open Privacy
                            },
                            child: const Text(
                              'Privacy Policy',
                              style: TextStyle(
                                color: Colors.grey,
                                fontSize: 10,
                                decoration: TextDecoration.underline,
                              ),
                            ),
                          ),
                        ],
                      ),
                      
                      const SizedBox(height: 16),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildFeature(IconData icon, String text) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 12),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: AppColors.primaryAction.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(icon, color: AppColors.primaryAction, size: 24),
          ),
          const SizedBox(width: 16),
          Text(
            text,
            style: AppTypography.bodyLarge.copyWith(fontWeight: FontWeight.w500),
          ),
        ],
      ),
    );
  }

  Widget _buildTierCard({
    required String id,
    required String title,
    required String price,
    required String subtitle,
    bool isPopular = false,
  }) {
    final isSelected = _selectedProductId == id;
    
    return Expanded(
      child: GestureDetector(
        onTap: () => setState(() => _selectedProductId = id),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
          decoration: BoxDecoration(
            color: isSelected 
              ? AppColors.primaryAction.withOpacity(0.1) 
              : Colors.white.withOpacity(0.05),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(
              color: isSelected 
                ? AppColors.primaryAction 
                : Colors.white.withOpacity(0.1),
              width: 2,
            ),
          ),
          child: Column(
            children: [
              if (isPopular)
                Container(
                  padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                  margin: const EdgeInsets.only(bottom: 4),
                  decoration: BoxDecoration(
                    color: AppColors.primaryAction,
                    borderRadius: BorderRadius.circular(4),
                  ),
                    child: const Text(
                      'POPULAR',
                      style: TextStyle(
                        color: AppColors.voidNavy, // Ã¢Å“Â¨ Consistency
                        fontSize: 8,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                ),
              Text(
                title,
                style: AppTypography.bodySmall.copyWith(
                  fontWeight: FontWeight.bold,
                  color: isSelected ? Colors.white : Colors.white70,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                price,
                style: AppTypography.headlineSmall.copyWith(
                  fontWeight: FontWeight.w900,
                  color: isSelected ? AppColors.primaryAction : Colors.white,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                subtitle,
                style: const TextStyle(
                  color: Colors.white38,
                  fontSize: 8,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



========================================

FILE #63: E:\Vive\lib\features\widget\presentation\bff_config_screen.dart

========================================


import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:home_widget/home_widget.dart';
import '../../../core/theme/app_colors.dart';
import '../../../core/theme/app_typography.dart';
import '../../../core/models/user_model.dart';
import '../../../core/providers/friends_provider.dart';
import '../../../core/services/widget_update_service.dart';
import '../../../shared/widgets/glass_container.dart';

/// Modern BFF Widget Configuration Screen
/// 
/// Replaces the legacy BFFConfigActivity.kt with a fluid, visually rich 
/// interface that follows the 2025 "Liquid Glass" and "Aura" design trends.
class BFFConfigScreen extends ConsumerStatefulWidget {
  final int appWidgetId;

  const BFFConfigScreen({
    super.key,
    required this.appWidgetId,
  });

  @override
  ConsumerState<BFFConfigScreen> createState() => _BFFConfigScreenState();
}

class _BFFConfigScreenState extends ConsumerState<BFFConfigScreen> {
  String _searchQuery = '';
  String? _selectedFriendId;

  @override
  Widget build(BuildContext context) {
    final friendsAsync = ref.watch(friendsProvider);

    return Scaffold(
      extendBodyBehindAppBar: true,
      backgroundColor: AppColors.background,
      appBar: _buildLiquidAppBar(),
      body: Stack(
        children: [
          // Aura Background
          Positioned.fill(
            child: Container(
              decoration: const BoxDecoration(
                gradient: AppColors.darkGradient,
              ),
            ),
          ),
          
          SafeArea(
            child: Column(
              children: [
                _buildSearchBar(),
                const SizedBox(height: 16),
                Expanded(
                  child: friendsAsync.when(
                    data: (friends) {
                      // Hick's Law: Filter and Sort
                      final filtered = friends
                          .where((f) => f.displayName
                              .toLowerCase()
                              .contains(_searchQuery.toLowerCase()))
                          .toList();

                      // Sort by activity mapping (if friendship data was available)
                      // For now, we just show the alphabetic or default order from DB

                      if (filtered.isEmpty) {
                        return _buildEmptyState();
                      }

                      return ListView.builder(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        itemCount: filtered.length,
                        itemBuilder: (context, index) {
                          return _buildFriendCard(filtered[index]);
                        },
                      );
                    },
                    loading: () => const Center(
                      child: CircularProgressIndicator(color: AppColors.primaryAction),
                    ),
                    error: (e, _) => Center(
                      child: Text('Error: $e', style: AppTypography.bodyMedium),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  PreferredSizeWidget _buildLiquidAppBar() {
    return AppBar(
      backgroundColor: Colors.transparent,
      elevation: 0,
      title: Text(
        "Pick your BFF",
        style: AppTypography.headlineMedium.copyWith(
          fontFamily: 'Outfit', // Using Outfit as requested for modern feel
          letterSpacing: -0.5,
        ),
      ),
      centerTitle: true,
      flexibleSpace: ClipRRect(
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 16, sigmaY: 16),
          child: Container(
            color: AppColors.background.withOpacity(0.6),
          ),
        ),
      ),
    );
  }

  Widget _buildSearchBar() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24.0),
      child: TextField(
        style: const TextStyle(color: Colors.white),
        onChanged: (val) => setState(() => _searchQuery = val),
        decoration: InputDecoration(
          hintText: "Search your squad...",
          hintStyle: TextStyle(color: Colors.white.withOpacity(0.4)),
          filled: true,
          fillColor: Colors.white.withOpacity(0.05),
          contentPadding: const EdgeInsets.symmetric(vertical: 16, horizontal: 20),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(24),
            borderSide: BorderSide.none,
          ),
          prefixIcon: Icon(Icons.search, color: Colors.white.withOpacity(0.5)),
        ),
      ),
    );
  }

  Widget _buildFriendCard(UserModel friend) {
    final isSelected = _selectedFriendId == friend.id;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutQuint,
        decoration: BoxDecoration(
          color: isSelected ? AppColors.primaryAction.withOpacity(0.1) : Colors.white.withOpacity(0.03),
          borderRadius: BorderRadius.circular(24),
          border: Border.all(
            color: isSelected ? AppColors.primaryAction.withOpacity(0.5) : Colors.white.withOpacity(0.05),
            width: isSelected ? 1.5 : 1,
          ),
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(24),
            onTap: () async {
              HapticFeedback.selectionClick();
              setState(() => _selectedFriendId = friend.id);
              
              // Save to Native Widget via HomeWidget
              await _saveFriendToWidget(friend);
              
              // Delay slightly for animation
              Future.delayed(const Duration(milliseconds: 300), () {
                if (mounted) {
                   Navigator.of(context).pop();
                }
              });
            },
            child: Padding(
              padding: const EdgeInsets.all(16),
              child: Row(
                children: [
                  Container(
                    width: 48,
                    height: 48,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      image: friend.avatarUrl != null
                          ? DecorationImage(
                              image: NetworkImage(friend.avatarUrl!),
                              fit: BoxFit.cover,
                            )
                          : null,
                      gradient: friend.avatarUrl == null ? AppColors.primaryGradient : null,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          friend.displayName,
                          style: AppTypography.labelLarge.copyWith(
                            color: isSelected ? AppColors.primaryAction : Colors.white,
                          ),
                        ),
                        if (friend.username != null)
                          Text(
                            "@${friend.username}",
                            style: AppTypography.caption,
                          ),
                      ],
                    ),
                  ),
                  Icon(
                    isSelected ? Icons.check_circle : Icons.circle_outlined,
                    color: isSelected ? AppColors.primaryAction : Colors.white.withOpacity(0.2),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.people_outline, size: 64, color: Colors.white.withOpacity(0.2)),
          const SizedBox(height: 16),
          Text(
            "No friends found",
            style: AppTypography.headlineSmall.copyWith(color: Colors.white.withOpacity(0.5)),
          ),
        ],
      ),
    );
  }

  Future<void> _saveFriendToWidget(UserModel friend) async {
    // Ported from BFFConfigActivity.kt logic
    final keyPrefix = "widget_${widget.appWidgetId}";
    
    await Future.wait([
      HomeWidget.saveWidgetData<String>('${keyPrefix}_friendId', friend.id),
      HomeWidget.saveWidgetData<String>('${keyPrefix}_name', friend.displayName),
      HomeWidget.saveWidgetData<String>('${keyPrefix}_avatar', friend.avatarUrl ?? ''),
    ]);

    // Update the widget
    await HomeWidget.updateWidget(
      name: 'BFFWidgetProvider',
    );

    // Communicate back to native to finish configuration
    const widgetChannel = MethodChannel('com.nock.nock/widget');
    await widgetChannel.invokeMethod('finishConfig', {
      'appWidgetId': widget.appWidgetId,
    });
  }
}



========================================

FILE #64: E:\Vive\lib\shared\widgets\aura_visualization.dart

========================================


import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:nock/core/theme/app_colors.dart';

/// Aura Visualization Widget
/// Creates a glowing, pulsing color blob that responds to audio
/// Maps volume to size and pitch/sentiment to color
class AuraVisualization extends StatefulWidget {
  final List<double> waveformData;
  final bool isRecording;
  final bool isPlaying;
  final double size;
  final AuraMood mood;

  const AuraVisualization({
    super.key,
    this.waveformData = const [],
    this.isRecording = false,
    this.isPlaying = false,
    this.size = 200,
    this.mood = AuraMood.neutral,
  });

  @override
  State<AuraVisualization> createState() => _AuraVisualizationState();
}

class _AuraVisualizationState extends State<AuraVisualization>
    with TickerProviderStateMixin {
  late AnimationController _pulseController;
  late AnimationController _rotationController;
  late Animation<double> _pulseAnimation;

  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );
    _rotationController = AnimationController(
      duration: const Duration(seconds: 10),
      vsync: this,
    );

    _pulseAnimation = Tween<double>(begin: 0.9, end: 1.1).animate(
      CurvedAnimation(parent: _pulseController, curve: Curves.easeInOut),
    );

    _pulseController.repeat(reverse: true);
    _rotationController.repeat();
  }

  @override
  void dispose() {
    _pulseController.dispose();
    _rotationController.dispose();
    super.dispose();
  }

  Color get _primaryColor {
    switch (widget.mood) {
      case AuraMood.happy:
        return AppColors.auraHappy;
      case AuraMood.excited:
        return AppColors.auraWarm;
      case AuraMood.calm:
        return AppColors.auraCool;
      case AuraMood.sad:
        return AppColors.auraSad;
      case AuraMood.neutral:
      default:
        return AppColors.auraNeutral;
    }
  }

  Color get _secondaryColor {
    switch (widget.mood) {
      case AuraMood.happy:
        return AppColors.auraWarm;
      case AuraMood.excited:
        return AppColors.secondaryAction;
      case AuraMood.calm:
        return AppColors.auraSad;
      case AuraMood.sad:
        return AppColors.auraCool;
      case AuraMood.neutral:
      default:
        return AppColors.primaryAction;
    }
  }

  double get _currentAmplitude {
    if (widget.waveformData.isEmpty) return 0.5;
    return widget.waveformData.last.clamp(0.0, 1.0);
  }

  @override
  Widget build(BuildContext context) {
    final isActive = widget.isRecording || widget.isPlaying;

    return AnimatedBuilder(
      animation: Listenable.merge([_pulseAnimation, _rotationController]),
      builder: (context, child) {
        final baseScale = isActive
            ? 0.8 + (_currentAmplitude * 0.4)
            : _pulseAnimation.value * 0.9;

        return SizedBox(
          width: widget.size,
          height: widget.size,
          child: Stack(
            alignment: Alignment.center,
            children: [
              // Outer glow
              Transform.scale(
                scale: baseScale * 1.2,
                child: Container(
                  width: widget.size,
                  height: widget.size,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    gradient: RadialGradient(
                      colors: [
                        _primaryColor.withOpacity(0.3),
                        _primaryColor.withOpacity(0.1),
                        Colors.transparent,
                      ],
                    ),
                  ),
                ),
              ),

              // Middle layer - rotating gradient
              Transform.rotate(
                angle: _rotationController.value * 2 * math.pi,
                child: Transform.scale(
                  scale: baseScale,
                  child: Container(
                    width: widget.size * 0.8,
                    height: widget.size * 0.8,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      gradient: SweepGradient(
                        colors: [
                          _primaryColor,
                          _secondaryColor,
                          _primaryColor.withOpacity(0.5),
                          _secondaryColor.withOpacity(0.5),
                          _primaryColor,
                        ],
                      ),
                    ),
                  ),
                ),
              ),

              // Core blob with blur
              Transform.scale(
                scale: baseScale * 0.9,
                child: Container(
                  width: widget.size * 0.6,
                  height: widget.size * 0.6,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    gradient: RadialGradient(
                      colors: [
                        Colors.white.withOpacity(0.9),
                        _primaryColor.withOpacity(0.8),
                        _secondaryColor.withOpacity(0.6),
                      ],
                    ),
                    boxShadow: [
                      BoxShadow(
                        color: _primaryColor.withOpacity(0.5),
                        blurRadius: 30,
                        spreadRadius: 10,
                      ),
                    ],
                  ),
                ),
              ),

              // Waveform overlay when active
              if (isActive && widget.waveformData.isNotEmpty)
                RepaintBoundary(
                  child: CustomPaint(
                    size: Size(widget.size, widget.size),
                    painter: WaveformPainter(
                      waveformData: List.from(widget.waveformData), // Pass a snapshot
                      color: Colors.white.withOpacity(0.5),
                    ),
                  ),
                ),

              // Center icon
              Icon(
                widget.isRecording
                    ? Icons.mic
                    : widget.isPlaying
                        ? Icons.volume_up
                        : Icons.touch_app,
                color: AppColors.background,
                size: widget.size * 0.2,
              ),
            ],
          ),
        );
      },
    );
  }
}

/// Waveform painter for the aura center
class WaveformPainter extends CustomPainter {
  final List<double> waveformData;
  final Color color;

  WaveformPainter({
    required this.waveformData,
    required this.color,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (waveformData.isEmpty) return;

    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2;

    final path = Path();
    final centerY = size.height / 2;
    final width = size.width;
    final barWidth = width / waveformData.length;

    for (int i = 0; i < waveformData.length; i++) {
      final x = i * barWidth;
      final amplitude = waveformData[i] * size.height * 0.3;

      if (i == 0) {
        path.moveTo(x, centerY - amplitude);
      } else {
        path.lineTo(x, centerY - amplitude);
      }
    }

    // Mirror the waveform
    for (int i = waveformData.length - 1; i >= 0; i--) {
      final x = i * barWidth;
      final amplitude = waveformData[i] * size.height * 0.3;
      path.lineTo(x, centerY + amplitude);
    }

    path.close();
    canvas.drawPath(path, paint);
  }

  @override
  bool shouldRepaint(WaveformPainter oldDelegate) {
    // Robust comparison: length check first (fast), then reference check
    if (oldDelegate.waveformData.length != waveformData.length) return true;
    return oldDelegate.waveformData != waveformData || oldDelegate.color != color;
  }
}

/// Mood types for Aura visualization
enum AuraMood {
  happy,    // Yellow/Gold
  excited,  // Orange/Pink
  calm,     // Blue
  sad,      // Purple
  neutral,  // Cyan
}

/// Simple waveform bar visualization
class WaveformBars extends StatelessWidget {
  final List<double> waveformData;
  final double height;
  final Color color;
  final int barCount;

  const WaveformBars({
    super.key,
    required this.waveformData,
    this.height = 40,
    this.color = AppColors.primaryAction,
    this.barCount = 30,
  });

  @override
  Widget build(BuildContext context) {
    final displayData = _normalizeData();

    return SizedBox(
      height: height,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        crossAxisAlignment: CrossAxisAlignment.center,
        children: List.generate(barCount, (index) {
          final value = displayData.length > index
              ? displayData[index]
              : 0.1;
          return AnimatedContainer(
            duration: const Duration(milliseconds: 100),
            width: 3,
            height: height * value.clamp(0.1, 1.0),
            decoration: BoxDecoration(
              color: color,
              borderRadius: BorderRadius.circular(1.5),
            ),
          );
        }),
      ),
    );
  }

  List<double> _normalizeData() {
    if (waveformData.isEmpty) {
      return List.generate(barCount, (_) => 0.1);
    }

    // Sample the waveform data to match bar count
    final step = waveformData.length / barCount;
    return List.generate(barCount, (i) {
      final index = (i * step).floor().clamp(0, waveformData.length - 1);
      return waveformData[index];
    });
  }
}



========================================

FILE #65: E:\Vive\lib\shared\widgets\glass_container.dart

========================================


import 'dart:ui';
import 'dart:math' as math;
import 'package:flutter/material.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/constants/app_constants.dart';

/// Glassmorphic Container - 2025 Enhanced (Luminous Architecture)
/// 
/// Key Changes for 2025:
/// - Luminous gradient borders (simulates light catching glass edges)
/// - Layered structure for proper depth
/// - Optional inner glow for premium feel
/// - Variable blur support
/// 
/// Set `useLuminousBorder: true` to enable the Spatial Glass effect
class GlassContainer extends StatelessWidget {
  final Widget child;
  final double? width;
  final double? height;
  final EdgeInsetsGeometry? padding;
  final EdgeInsetsGeometry? margin;
  final double borderRadius;
  final double blurAmount;
  final Color? backgroundColor;
  final Color? borderColor;
  final bool showGlow;
  final bool useSmallGlow;
  final Color glowColor;
  final VoidCallback? onTap;
  
  /// Enable luminous gradient borders (Spatial Glass architecture)
  /// Creates light-catching effect on glass edges
  final bool useLuminousBorder;

  const GlassContainer({
    super.key,
    required this.child,
    this.width,
    this.height,
    this.padding,
    this.margin,
    this.borderRadius = AppConstants.borderRadiusLarge,
    this.blurAmount = AppConstants.glassBlurAmount,
    this.backgroundColor,
    this.borderColor,
    this.showGlow = false,
    this.useSmallGlow = false,
    this.glowColor = AppColors.primaryAction,
    this.onTap,
    this.useLuminousBorder = false, // Opt-in for Spatial Glass
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: margin,
      decoration: showGlow
          ? BoxDecoration(
              borderRadius: BorderRadius.circular(borderRadius),
              boxShadow: [
                BoxShadow(
                  color: glowColor.withAlpha(20), // Reduced to subtle outline
                  blurRadius: 10,
                  spreadRadius: 1,
                ),
              ],
            )
          : null,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(borderRadius),
        child: RepaintBoundary(
          child: BackdropFilter(
            filter: ImageFilter.blur(sigmaX: blurAmount, sigmaY: blurAmount),
            child: GestureDetector(
              onTap: onTap,
              child: useLuminousBorder
                  ? CustomPaint(
                      painter: _LuminousBorderPainter(
                        borderRadius: borderRadius,
                        borderColor: borderColor ?? AppColors.glassBorder,
                      ),
                      child: Container(
                        width: width,
                        height: height,
                        padding: padding,
                        decoration: BoxDecoration(
                          color: backgroundColor ?? AppColors.glassBackground,
                          borderRadius: BorderRadius.circular(borderRadius),
                          // No border here - painted by CustomPainter
                        ),
                        child: child,
                      ),
                    )
                  : Container(
                      width: width,
                      height: height,
                      padding: padding,
                      decoration: BoxDecoration(
                        color: backgroundColor ?? AppColors.glassBackground,
                        borderRadius: BorderRadius.circular(borderRadius),
                        border: Border.all(
                          color: borderColor ?? AppColors.glassBorder,
                          width: 1.5, // Standard border (legacy)
                        ),
                      ),
                      child: child,
                    ),
            ),
          ),
        ),
      ),
    );
  }

  /// Surface gradient for depth
  LinearGradient _buildSurfaceGradient() {
    return LinearGradient(
      begin: Alignment.topCenter,
      end: Alignment.bottomCenter,
      colors: [
        Colors.white.withAlpha(13), // 5%
        Colors.white.withAlpha(5),  // 2%
      ],
    );
  }

  /// Rim light gradient for 3D effect
  LinearGradient _buildRimGradient() {
    return LinearGradient(
      begin: Alignment.topLeft,
      end: Alignment.bottomRight,
      colors: [
        Colors.white.withAlpha(20), // 8%
        Colors.white.withAlpha(5),  // 2%
        Colors.transparent,
      ],
      stops: const [0.0, 0.3, 1.0],
    );
  }
}

/// Custom painter for luminous gradient borders (Spatial Glass)
/// Paints a gradient stroke that fades from top (light catch) to bottom (transparent)
class _LuminousBorderPainter extends CustomPainter {
  final double borderRadius;
  final Color borderColor;
  
  _LuminousBorderPainter({
    required this.borderRadius,
    required this.borderColor,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final rect = Rect.fromLTWH(0, 0, size.width, size.height);
    final rrect = RRect.fromRectAndRadius(
      rect,
      Radius.circular(borderRadius),
    );
    
    // Create gradient shader (top bright, bottom fades)
    final gradient = LinearGradient(
      begin: Alignment.topCenter,
      end: Alignment.bottomCenter,
      colors: [
        AppColors.luminousBorderTop,
        AppColors.luminousBorderBottom,
      ],
    );
    
    final paint = Paint()
      ..shader = gradient.createShader(rect)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5;
    
    canvas.drawRRect(rrect, paint);
  }
  
  @override
  bool shouldRepaint(_LuminousBorderPainter oldDelegate) {
    return oldDelegate.borderRadius != borderRadius ||
           oldDelegate.borderColor != borderColor;
  }
}

/// Custom painter for luminous gradient borders on CIRCULAR shapes
/// Used for camera shutter, avatars, and other circular elements
class CircularLuminousBorderPainter extends CustomPainter {
  final double strokeWidth;
  final Color baseColor;
  
  CircularLuminousBorderPainter({
    required this.strokeWidth,
    required this.baseColor,
  });
  
  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2;
    
    // Create gradient shader (top bright, bottom fades)
    // For circular shapes, we simulate top-bottom gradient radially
    final gradient = SweepGradient(
      center: Alignment.center,
      startAngle: -math.pi / 2, // Start at top (12 o'clock)
      endAngle: 3 * math.pi / 2, // End at top (full rotation)
      colors: [
        // Top (brightest)
        Color.lerp(baseColor, Colors.white, 0.6)!,
        // Sides (medium)
        baseColor,
        // Bottom (fade)
        Color.lerp(baseColor, Colors.transparent, 0.7)!,
        // Back to top
        Color.lerp(baseColor, Colors.white, 0.6)!,
      ],
      stops: const [0.0, 0.25, 0.5, 1.0],
    );
    
    final rect = Rect.fromCircle(center: center, radius: radius);
    final paint = Paint()
      ..shader = gradient.createShader(rect)
      ..style = PaintingStyle.stroke
      ..strokeWidth = strokeWidth;
    
    canvas.drawCircle(center, radius - strokeWidth / 2, paint);
  }
  
  @override
  bool shouldRepaint(CircularLuminousBorderPainter oldDelegate) {
    return oldDelegate.strokeWidth != strokeWidth ||
           oldDelegate.baseColor != baseColor;
  }
}

/// Glassmorphic Card with enhanced styling
class GlassCard extends StatelessWidget {
  final Widget child;
  final EdgeInsetsGeometry? padding;
  final EdgeInsetsGeometry? margin;
  final double borderRadius;
  final VoidCallback? onTap;
  final bool isSelected;

  const GlassCard({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.all(16),
    this.margin,
    this.borderRadius = AppConstants.borderRadiusLarge,
    this.onTap,
    this.isSelected = false,
  });

  @override
  Widget build(BuildContext context) {
    return GlassContainer(
      padding: padding,
      margin: margin,
      borderRadius: borderRadius,
      showGlow: isSelected,
      glowColor: AppColors.primaryAction,
      useLuminousBorder: true, // Ã¢Å“Â¨ Enable Spatial Glass by default
      borderColor:
          isSelected ? AppColors.primaryAction : AppColors.glassBorder,
      onTap: onTap,
      child: child,
    );
  }
}

/// Glassmorphic Button with press animation
class GlassButton extends StatefulWidget {
  final Widget child;
  final VoidCallback? onPressed;
  final double width;
  final double height;
  final bool isLoading;
  final Color? glowColor;

  const GlassButton({
    super.key,
    required this.child,
    this.onPressed,
    this.width = 60,
    this.height = 60,
    this.isLoading = false,
    this.glowColor,
  });

  @override
  State<GlassButton> createState() => _GlassButtonState();
}

class _GlassButtonState extends State<GlassButton>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 100),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.95).animate(
      CurvedAnimation(parent: _controller, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: (_) => _controller.forward(),
      onTapUp: (_) {
        _controller.reverse();
        widget.onPressed?.call();
      },
      onTapCancel: () => _controller.reverse(),
      child: AnimatedBuilder(
        animation: _scaleAnimation,
        builder: (context, child) {
          return Transform.scale(
            scale: _scaleAnimation.value,
            child: GlassContainer(
              width: widget.width,
              height: widget.height,
              borderRadius: widget.width / 2,
              showGlow: widget.glowColor != null,
              glowColor: widget.glowColor ?? AppColors.primaryAction,
              child: Center(
                child: widget.isLoading
                    ? const SizedBox(
                        width: 24,
                        height: 24,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: AppColors.primaryAction,
                        ),
                      )
                    : widget.child,
              ),
            ),
          );
        },
      ),
    );
  }
}

/// 2025: Modern pill-shaped action button
class GlassPill extends StatelessWidget {
  final String label;
  final IconData? icon;
  final VoidCallback? onTap;
  final Color? accentColor;
  final bool isActive;

  const GlassPill({
    super.key,
    required this.label,
    this.icon,
    this.onTap,
    this.accentColor,
    this.isActive = false,
  });

  @override
  Widget build(BuildContext context) {
    final color = accentColor ?? AppColors.primaryAction;
    
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
        decoration: BoxDecoration(
          color: isActive 
              ? color.withAlpha(51) 
              : AppColors.glassBackground,
          borderRadius: BorderRadius.circular(24),
          border: Border.all(
            color: isActive ? color : AppColors.glassBorder,
            width: 1,
          ),
        ),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (icon != null) ...[
              Icon(icon, size: 18, color: isActive ? color : AppColors.textSecondary),
              const SizedBox(width: 8),
            ],
            Text(
              label,
              style: TextStyle(
                color: isActive ? color : AppColors.textSecondary,
                fontSize: 14,
                fontWeight: isActive ? FontWeight.w600 : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



========================================

FILE #66: E:\Vive\lib\shared\widgets\permission_guard.dart

========================================


import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:nock/core/theme/app_colors.dart';
import 'package:nock/core/theme/app_typography.dart';

/// 2025 Permission Guard - Contextual Progressive Disclosure
/// 
/// Instead of blocking users with full-screen permission gates,
/// this widget wraps interactive elements and requests permissions
/// only when the user attempts to use the feature.
/// 
/// Usage:
/// ```dart
/// PermissionGuard(
///   permission: Permission.camera,
///   featureName: 'Camera',
///   featureDescription: 'Take photos to share with voice notes',
///   onGranted: () => _startCamera(),
///   child: CaptureButton(),
/// )
/// ```
class PermissionGuard extends StatelessWidget {
  final Permission permission;
  final String featureName;
  final String featureDescription;
  final VoidCallback onGranted;
  final Widget child;
  
  /// Optional: Called when permanently denied (after showing settings dialog)
  final VoidCallback? onPermanentlyDenied;

  const PermissionGuard({
    super.key,
    required this.permission,
    required this.featureName,
    required this.featureDescription,
    required this.onGranted,
    required this.child,
    this.onPermanentlyDenied,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () => _handleTap(context),
      child: child,
    );
  }

  Future<void> _handleTap(BuildContext context) async {
    // Check if already granted
    final status = await permission.status;
    
    if (status.isGranted) {
      onGranted();
      return;
    }
    
    if (status.isPermanentlyDenied) {
      _showSettingsDialog(context);
      return;
    }
    
    // Show contextual permission request
    final shouldRequest = await _showPermissionExplanation(context);
    
    if (shouldRequest) {
      final newStatus = await permission.request();
      
      if (newStatus.isGranted) {
        onGranted();
      } else if (newStatus.isPermanentlyDenied) {
        _showSettingsDialog(context);
      }
    }
  }

  Future<bool> _showPermissionExplanation(BuildContext context) async {
    return await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        title: Row(
          children: [
            Icon(
              _getIconForPermission(),
              color: AppColors.primaryAction,
            ),
            const SizedBox(width: 12),
            Text(
              featureName,
              style: AppTypography.headlineMedium,
            ),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              featureDescription,
              style: AppTypography.bodyMedium.copyWith(
                color: AppColors.textSecondary,
              ),
            ),
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: AppColors.primaryAction.withAlpha(25),
                borderRadius: BorderRadius.circular(12),
              ),
              child: Row(
                children: [
                  const Icon(
                    Icons.privacy_tip_outlined,
                    color: AppColors.primaryAction,
                    size: 20,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      'Your privacy is important. We only use this when you\'re actively using the feature.',
                      style: AppTypography.labelSmall.copyWith(
                        color: AppColors.primaryAction,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(
              'Not Now',
              style: TextStyle(color: AppColors.textSecondary),
            ),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryAction,
            ),
            child: Text(
              'Enable $featureName',
              style: const TextStyle(color: Colors.black),
            ),
          ),
        ],
      ),
    ) ?? false;
  }

  void _showSettingsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: AppColors.surface,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(20),
        ),
        title: Text(
          '$featureName Access Required',
          style: AppTypography.headlineMedium,
        ),
        content: Text(
          'You\'ve previously denied $featureName access. Please enable it in Settings to use this feature.',
          style: AppTypography.bodyMedium.copyWith(
            color: AppColors.textSecondary,
          ),
        ),
        actions: [
          TextButton(
            onPressed: () {
              Navigator.pop(context);
              onPermanentlyDenied?.call();
            },
            child: const Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              openAppSettings();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: AppColors.primaryAction,
            ),
            child: const Text(
              'Open Settings',
              style: TextStyle(color: Colors.black),
            ),
          ),
        ],
      ),
    );
  }

  IconData _getIconForPermission() {
    if (permission == Permission.camera) return Icons.camera_alt;
    if (permission == Permission.microphone) return Icons.mic;
    if (permission == Permission.notification) return Icons.notifications;
    if (permission == Permission.contacts) return Icons.contacts;
    if (permission == Permission.photos) return Icons.photo_library;
    return Icons.security;
  }
}

/// Helper function to check and request camera + mic together
Future<bool> requestCameraAndMicPermissions(BuildContext context) async {
  final cameraStatus = await Permission.camera.status;
  final micStatus = await Permission.microphone.status;
  
  if (cameraStatus.isGranted && micStatus.isGranted) {
    return true;
  }
  
  // Request both together
  final statuses = await [
    Permission.camera,
    Permission.microphone,
  ].request();
  
  final allGranted = statuses.values.every((status) => status.isGranted);
  
  if (!allGranted) {
    final hasPermanentlyDenied = statuses.values.any((s) => s.isPermanentlyDenied);
    
    if (hasPermanentlyDenied && context.mounted) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          backgroundColor: AppColors.surface,
          title: Text('Permissions Required', style: AppTypography.headlineMedium),
          content: Text(
            'Camera and Microphone access are needed to create vibes. Please enable them in Settings.',
            style: AppTypography.bodyMedium,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () {
                Navigator.pop(context);
                openAppSettings();
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: AppColors.primaryAction,
              ),
              child: const Text('Open Settings', style: TextStyle(color: Colors.black)),
            ),
          ],
        ),
      );
    }
  }
  
  return allGranted;
}

/// Helper function to check and request notification permission
/// Call this after user sends their first vibe
Future<bool> requestNotificationPermission(BuildContext context) async {
  final status = await Permission.notification.status;
  
  if (status.isGranted) return true;
  
  final shouldRequest = await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      backgroundColor: AppColors.surface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20),
      ),
      title: Row(
        children: [
          const Icon(Icons.notifications_active, color: AppColors.secondaryAction),
          const SizedBox(width: 12),
          Text('Stay Connected', style: AppTypography.headlineMedium),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            'Get notified when your friends send you vibes!',
            style: AppTypography.bodyMedium.copyWith(
              color: AppColors.textSecondary,
            ),
          ),
          const SizedBox(height: 16),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: AppColors.secondaryAction.withAlpha(25),
              borderRadius: BorderRadius.circular(12),
            ),
            child: Row(
              children: [
                const Icon(Icons.favorite, color: AppColors.secondaryAction, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    'You just sent your first vibe! ðŸŽ‰',
                    style: AppTypography.labelSmall.copyWith(
                      color: AppColors.secondaryAction,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context, false),
          child: Text('Maybe Later', style: TextStyle(color: AppColors.textSecondary)),
        ),
        ElevatedButton(
          onPressed: () => Navigator.pop(context, true),
          style: ElevatedButton.styleFrom(
            backgroundColor: AppColors.secondaryAction,
          ),
          child: const Text('Enable Notifications', style: TextStyle(color: Colors.white)),
        ),
      ],
    ),
  ) ?? false;
  
  if (shouldRequest) {
    final newStatus = await Permission.notification.request();
    return newStatus.isGranted;
  }
  
  return false;
}



========================================

FILE #67: E:\Vive\lib\shared\widgets\qr_invite_card.dart

========================================


import 'package:flutter/material.dart';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:nock/core/theme/app_colors.dart';

/// QR Code Invite Card Widget
/// Displays a clean QR code card that users can share to invite friends.
/// Similar to AirBuds.fm design - white card with username, tagline, and scannable QR.
class QRInviteCard extends StatelessWidget {
  final String username;
  final String? userId;
  final String? displayName;

  const QRInviteCard({
    super.key,
    required this.username,
    this.userId,
    this.displayName,
  });

  /// Generate the deep link URL for this user
  String get inviteUrl {
    if (userId != null) {
      return 'https://nock.app/invite/$userId';
    }
    return 'https://nock.app/invite/$username';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 24, vertical: 16),
      decoration: BoxDecoration(
        color: AppColors.surfaceCard,
        borderRadius: BorderRadius.circular(24),
        border: Border.all(
          color: Colors.white.withOpacity(0.05),
          width: 1,
        ),
        boxShadow: [
          BoxShadow(
            color: AppColors.primaryAction.withOpacity(0.1),
            blurRadius: 24,
            spreadRadius: 2,
            offset: const Offset(0, 8),
          ),
        ],
      ),
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Username handle
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              decoration: BoxDecoration(
                gradient: AppColors.primaryGradient,
                borderRadius: BorderRadius.circular(20),
              ),
              child: Text(
                '@$username',
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  letterSpacing: 0.5,
                ),
              ),
            ),
            
            const SizedBox(height: 20),
            
            // Tagline
            const Text(
              'INVITE TO NOCK',
              style: TextStyle(
                color: Colors.white,
                fontSize: 14,
                fontWeight: FontWeight.w600,
                letterSpacing: 2,
              ),
            ),
            
            const SizedBox(height: 4),
            
            // App URL
            Text(
              'nock.app',
              style: TextStyle(
                color: AppColors.textSecondary,
                fontSize: 13,
                fontWeight: FontWeight.w500,
              ),
            ),
            
            const SizedBox(height: 20),
            
            // QR Code
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.white.withOpacity(0.03),
                borderRadius: BorderRadius.circular(16),
                border: Border.all(
                  color: Colors.white.withOpacity(0.05),
                  width: 1,
                ),
              ),
              child: QrImageView(
                data: inviteUrl,
                version: QrVersions.auto,
                size: 180,
                eyeStyle: const QrEyeStyle(
                  eyeShape: QrEyeShape.square,
                  color: Colors.white,
                ),
                dataModuleStyle: const QrDataModuleStyle(
                  dataModuleShape: QrDataModuleShape.square,
                  color: Colors.white,
                ),
                embeddedImage: null,
                embeddedImageStyle: null,
              ),
            ),
            
            const SizedBox(height: 16),
            
            // Scan instruction
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.qr_code_scanner,
                  size: 16,
                  color: AppColors.textTertiary,
                ),
                const SizedBox(width: 6),
                const Text(
                  'Scan to add me on Nock',
                  style: TextStyle(
                    color: AppColors.textTertiary,
                    fontSize: 12,
                    fontWeight: FontWeight.w500,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}



========================================

FILE #68: E:\Vive\android\app\src\main\kotlin\com\nock\nock\BFFWidgetProvider.kt

========================================


package com.nock.nock

import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.widget.RemoteViews
import android.app.PendingIntent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.util.Log
import java.net.URL
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * BFF Widget Provider - 1-tap access to record for a specific friend
 * 
 * Features:
 * - Configurable friend selection (via BFFConfigActivity)
 * - Deep link to recording screen for that friend
 * - Shows friend avatar and streak
 * - Supports Lock Screen placement (Android 15+)
 */
class BFFWidgetProvider : AppWidgetProvider() {
    
    override fun onReceive(context: Context, intent: Intent) {
        super.onReceive(context, intent)
        
        if (intent.action == Intent.ACTION_BOOT_COMPLETED || 
            intent.action == Intent.ACTION_MY_PACKAGE_REPLACED) {
            Log.d(TAG, "Boot/Update received, refreshing BFF widget")
            val appWidgetManager = AppWidgetManager.getInstance(context)
            val appWidgetIds = appWidgetManager.getAppWidgetIds(
                android.content.ComponentName(context, BFFWidgetProvider::class.java)
            )
            for (appWidgetId in appWidgetIds) {
                updateAppWidget(context, appWidgetManager, appWidgetId)
            }
        }
    }
    
    companion object {
        private const val TAG = "BFFWidget"
        private const val PREFS_NAME = "HomeWidgetPrefs" // Standardized for HomeWidget plugin
        
        /**
         * Update a specific widget with friend data
         */
        fun updateWidget(context: Context, appWidgetId: Int) {
            val appWidgetManager = AppWidgetManager.getInstance(context)
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
        
        /**
         * Update all BFF widgets
         */
        fun updateAll(context: Context) {
            val intent = Intent(context, BFFWidgetProvider::class.java).apply {
                action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
            }
            context.sendBroadcast(intent)
        }
        
        private fun updateAppWidget(
            context: Context,
            appWidgetManager: AppWidgetManager,
            appWidgetId: Int
        ) {
            try {
                Log.d(TAG, "updateAppWidget: Starting for widget $appWidgetId")
                
                // ðŸš€ 2026 STANDARD: Use HomeWidgetPlugin to ensure correct SharedPrefs bucket
                val widgetData = es.antonborri.home_widget.HomeWidgetPlugin.getData(context)
                
                // HomeWidget plugin does NOT use the "flutter." prefix by default
                val friendId = widgetData.getString("widget_${appWidgetId}_friendId", null)
                val friendName = widgetData.getString("widget_${appWidgetId}_name", "BFF") ?: "BFF"
                val friendAvatarUrl = widgetData.getString("widget_${appWidgetId}_avatar", null)
                
                Log.d(TAG, "updateAppWidget: friendId=$friendId, friendName=$friendName")
            
                val views = RemoteViews(context.packageName, R.layout.bff_widget_layout)

            // Set friend name with safety truncation for layout stability
            // ðŸ§  Zero State: Guide user if no friend selected
            val displayNameRaw = if (friendId.isNullOrEmpty()) "Tap to Setup" else friendName
            views.setTextViewText(R.id.friend_name, if (displayNameRaw.length > 15) displayNameRaw.take(12) + "..." else displayNameRaw)
            
            // Load avatar from local path (Flutter-Push Architecture)
            // Priority: 1. Global path (avatar_$friendId) 2. Instance path (friendAvatarUrl)
            val globalAvatarPath = if (friendId != null) widgetData.getString("avatar_$friendId", null) else null
            val avatarPath = globalAvatarPath ?: friendAvatarUrl

            if (!avatarPath.isNullOrEmpty()) {
                // CRITICAL FIX: Use setSafeImage (Downsampling + URI method)
                // Avatars are small, so 256px is plenty.
                WidgetUtils.setSafeImage(context, views, R.id.friend_avatar, avatarPath, friendId, 256)
            } else {
                // Ã¢Å“Â¨ Zero State Fix: Show bioluminescent ring even if no friend selected
                // This signals "Potential" rather than an empty/broken feature.
                views.setImageViewResource(R.id.friend_avatar, R.drawable.circle_gradient)
                views.setInt(R.id.friend_avatar, "setAlpha", 180) // Slightly dimmer for background feel
            }
            
            // Deep link intent to recording screen - NOW LAUNCHES MAIN ACTIVITY (API 34 COMPLIANT)
            if (!friendId.isNullOrEmpty()) {
                val recordIntent = Intent(context, MainActivity::class.java).apply {
                    action = Intent.ACTION_VIEW
                    data = Uri.parse("nock:///record/$friendId")
                    addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                }
                
                val pendingIntent = PendingIntent.getActivity(
                    context,
                    appWidgetId,
                    recordIntent,
                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                )
                
                views.setOnClickPendingIntent(R.id.widget_root, pendingIntent)
            } else {
                // No friend configured - open config activity (MainActivity)
                val configIntent = Intent(context, MainActivity::class.java).apply {
                    action = AppWidgetManager.ACTION_APPWIDGET_CONFIGURE
                    putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, appWidgetId)
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
                }
                
                val pendingIntent = PendingIntent.getActivity(
                    context,
                    appWidgetId,
                    configIntent,
                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                )
                
                views.setOnClickPendingIntent(R.id.widget_root, pendingIntent)
            }
            
            appWidgetManager.updateAppWidget(appWidgetId, views)
            Log.d(TAG, "updateAppWidget: Widget updated successfully")
            } catch (e: Exception) {
                Log.e(TAG, "updateAppWidget: ERROR - ${e.message}", e)
            }
        }
    }
    
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        Log.d(TAG, "onUpdate called for ${appWidgetIds.size} widgets")
        for (appWidgetId in appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }
    
    override fun onDeleted(context: Context, appWidgetIds: IntArray) {
        // Clean up preferences when widgets are removed
        val prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val editor = prefs.edit()
        
        for (appWidgetId in appWidgetIds) {
            editor.remove("widget_${appWidgetId}_friendId")
            editor.remove("widget_${appWidgetId}_name")
            editor.remove("widget_${appWidgetId}_avatar")
        }
        
        editor.apply()
        Log.d(TAG, "Cleaned up prefs for deleted widgets")
    }
    
    override fun onEnabled(context: Context) {
        Log.d(TAG, "First BFF widget enabled")
    }
    
    override fun onDisabled(context: Context) {
        Log.d(TAG, "Last BFF widget disabled")
    }
}



========================================

FILE #69: E:\Vive\android\app\src\main\kotlin\com\nock\nock\MainActivity.kt

========================================


package com.nock.nock

import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import androidx.core.content.FileProvider
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import androidx.lifecycle.lifecycleScope
import kotlinx.coroutines.launch
import java.io.File

class MainActivity : FlutterActivity() {
    private val DEEPLINK_CHANNEL = "com.nock.nock/deeplink"
    private val SHARE_CHANNEL = "com.nock.nock/share"
    private val WIDGET_CHANNEL = "com.nock.nock/widget"
    private val AUDIO_CHANNEL = "com.nock.nock/audio_control"
    
    private var pendingWidgetId: Int = android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID
    
    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        
        // Handle initial deep link if app was launched via deep link
        handleDeepLink(intent)

        // Setup audio control channel to stop background service
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, AUDIO_CHANNEL).setMethodCallHandler { call, result ->
            if (call.method == "stopNockAudioService") {
                val stopIntent = Intent(this, NockAudioService::class.java)
                stopService(stopIntent)
                result.success(true)
            } else {
                result.notImplemented()
            }
        }
        
        // Setup share channel for social media sharing
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, SHARE_CHANNEL).setMethodCallHandler { call, result ->
            when (call.method) {
                // Instagram share
                "shareToInstagram" -> {
                    val imagePath = call.argument<String>("imagePath")
                    if (imagePath != null) {
                        val success = shareToApp(imagePath, "com.instagram.android")
                        result.success(success)
                    } else {
                        result.error("INVALID_ARGUMENT", "imagePath is required", null)
                    }
                }
                "isInstagramInstalled" -> {
                    result.success(isAppInstalled("com.instagram.android"))
                }
                
                // TikTok share
                "shareToTikTok" -> {
                    val imagePath = call.argument<String>("imagePath")
                    if (imagePath != null) {
                        val success = shareToApp(imagePath, "com.zhiliaoapp.musically")
                        result.success(success)
                    } else {
                        result.error("INVALID_ARGUMENT", "imagePath is required", null)
                    }
                }
                "isTikTokInstalled" -> {
                    result.success(isAppInstalled("com.zhiliaoapp.musically"))
                }
                
                else -> {
                    result.notImplemented()
                }
            }
        }

        // Setup widget channel for configuration finish
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, WIDGET_CHANNEL).setMethodCallHandler { call, result ->
            if (call.method == "finishConfig") {
                val widgetId = call.argument<Int>("appWidgetId") ?: android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID
                if (widgetId != android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID) {
                    val resultValue = Intent().apply {
                        putExtra(android.appwidget.AppWidgetManager.EXTRA_APPWIDGET_ID, widgetId)
                    }
                    setResult(RESULT_OK, resultValue)
                    finish()
                }
                result.success(null)
            } else {
                result.notImplemented()
            }
        }

        // ==================== BACKGROUND UPLOAD CHANNEL ====================
        val BACKGROUND_UPLOAD_CHANNEL = "com.nock.nock/background_upload"
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, BACKGROUND_UPLOAD_CHANNEL).setMethodCallHandler { call, result ->
            when (call.method) {
                "startBackgroundTask" -> {
                    val title = call.argument<String>("title") ?: "Uploading"
                    val subtitle = call.argument<String>("subtitle") ?: "Please wait..."
                    
                    val workRequest = androidx.work.OneTimeWorkRequestBuilder<VibeUploadWorker>()
                        .setExpedited(androidx.work.OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                        .setInputData(androidx.work.workDataOf(
                            "title" to title,
                            "subtitle" to subtitle
                        ))
                        .build()
                    
                    androidx.work.WorkManager.getInstance(this).enqueue(workRequest)
                    result.success(workRequest.id.toString())
                }
                "updateTaskProgress" -> {
                    val taskId = call.argument<String>("taskId")
                    val fraction = call.argument<Double>("fraction") ?: 0.0
                    if (taskId != null) {
                        // ðŸ›¡ï¸ 2026 GOLD STANDARD: Reactive progress updates to native worker
                        val progressInt = (fraction * 100).toInt()
                        (this as? androidx.lifecycle.LifecycleOwner)?.lifecycleScope?.launch {
                            VibeUploadWorker.progressFlow.emit(taskId to progressInt)
                        }
                    }
                    result.success(true)
                }
                "stopBackgroundTask" -> {
                    val taskId = call.argument<String>("taskId")
                    if (taskId != null) {
                        VibeUploadWorker.stopTask(taskId)
                        androidx.work.WorkManager.getInstance(this).cancelWorkById(java.util.UUID.fromString(taskId))
                    }
                    result.success(true)
                }
                else -> result.notImplemented()
            }
        }
    }
    
    /**
     * Share image directly to a specific app using explicit intent
     * This bypasses the system share sheet and opens the target app directly
     * Works for Instagram, TikTok, WhatsApp, etc.
     */
    private fun shareToApp(imagePath: String, packageName: String): Boolean {
        return try {
            val file = File(imagePath)
            if (!file.exists()) {
                android.util.Log.e("MainActivity", "Image file does not exist: $imagePath")
                return false
            }
            
            // Check if target app is installed
            if (!isAppInstalled(packageName)) {
                android.util.Log.e("MainActivity", "App not installed: $packageName")
                return false
            }
            
            // Get content URI using FileProvider
            val contentUri: Uri = FileProvider.getUriForFile(
                this,
                "com.nock.nock.provider",
                file
            )
            
            // Create explicit intent for the target app
            val intent = Intent(Intent.ACTION_SEND).apply {
                type = "image/*"
                putExtra(Intent.EXTRA_STREAM, contentUri)
                // CRITICAL: Set package to bypass system share sheet and open app directly
                setPackage(packageName)
                addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
            }
            
            // Start the target app directly
            startActivity(intent)
            true
        } catch (e: Exception) {
            android.util.Log.e("MainActivity", "Failed to share to $packageName: ${e.message}")
            false
        }
    }
    
    /**
     * Check if an app is installed on the device
     */
    private fun isAppInstalled(packageName: String): Boolean {
        return try {
            packageManager.getPackageInfo(packageName, PackageManager.GET_ACTIVITIES)
            true
        } catch (e: PackageManager.NameNotFoundException) {
            false
        }
    }
    
    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        setIntent(intent)
        // Handle deep link when app is already running
        handleDeepLink(intent)
    }
    
    private fun handleDeepLink(intent: Intent?) {
        val action = intent?.action
        val data = intent?.data
        
        // Handle Widget Configuration
        if (action == android.appwidget.AppWidgetManager.ACTION_APPWIDGET_CONFIGURE) {
            pendingWidgetId = intent.getIntExtra(
                android.appwidget.AppWidgetManager.EXTRA_APPWIDGET_ID,
                android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID
            )
            
            if (pendingWidgetId != android.appwidget.AppWidgetManager.INVALID_APPWIDGET_ID) {
                android.util.Log.d("MainActivity", "Configuring widget: $pendingWidgetId")
                // We'll let Flutter handle the routing via the initial route or deep link
                // The intent data might need to be set so GoRouter picks it up
                intent.data = Uri.parse("nock://widget-config/$pendingWidgetId")
            }
        }

        if (action == Intent.ACTION_VIEW || action == "com.nock.nock.OPEN_NOCK") {
            if (data != null) {
                android.util.Log.d("MainActivity", "Deep link/Action received: $action, data: $data")
            }
        }
    }
}



========================================

FILE #70: E:\Vive\android\app\src\main\kotlin\com\nock\nock\NockAudioService.kt

========================================


package com.nock.nock

import android.app.Activity
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.app.Service
import android.content.Context
import android.content.Intent
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.os.Build
import android.os.IBinder
import android.os.Environment
import android.os.Handler
import android.os.Looper
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import android.support.v4.media.session.MediaSessionCompat
import androidx.media.app.NotificationCompat.MediaStyle
import android.media.AudioManager
import android.media.AudioFocusRequest
import androidx.core.app.NotificationCompat

/**
 * NockAudioService - Background Foreground Service for Widget Audio Playback
 * 
 * This service enables the "Invisible App" experience where tapping the widget
 * plays audio instantly on the home screen without opening the app.
 * 
 * Key Features:
 * - Plays audio in the background via MediaPlayer
 * - Shows a MediaStyle notification (required by Android for foreground services)
 * - Auto-kills itself when audio finishes to save battery
 * - Handles errors gracefully
 */
class NockAudioService : Service() {

    private var mediaPlayer: MediaPlayer? = null
    private var mediaSession: MediaSessionCompat? = null
    
    private lateinit var audioManager: AudioManager
    private var focusRequest: AudioFocusRequest? = null
    
    // Track current foreground service type to allow atomic transitions (API 34)
    private var currentServiceType: Int = 0
    
    private val focusChangeListener = AudioManager.OnAudioFocusChangeListener { focusChange ->
        when (focusChange) {
            AudioManager.AUDIOFOCUS_GAIN -> {
                mediaPlayer?.setVolume(1.0f, 1.0f)
                if (mediaPlayer?.isPlaying == false) mediaPlayer?.start()
            }
            AudioManager.AUDIOFOCUS_LOSS,
            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT -> {
                // The Camera (or another app) is taking the mic/speaker.
                // 1. Release hardware locks and pause
                stopPlayback()

                
                // 2. Downgrade/Stop service to release OS-level hardware handles
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    startForeground(NOTIFICATION_ID, createNotification("Nock", "Ready", null), 
                        android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK)
                }
            }
            AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK -> mediaPlayer?.setVolume(0.2f, 0.2f)
        }
    }

    companion object {
        const val ACTION_PLAY = "com.nock.nock.ACTION_PLAY"
        const val ACTION_STOP = "com.nock.nock.ACTION_STOP"
        const val EXTRA_AUDIO_URL = "audio_url"
        const val EXTRA_SENDER_NAME = "sender_name"
        const val EXTRA_NOCK_ID = "nock_id"
        const val EXTRA_RECEIVER_ID = "receiver_id"
        const val CHANNEL_ID = "nock_playback_channel"
        const val NOTIFICATION_ID = 101
    }

    override fun onBind(intent: Intent?): IBinder? = null

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
        audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
        mediaSession = MediaSessionCompat(this, "NockAudioService").apply {
            isActive = true
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val resultReceiver = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            intent?.getParcelableExtra("completer", android.os.ResultReceiver::class.java)
        } else {
            @Suppress("DEPRECATION")
            intent?.getParcelableExtra("completer")
        }

        try {
            when (intent?.action) {
                ACTION_PLAY -> {
                    val audioUrl = intent.getStringExtra(EXTRA_AUDIO_URL)
                    val senderName = intent.getStringExtra(EXTRA_SENDER_NAME) ?: "Friend"
                    val nockId = intent.getStringExtra(EXTRA_NOCK_ID)

                    // ðŸ›¡ï¸ 2026 STABILITY FIX: Always call startForeground high up
                    // Android OS kills the process if startForeground() isn't called within ~5s
                    // even if we intended to stop immediately.
                    val notification = createNotification(
                        if (audioUrl.isNullOrEmpty()) "Nock Idle" else "Playing Nock",
                        if (audioUrl.isNullOrEmpty()) "Ready" else "From $senderName",
                        nockId
                    )
                    
                    if (Build.VERSION.SDK_INT >= 34) {
                        startForeground(NOTIFICATION_ID, notification, 
                            android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MEDIA_PLAYBACK)
                    } else {
                        startForeground(NOTIFICATION_ID, notification)
                    }

                    if (audioUrl != null && audioUrl.isNotEmpty()) {
                        playAudio(audioUrl)
                    } else {
                        android.util.Log.d("NockAudioService", "Empty audio URL, stopping immediately.")
                        stopSelf()
                    }
                }
                ACTION_STOP -> {
                    stopPlayback()
                    stopForeground(STOP_FOREGROUND_REMOVE)
                    stopSelf()
                }

            }
            
            // Signal trampoline activity that the service reached foreground state
            resultReceiver?.send(Activity.RESULT_OK, null)

        } catch (e: Exception) {
            android.util.Log.e("NockAudioService", "Error in onStartCommand: ${e.message}")
            // Even on error, release the trampoline activity
            resultReceiver?.send(Activity.RESULT_CANCELED, null)
            
            // Stop service if we failed to reach foreground state effectively
            if (intent?.action != ACTION_STOP) {
                stopSelf()
            }
        }
        return START_NOT_STICKY
    }

    private fun playAudio(url: String) {
        // Stop previous playback if any
        stopPlayback()

        // Request Audio Focus
        val result = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val playbackAttributes = AudioAttributes.Builder()
                .setUsage(AudioAttributes.USAGE_MEDIA)
                .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                .build()
            focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK)
                .setAudioAttributes(playbackAttributes)
                .setAcceptsDelayedFocusGain(true)
                .setOnAudioFocusChangeListener(focusChangeListener)
                .build()
            audioManager.requestAudioFocus(focusRequest!!)
        } else {
            @Suppress("DEPRECATION")
            audioManager.requestAudioFocus(
                focusChangeListener,
                AudioManager.STREAM_MUSIC,
                AudioManager.AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK
            )
        }

        if (result != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
            stopSelf()
            return
        }

        try {
            mediaPlayer = MediaPlayer().apply {
                setAudioAttributes(
                    AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                        .setUsage(AudioAttributes.USAGE_MEDIA)
                        .build()
                )
                setDataSource(url)
                prepareAsync()
                
                setOnPreparedListener {
                    it.start()
                }
                
                setOnCompletionListener {
                    stopPlayback()
                    stopForeground(STOP_FOREGROUND_REMOVE)
                    stopSelf()
                }
                
                setOnErrorListener { _, what, extra ->
                    android.util.Log.e("NockAudioService", "MediaPlayer error: $what")
                    stopPlayback()
                    stopForeground(STOP_FOREGROUND_REMOVE)
                    stopSelf()
                    true
                }
            }
        } catch (e: Exception) {
            android.util.Log.e("NockAudioService", "Error playing audio", e)
            stopPlayback()
            stopSelf()
        }
    }

    private fun stopPlayback() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            focusRequest?.let { audioManager.abandonAudioFocusRequest(it) }
        } else {
            @Suppress("DEPRECATION")
            audioManager.abandonAudioFocus(focusChangeListener)
        }

        mediaPlayer?.let {
            if (it.isPlaying) {
                it.stop()
            }
            it.release()
        }
        mediaPlayer = null
    }

    private fun createNotification(title: String, text: String, nockId: String?): Notification {
        // Create intent to open app when notification is tapped
        val launchIntent = packageManager.getLaunchIntentForPackage(packageName)?.apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            if (nockId != null) {
                putExtra("nockId", nockId)
                putExtra("route", "/player")
            }
        }
        
        val pendingIntent = PendingIntent.getActivity(
            this,
            0,
            launchIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
 
        // Create stop action
        val stopIntent = Intent(this, NockAudioService::class.java).apply {
            action = ACTION_STOP
        }
        val stopPendingIntent = PendingIntent.getService(
            this,
            1,
            stopIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )

        val builder = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(text)
            .setSmallIcon(R.drawable.ic_notification)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOngoing(true)
            .setContentIntent(pendingIntent)
            .addAction(
                NotificationCompat.Action(
                    android.R.drawable.ic_media_pause,
                    "Stop",
                    stopPendingIntent
                )
            )
            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)

        // Ã¢Å“Â¨ BIOLUMINESCENT HUD: Tint notification based on state
        // Bio-Lime for Playback, Digital Lavender for Idle
        val intentAction = (if (mediaPlayer != null) ACTION_PLAY else "IDLE")
        val tintColor = when (intentAction) {
            ACTION_PLAY -> 0xFFD4F49C.toInt()   // bioLime
            else -> 0xFFE5D1FA.toInt()          // digitalLavender
        }
        builder.setColor(tintColor)
        // Ensure the icon/background follows the brand color
        builder.setSubText("Nocking")

        // Apply MediaStyle
        mediaSession?.let {
            builder.setStyle(
                MediaStyle()
                    .setMediaSession(it.sessionToken)
                    .setShowActionsInCompactView(0)
            )
        }

        return builder.build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Nock Playback",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Shows when a Nock is playing"
                setShowBadge(false)
            }
            val manager = getSystemService(NotificationManager::class.java)
            manager.createNotificationChannel(channel)
        }
    }

    override fun onDestroy() {
        try {
            stopPlayback()

        } catch (e: Exception) {
            android.util.Log.e("NockAudioService", "Error in onDestroy cleanup: ${e.message}")
        }
        super.onDestroy()
    }
}



========================================

FILE #71: E:\Vive\android\app\src\main\kotlin\com\nock\nock\NockWidgetProvider.kt

========================================


package com.nock.nock

import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.content.SharedPreferences
import android.widget.RemoteViews
import android.app.PendingIntent
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Build
import android.util.Log
import es.antonborri.home_widget.HomeWidgetPlugin
import java.io.File
import java.net.URL
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Nock Widget Provider
 * 
 * Displays the latest received nock (photo + voice) on the home screen.
 * Tapping the widget opens the app to the player screen.
 */
class NockWidgetProvider : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        for (appWidgetId in appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }

    override fun onReceive(context: Context, intent: Intent) {
        super.onReceive(context, intent)
        
        // Handle custom actions
        when (intent.action) {
            Intent.ACTION_BOOT_COMPLETED, Intent.ACTION_MY_PACKAGE_REPLACED -> {
                android.util.Log.d("NockWidget", "Boot/Update received, refreshing widget")
                val appWidgetManager = AppWidgetManager.getInstance(context)
                val componentName = android.content.ComponentName(context, NockWidgetProvider::class.java)
                val appWidgetIds = appWidgetManager.getAppWidgetIds(componentName)
                for (appWidgetId in appWidgetIds) {
                    updateAppWidget(context, appWidgetManager, appWidgetId)
                }
            }
            ACTION_PLAY_AUDIO -> {
                // REMOVED: Receiver-based start is deprecated due to BAL restrictions in Android 14.
                // We now launch TrampolineActivity directly via PendingIntent.getActivity()
            }
            
            // Heart button tap - Send nudge (102 requests for quick interactions)
            ACTION_SEND_NUDGE -> {
                // REMOVED: Receiver-based start is deprecated. 
                // PendingIntent.getActivity() now launches MainActivity directly.
            }
        }
    }

    companion object {
        const val ACTION_PLAY_AUDIO = "com.nock.nock.ACTION_PLAY_AUDIO"
        const val ACTION_SEND_NUDGE = "com.nock.nock.ACTION_SEND_NUDGE"
        const val EXTRA_AUDIO_URL = "audio_url"
        const val EXTRA_NOCK_ID = "nock_id"
        const val EXTRA_RECEIVER_ID = "receiver_id"
        
        private const val PREFS_NAME = "HomeWidgetPrefs"

        internal fun updateAppWidget(
            context: Context,
            appWidgetManager: AppWidgetManager,
            appWidgetId: Int
        ) {
            try {
                android.util.Log.d("NockWidget", "updateAppWidget: Starting for widget $appWidgetId")
                val views = RemoteViews(context.packageName, R.layout.nock_widget_layout)
                
                // âš¡ OPTIMISTIC RENDERING: Get existing data IMMEDIATELY to avoid "Loading..." flash
                val widgetData = HomeWidgetPlugin.getData(context)
                
                // ðŸ” DIAGNOSTIC LOG: List all keys to see if they have prefixes or wrong names
                val allKeys = widgetData.all.keys
                android.util.Log.d("NockWidget", "DEBUG: All SharedPrefs keys: ${allKeys.joinToString(", ")}")
                
                var senderName = widgetData.getString("senderName", null)
                var senderId = widgetData.getString("senderId", null)
                var nockId = widgetData.getString("vibeId", null) ?: widgetData.getString("nockId", null)
                var imageUrl = widgetData.getString("imageUrl", null)
                var isPlayed = widgetData.getBoolean("isPlayed", true)
                var timestamp = widgetData.getLong("timestamp", 0L)
                var transcription = widgetData.getString("transcription", null) ?: widgetData.getString("transcriptionPreview", null)

                // ðŸ”„ RESILIENCY FALLBACK: If individual keys are missing, try to extract from Squad JSON
                // This ensures Nock/Hero widget stays in sync with the Squad grid source of truth.
                if (senderName == null || nockId == null) {
                    try {
                        val vibesJson = widgetData.getString("recent_vibes", null)
                        if (!vibesJson.isNullOrEmpty()) {
                            val array = org.json.JSONArray(vibesJson)
                            if (array.length() > 0) {
                                val hero = array.getJSONObject(0)
                                senderName = hero.optString("senderName", null)
                                nockId = hero.optString("vibeId", null)
                                senderId = hero.optString("senderId", null)
                                imageUrl = hero.optString("imageUrl", null)
                                isPlayed = hero.optBoolean("isPlayed", false)
                                timestamp = hero.optLong("timestamp", 0L)
                                transcription = hero.optString("transcription", null)
                                android.util.Log.d("NockWidget", "Fallback Success: Extracted hero $nockId from JSON")
                            }
                        }
                    } catch (e: Exception) {
                        android.util.Log.e("NockWidget", "Fallback failed: ${e.message}")
                    }
                }

                android.util.Log.d("NockWidget", "updateAppWidget: Final Data - senderName=$senderName, vibeId=$nockId")

                if (senderName != null && nockId != null) {
                    // Populate view
                    val displayName = if (senderName.length > 15) senderName.take(12) + "..." else senderName
                    views.setTextViewText(R.id.sender_name, displayName)
                    
                    val infoText = if (timestamp > 0) {
                        formatTimeAgo(timestamp)
                    } else if (!transcription.isNullOrEmpty()) {
                        "\"$transcription\""
                    } else {
                        ""
                    }
                    // views.setTextViewText(R.id.time_text, infoText) // If you have a time text field
                    
                    views.setViewVisibility(R.id.status_indicator, if (!isPlayed) android.view.View.VISIBLE else android.view.View.GONE)
                    views.setViewVisibility(R.id.play_button, android.view.View.VISIBLE)
                    
                    // Set up click intent - Opens app player
                    val openIntent = Intent(context, MainActivity::class.java).apply {
                        action = Intent.ACTION_VIEW
                        data = Uri.parse("nock:///player/$nockId")
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    }
                    val openPi = PendingIntent.getActivity(context, appWidgetId, openIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
                    views.setOnClickPendingIntent(R.id.widget_image, openPi)

                    // Play button
                    val playIntent = Intent(context, TrampolineActivity::class.java).apply {
                        action = "com.nock.nock.ACTION_PLAY"
                        putExtra("audio_url", widgetData.getString("audioUrl", ""))
                        putExtra("sender_name", senderName)
                        putExtra("nock_id", nockId)
                    }
                    val playPi = PendingIntent.getActivity(context, appWidgetId + 200, playIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
                    views.setOnClickPendingIntent(R.id.play_button, playPi)

                    // Load image
                    if (!imageUrl.isNullOrEmpty()) {
                        loadImageAsync(context, imageUrl, views, appWidgetManager, appWidgetId, nockId)
                    }
                } else {
                    // Fallback for new widgets
                    views.setTextViewText(R.id.sender_name, "Nock")
                    views.setViewVisibility(R.id.play_button, android.view.View.GONE)
                    views.setViewVisibility(R.id.status_indicator, android.view.View.GONE)
                    
                    val openIntent = context.packageManager.getLaunchIntentForPackage(context.packageName)
                    val openPi = PendingIntent.getActivity(context, appWidgetId, openIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)
                    views.setOnClickPendingIntent(R.id.widget_image, openPi)
                }
                
                appWidgetManager.updateAppWidget(appWidgetId, views)
                android.util.Log.d("NockWidget", "updateAppWidget: Widget updated successfully")
            } catch (e: Exception) {
                android.util.Log.e("NockWidget", "updateAppWidget: ERROR - ${e.message}", e)
            }
        }
        
        private fun loadImageAsync(
            context: Context,
            imageUrl: String,
            views: RemoteViews,
            appWidgetManager: AppWidgetManager,
            appWidgetId: Int,
            nockId: String? = null
        ) {
            // ðŸ§  ANTI-FLICKER OPTIMIZATION: Move heavy I/O and decoding to background.
            // This prevents "hitch" during home screen page swipes.
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    // 1. Perform decoding and URI generation in background
                    WidgetUtils.setSafeImage(context, views, R.id.widget_image, imageUrl, nockId)
                    
                    // 2. Update widget once decoding is done
                    withContext(Dispatchers.Main) {
                        appWidgetManager.updateAppWidget(appWidgetId, views)
                        android.util.Log.d("NockWidget", "Async image update complete for $appWidgetId")
                    }
                } catch (e: Exception) {
                    android.util.Log.e("NockWidget", "Background image load failed: ${e.message}")
                }
            }
        }

        /**
         * Format timestamp to human-readable relative time (e.g., "2m ago", "1h ago", "3d ago")
         * Follows Dual Coding Theory - adds unique value instead of redundant content type info
         */
        private fun formatTimeAgo(timestampMs: Long): String {
            val now = System.currentTimeMillis()
            val diffMs = now - timestampMs
            
            val seconds = diffMs / 1000
            val minutes = seconds / 60
            val hours = minutes / 60
            val days = hours / 24
            val weeks = days / 7
            
            return when {
                seconds < 60 -> "now"
                minutes < 60 -> "${minutes}m ago"
                hours < 24 -> "${hours}h ago"
                days < 7 -> "${days}d ago"
                else -> "${weeks}w ago"
            }
        }
    }
}



========================================

FILE #72: E:\Vive\android\app\src\main\kotlin\com\nock\nock\SquadWidgetProvider.kt

========================================


package com.nock.nock

import android.appwidget.AppWidgetManager
import android.appwidget.AppWidgetProvider
import android.content.Context
import android.content.Intent
import android.widget.RemoteViews
import android.app.PendingIntent
import android.graphics.BitmapFactory
import android.net.Uri
import android.util.Log
import android.view.View
import org.json.JSONArray
import java.net.URL
import java.util.concurrent.TimeUnit
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Squad Widget Provider - Shows latest 3 vibes in a horizontal grid
 * 
 * Features:
 * - Displays 3 most recent vibes
 * - Shows sender avatar/image, name, and time
 * - Unread indicators
 * - Deep links to PlayerScreen for each vibe
 * - Auto-refreshes every 30 minutes
 */
class SquadWidgetProvider : AppWidgetProvider() {
    
    override fun onReceive(context: Context, intent: Intent) {
        super.onReceive(context, intent)
        
        if (intent.action == Intent.ACTION_BOOT_COMPLETED || 
            intent.action == Intent.ACTION_MY_PACKAGE_REPLACED) {
            Log.d(TAG, "Boot/Update received, refreshing Squad widget")
            val appWidgetManager = AppWidgetManager.getInstance(context)
            val appWidgetIds = appWidgetManager.getAppWidgetIds(
                android.content.ComponentName(context, SquadWidgetProvider::class.java)
            )
            for (appWidgetId in appWidgetIds) {
                updateAppWidget(context, appWidgetManager, appWidgetId)
            }
        }
    }
    
    companion object {
        private const val TAG = "SquadWidget"
        
        /**
         * Update all Squad widgets
         */
        fun updateAll(context: Context) {
            val intent = Intent(context, SquadWidgetProvider::class.java).apply {
                action = AppWidgetManager.ACTION_APPWIDGET_UPDATE
            }
            context.sendBroadcast(intent)
        }
        
        private fun updateAppWidget(
            context: Context,
            appWidgetManager: AppWidgetManager,
            appWidgetId: Int
        ) {
            // ðŸ§  ANTI-FLICKER OPTIMIZATION: Squad widget decodes 3 images.
            // Move entire update cycle to background to prevent UI lag.
            CoroutineScope(Dispatchers.IO).launch {
                try {
                    Log.d(TAG, "updateAppWidget: Starting background update for $appWidgetId")
                    val views = RemoteViews(context.packageName, R.layout.squad_widget_layout)
                    
                    val vibes = loadVibes(context)
                    Log.d(TAG, "updateAppWidget: Loaded ${vibes.size} vibes")
                    
                    // These lookups and decodings now happen in the background!
                    updateVibeSlot(context, views, vibes.getOrNull(0), 1, appWidgetId)
                    updateVibeSlot(context, views, vibes.getOrNull(1), 2, appWidgetId)
                    updateVibeSlot(context, views, vibes.getOrNull(2), 3, appWidgetId)

                    // ZERO STATE HANDLING
                    if (vibes.isEmpty()) {
                        views.setViewVisibility(R.id.content_container, View.GONE)
                        views.setViewVisibility(R.id.empty_state_container, View.VISIBLE)
                        
                        val openIntent = Intent(context, MainActivity::class.java).apply {
                            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
                        }
                        val pendingIntent = PendingIntent.getActivity(
                            context, appWidgetId, openIntent, 
                            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
                        )
                        views.setOnClickPendingIntent(R.id.empty_state_container, pendingIntent)
                    } else {
                        views.setViewVisibility(R.id.content_container, View.VISIBLE)
                        views.setViewVisibility(R.id.empty_state_container, View.GONE)
                    }
                    
                    // ðŸš€ Final render on the Main thread
                    withContext(Dispatchers.Main) {
                        appWidgetManager.updateAppWidget(appWidgetId, views)
                        Log.d(TAG, "updateAppWidget: Widget updated successfully on MAIN thread")
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "updateAppWidget: Async update failed: ${e.message}", e)
                }
            }
        }
        
        private fun loadVibes(context: Context): List<VibeData> {
            try {
                // ðŸš€ 2026 STANDARD: Use HomeWidgetPlugin to ensure correct SharedPrefs bucket
                val widgetData = es.antonborri.home_widget.HomeWidgetPlugin.getData(context)
                val vibesJson = widgetData.getString("recent_vibes", null)
                
                Log.d(TAG, "loadVibes: Data string found: ${vibesJson?.take(100)}...")
                
                if (vibesJson.isNullOrEmpty()) {
                    Log.w(TAG, "loadVibes: recent_vibes key is NULL or empty")
                    return emptyList()
                }
                
                val array = JSONArray(vibesJson)
                Log.d(TAG, "loadVibes: Found ${array.length()} vibes in JSON")
                
                return (0 until minOf(array.length(), 3)).map { i ->
                    val obj = array.getJSONObject(i)
                    VibeData(
                        vibeId = obj.getString("vibeId"),
                        senderName = obj.getString("senderName"),
                        imageUrl = obj.optString("imageUrl", null),
                        isPlayed = obj.optBoolean("isPlayed", false),
                        timestamp = obj.optLong("timestamp", System.currentTimeMillis()),
                        transcription = obj.optString("transcription", "")
                    )
                }
            } catch (e: Exception) {
                Log.e(TAG, "loadVibes: CRITICAL FAILURE: ${e.message}")
                e.printStackTrace()
                return emptyList()
            }
        }
        
        private fun updateVibeSlot(
            context: Context,
            views: RemoteViews,
            vibe: VibeData?,
            slotNumber: Int,
            appWidgetId: Int
        ) {
            val containerId = when (slotNumber) {
                1 -> R.id.vibe_1_container
                2 -> R.id.vibe_2_container
                3 -> R.id.vibe_3_container
                else -> return
            }
            
            val imageId = when (slotNumber) {
                1 -> R.id.vibe_1_image
                2 -> R.id.vibe_2_image
                3 -> R.id.vibe_3_image
                else -> return
            }
            
            val nameId = when (slotNumber) {
                1 -> R.id.vibe_1_name
                2 -> R.id.vibe_2_name
                3 -> R.id.vibe_3_name
                else -> return
            }
            
            val timeId = when (slotNumber) {
                1 -> R.id.vibe_1_time
                else -> 0
            }
            
            // TRANSCRIPTION: Only valid for Hero Slot (1)
            val transcriptionId = when (slotNumber) {
                1 -> R.id.vibe_transcription
                else -> 0
            }
            
            val unreadId = when (slotNumber) {
                1 -> R.id.vibe_1_unread
                2 -> R.id.vibe_2_unread
                3 -> R.id.vibe_3_unread
                else -> return
            }
            
            if (vibe == null) {
                views.setViewVisibility(containerId, View.GONE)
                return
            }
            
            views.setViewVisibility(containerId, View.VISIBLE)
            val displayName = if (vibe.senderName.length > 15) vibe.senderName.take(12) + "..." else vibe.senderName
            views.setTextViewText(nameId, displayName)
            if (timeId != 0) {
                views.setTextViewText(timeId, formatTimeAgo(vibe.timestamp))
            }
            
            // BIND TRANSCRIPTION (If exists and is slot 1)
            if (transcriptionId != 0) {
                if (!vibe.transcription.isNullOrEmpty()) {
                    views.setTextViewText(transcriptionId, "\"" + vibe.transcription + "\"")
                    views.setViewVisibility(transcriptionId, View.VISIBLE)
                } else {
                    views.setViewVisibility(transcriptionId, View.GONE)
                }
            }
            
            // Unread indicator
            views.setViewVisibility(unreadId, if (vibe.isPlayed) View.GONE else View.VISIBLE)
            
            // Load image from local path (Flutter-Push Architecture)
            if (!vibe.imageUrl.isNullOrEmpty()) {
                // CRITICAL FIX: Use setSafeImage (Downsampling + URI method)
                // We have 3 slots, so URI method is mandatory to stay under 1MB Binder limit.
                WidgetUtils.setSafeImage(context, views, imageId, vibe.imageUrl, vibe.vibeId, 300)
            }
            
            // Deep link to player
            val playerIntent = Intent(context, MainActivity::class.java).apply {
                action = Intent.ACTION_VIEW
                data = Uri.parse("nock:///player/${vibe.vibeId}")
                flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP
            }
            
            val pendingIntent = PendingIntent.getActivity(
                context,
                appWidgetId * 10 + slotNumber,
                playerIntent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            
            views.setOnClickPendingIntent(containerId, pendingIntent)
        }
        
        private fun formatTimeAgo(timestamp: Long): String {
            val now = System.currentTimeMillis()
            val diff = now - timestamp
            
            return when {
                diff < TimeUnit.MINUTES.toMillis(1) -> "now"
                diff < TimeUnit.HOURS.toMillis(1) -> "${TimeUnit.MILLISECONDS.toMinutes(diff)}m"
                diff < TimeUnit.DAYS.toMillis(1) -> "${TimeUnit.MILLISECONDS.toHours(diff)}h"
                else -> "${TimeUnit.MILLISECONDS.toDays(diff)}d"
            }
        }
    }
    
    data class VibeData(
        val vibeId: String,
        val senderName: String,
        val imageUrl: String?,
        val isPlayed: Boolean,
        val timestamp: Long,
        val transcription: String?
    )
    
    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        Log.d(TAG, "onUpdate called for ${appWidgetIds.size} widgets")
        for (appWidgetId in appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }
    
    override fun onEnabled(context: Context) {
        Log.d(TAG, "First Squad widget enabled")
    }
    
    override fun onDisabled(context: Context) {
        Log.d(TAG, "Last Squad widget disabled")
    }
}



========================================

FILE #73: E:\Vive\android\app\src\main\kotlin\com\nock\nock\TrampolineActivity.kt

========================================


package com.nock.nock

import android.app.Activity
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.Bundle
import android.os.VibrationEffect
import android.os.Vibrator
import android.util.Log
import androidx.core.content.ContextCompat

class TrampolineActivity : Activity() {
    
    companion object {
        private const val TAG = "TrampolineActivity"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        Log.d(TAG, "TrampolineActivity created. Intent: ${intent?.action}")

        // --- START FIX: IMMEDIATE HAPTIC FEEDBACK ---
        try {
            val vibrator = getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
            if (vibrator.hasVibrator()) {
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    vibrator.vibrate(VibrationEffect.createOneShot(50, VibrationEffect.DEFAULT_AMPLITUDE))
                } else {
                    vibrator.vibrate(50)
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Vibration failed: ${e.message}")
        }
        
        // --- HANDSHAKE MECHANISM FOR ANDROID 14 ---
        // We must NOT finish the activity until the Service has successfully called
        // startForeground(). If we finish early, the system might transition the app
        // to "Background" state and throw a SecurityException for microphone usage.
        
        val handler = android.os.Handler(android.os.Looper.getMainLooper())
        
        // Safety timeout: If service never calls back, don't leave this activity orphaned forever
        val timeoutRunnable = Runnable {
            Log.w(TAG, "Handshake timeout! Finishing trampoline to avoid orphaning.")
            finish()
        }

        val finisher = object : android.os.ResultReceiver(handler) {
            override fun onReceiveResult(resultCode: Int, resultData: Bundle?) {
                Log.d(TAG, "Service handshake received (result: $resultCode). Finishing trampoline.")
                handler.removeCallbacks(timeoutRunnable)
                finish()
            }
        }

        // Forward the intent to NockAudioService
        intent?.let { originalIntent ->
            // --- START FIX: ANDROID 13+ "ZOMBIE" AUDIO MITIGATION ---
            // If we don't have notification permissions on Android 13+, 
            // the foreground service notification will be SUPPRESSED.
            // This leaves the user with "Zombie Audio": playing but un-stoppable.
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                val permission = android.Manifest.permission.POST_NOTIFICATIONS
                if (androidx.core.content.ContextCompat.checkSelfPermission(this, permission) != 
                    android.content.pm.PackageManager.PERMISSION_GRANTED) {
                    
                    Log.w(TAG, "Notification permission missing! Redirecting to MainActivity to avoid Zombie Audio.")
                    
                    // Fallback: Open the main app so the user has the full player UI and controls.
                    val mainIntent = Intent(this, MainActivity::class.java).apply {
                        action = originalIntent.action
                        originalIntent.extras?.let { putExtras(it) }
                        data = originalIntent.data
                        addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP)
                    }
                    startActivity(mainIntent)
                    finish()
                    return
                }
            }
            // --- END ZOMBIE AUDIO FIX ---

            val serviceIntent = Intent(this, NockAudioService::class.java).apply {
                action = originalIntent.action
                originalIntent.extras?.let { putExtras(it) }
                data = originalIntent.data
                putExtra("completer", finisher)
            }
            
            try {
                ContextCompat.startForegroundService(this, serviceIntent)
                Log.d(TAG, "Service started, waiting for handshake...")
                
                // Start the safety timer (10 seconds is a safe watchdog for slow cold starts)
                // This only fires if the Handshake fails or the service crashes.
                handler.postDelayed(timeoutRunnable, 10000)
                
            } catch (e: Exception) {
                Log.e(TAG, "Failed to start service: ${e.message}")
                finish()
            }
        } ?: run {
            finish()
        }
        
        moveTaskToBack(true)
    }
}



========================================

FILE #74: E:\Vive\android\app\src\main\kotlin\com\nock\nock\VibeUploadWorker.kt

========================================


package com.nock.nock

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import androidx.core.app.NotificationCompat
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkerParameters
import androidx.work.WorkManager
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.collectLatest
import java.util.concurrent.ConcurrentHashMap

/**
 * Vibe Upload Worker
 * 
 * A "Short-lived" expedited worker that ensures the app process survives
 * while Dart performs a critical media upload.
 */
class VibeUploadWorker(context: Context, params: WorkerParameters) :
    CoroutineWorker(context, params) {

    companion object {
        const val CHANNEL_ID = "vibe_uploads"
        private const val NOTIFICATION_ID = 1001
        
        // Static flow to send progress updates to the active worker
        internal val progressFlow = MutableSharedFlow<Pair<String, Int>>(extraBufferCapacity = 10)
        
        // Static map to track active tasks and signal completion
        internal val activeTasks = ConcurrentHashMap<String, CompletableDeferred<Unit>>()
        
        fun stopTask(taskId: String) {
            activeTasks[taskId]?.complete(Unit)
        }
    }

    override suspend fun doWork(): Result {
        val taskId = id.toString()
        val title = inputData.getString("title") ?: "Uploading Vibe"
        val subtitle = inputData.getString("subtitle") ?: "Please wait..."
        
        android.util.Log.d("VibeUploadWorker", "ðŸ›¡ï¸ Starting background upload survival task: $taskId")
        
        val completionSignal = CompletableDeferred<Unit>()
        activeTasks[taskId] = completionSignal
        
        try {
            // Initial notification
            setForeground(createForegroundInfo(title, subtitle, 0))
            
            // Listen for progress updates and completion in parallel
            coroutineScope {
                val progressJob = launch {
                    progressFlow.collectLatest { (updateId, progress) ->
                        if (updateId == taskId) {
                            setForeground(createForegroundInfo(title, subtitle, progress))
                        }
                    }
                }
                
                completionSignal.await()
                progressJob.cancel()
            }
            
            return Result.success()
        } catch (e: Exception) {
            return Result.failure()
        } finally {
            activeTasks.remove(taskId)
        }
    }

    private suspend fun createForegroundInfo(title: String, subtitle: String, progress: Int): ForegroundInfo {
        val notificationManager = applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                "Vibe Uploads",
                NotificationManager.IMPORTANCE_LOW
            ).apply {
                description = "Shows progress of vibes being sent"
            }
            notificationManager.createNotificationChannel(channel)
        }

        val notification = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
            .setContentTitle(title)
            .setContentText(subtitle)
            .setSmallIcon(R.mipmap.ic_launcher)
            .setOngoing(true)
            .setCategory(NotificationCompat.CATEGORY_SERVICE)
            .setProgress(100, progress, progress == 0) 
            // ðŸ›¡ï¸ 2026 GOLD STANDARD: Use ProgressStyle for system-level prioritization
            .setStyle(NotificationCompat.BigTextStyle().bigText(subtitle))
            .build()

        // 2026 Standard: Specify foreground service type
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
            ForegroundInfo(NOTIFICATION_ID, notification, android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC)
        } else {
            ForegroundInfo(NOTIFICATION_ID, notification)
        }
    }

    /**
     * Public method to update progress from MainActivity
     */
    suspend fun updateProgress(title: String, subtitle: String, progress: Int) {
        setForeground(createForegroundInfo(title, subtitle, progress))
    }
}



========================================

FILE #75: E:\Vive\android\app\src\main\kotlin\com\nock\nock\WidgetUtils.kt

========================================


package com.nock.nock

import android.content.Context
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import androidx.core.content.FileProvider
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

object WidgetUtils {
    private const val WIDGET_CACHE_DIR = "widget_images"
    private const val PROVIDER_AUTHORITY = "com.nock.nock.provider"

    /**
     * Saves a bitmap to the cache directory and returns a content URI.
     * Uses JPEG to keep the file size minimal for the widget host.
     */
    fun saveBitmapAndGetUri(context: Context, bitmap: Bitmap, fileName: String): Uri? {
        val cacheDir = File(context.cacheDir, WIDGET_CACHE_DIR)
        if (!cacheDir.exists() && !cacheDir.mkdirs()) {
            return null
        }

        // Clean up old files with same prefix to avoid cache bloat
        // e.g. if fileName is "view_1_..." delete all "view_1_*"
        val prefix = fileName.substringBeforeLast("_") + "_"
        deleteFilesWithPrefix(context, prefix)

        val file = File(cacheDir, fileName)
        return try {
            FileOutputStream(file).use { out ->
                // Use JPEG for widgets - much smaller than PNG
                bitmap.compress(Bitmap.CompressFormat.JPEG, 85, out)
            }
            FileProvider.getUriForFile(context, PROVIDER_AUTHORITY, file)
        } catch (e: IOException) {
            e.printStackTrace()
            null
        }
    }

    /**
     * Helper to set image on RemoteViews safely (downsampled + URI method).
     * This is the "Gold Standard" fix for TransactionTooLargeException.
     * 
     * @param vibeId Optional ID to look up local cached version if path is a URL
     */
    fun setSafeImage(context: Context, views: android.widget.RemoteViews, viewId: Int, path: String, vibeId: String? = null, targetSize: Int = 300) {
        try {
            var actualPath = path
            
            // 1. Resolve local cached path if needed
            if (path.startsWith("http") && vibeId != null) {
                val flutterFilesDir = File(context.filesDir, "widget_images")
                val files = listOf("vibe_image_$vibeId.png", "nock_image_$vibeId.png", "avatar_$vibeId.png")
                for (fileName in files) {
                    val file = File(flutterFilesDir, fileName)
                    if (file.exists()) {
                        actualPath = file.absolutePath
                        break
                    }
                }
            }

            val file = File(actualPath)
            if (!file.exists()) return

            // 2. Load downsampled bitmap (Binder Safe)
            // 300px @ RGB_565 is ~180KB. 3 of these = ~540KB. Well under 1MB limit.
            val options = BitmapFactory.Options().apply {
                inJustDecodeBounds = true
            }
            BitmapFactory.decodeFile(actualPath, options)
            
            options.inSampleSize = calculateInSampleSize(options, targetSize, targetSize)
            options.inJustDecodeBounds = false
            options.inPreferredConfig = Bitmap.Config.RGB_565 
            
            val bitmap = BitmapFactory.decodeFile(actualPath, options)
            
            if (bitmap != null) {
                // 3. Directly set bitmap (Much more robust than URI for widgets)
                views.setImageViewBitmap(viewId, bitmap)
                android.util.Log.d("WidgetUtils", "Set bitmap for view $viewId from $actualPath")
            }
        } catch (e: Exception) {
            android.util.Log.e("WidgetUtils", "Error setting safe image: ${e.message}")
        }
    }

    fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
        val height: Int = options.outHeight
        val width: Int = options.outWidth
        var inSampleSize = 1
        if (height > reqHeight || width > reqWidth) {
            val halfHeight = height / 2
            val halfWidth = width / 2
            while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
                inSampleSize *= 2
            }
        }
        return inSampleSize
    }

    /**
     * Cleans up old widget images from the cache.
     */
    fun clearCache(context: Context) {
        val cacheDir = File(context.cacheDir, WIDGET_CACHE_DIR)
        if (cacheDir.exists()) {
            cacheDir.listFiles()?.forEach { it.delete() }
        }
    }

    /**
     * Deletes files starting with the given prefix.
     * Used to clean up old timestamped images for a specific widget.
     */
    fun deleteFilesWithPrefix(context: Context, prefix: String) {
        val cacheDir = File(context.cacheDir, WIDGET_CACHE_DIR)
        if (cacheDir.exists()) {
            cacheDir.listFiles()?.forEach { file ->
                if (file.name.startsWith(prefix)) {
                    file.delete()
                }
            }
        }
    }

    /**
     * Checks if a file exists in the cache and returns its URI.
     * Used to avoid redundant network calls.
     */
    fun getCachedUri(context: Context, fileName: String): Uri? {
        val cacheDir = File(context.cacheDir, WIDGET_CACHE_DIR)
        val file = File(cacheDir, fileName)
        
        return if (file.exists()) {
            FileProvider.getUriForFile(context, PROVIDER_AUTHORITY, file)
        } else {
            null
        }
    }
}



========================================

FILE #76: E:\Vive\ios\Runner\AppDelegate.swift

========================================


import Flutter
import UIKit
import AVFoundation

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    
    let controller : FlutterViewController = window?.rootViewController as! FlutterViewController
    
    // ==================== AUDIO CHANNEL ====================
    let audioChannel = FlutterMethodChannel(name: "com.vive.app/audio",
                                              binaryMessenger: controller.binaryMessenger)
    
    audioChannel.setMethodCallHandler({ [weak self] (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in
      if call.method == "deactivateSession" {
          self?.deactivateAudioSession(result: result)
      } else {
        result(FlutterMethodNotImplemented)
      }
    })
    
    // ==================== SHARE CHANNEL ====================
    let shareChannel = FlutterMethodChannel(name: "com.nock.nock/share",
                                            binaryMessenger: controller.binaryMessenger)
    
    shareChannel.setMethodCallHandler({ [weak self] (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in
      switch call.method {
      // Instagram share
      case "shareToInstagram":
        if let args = call.arguments as? [String: Any],
           let imagePath = args["imagePath"] as? String {
          self?.shareToApp(imagePath: imagePath, urlScheme: "instagram://", result: result)
        } else {
          result(FlutterError(code: "INVALID_ARGUMENT", message: "imagePath is required", details: nil))
        }
        
      case "isInstagramInstalled":
        let isInstalled = UIApplication.shared.canOpenURL(URL(string: "instagram://")!)
        result(isInstalled)
        
      // TikTok share
      case "shareToTikTok":
        if let args = call.arguments as? [String: Any],
           let imagePath = args["imagePath"] as? String {
          self?.shareToApp(imagePath: imagePath, urlScheme: "tiktok://", result: result)
        } else {
          result(FlutterError(code: "INVALID_ARGUMENT", message: "imagePath is required", details: nil))
        }
        
      case "isTikTokInstalled":
        // TikTok uses multiple URL schemes
        let schemes = ["tiktok://", "snssdk1180://", "snssdk1233://"]
        let isInstalled = schemes.contains { UIApplication.shared.canOpenURL(URL(string: $0)!) }
        result(isInstalled)
        
      default:
        result(FlutterMethodNotImplemented)
      }
    })

    // ==================== BACKGROUND UPLOAD CHANNEL ====================
    let backgroundChannel = FlutterMethodChannel(name: "com.nock.nock/background_upload",
                                              binaryMessenger: controller.binaryMessenger)
    
    // Register the task identifier for iOS 19+ survival
    if #available(iOS 19.0, *) {
        BGTaskScheduler.shared.register(forTaskWithIdentifier: "com.nock.nock.vibe_upload", using: nil) { task in
            guard let processingTask = task as? BGContinuedProcessingTask else { return }
            self.handleContinuedProcessingTask(processingTask)
        }
    }

    backgroundChannel.setMethodCallHandler({ [weak self] (call: FlutterMethodCall, result: @escaping FlutterResult) -> Void in
      switch call.method {
      case "startBackgroundTask":
        let taskId = "com.nock.nock.vibe_upload"
        
        // ðŸ›¡ï¸ 2026 GOLD STANDARD: BGContinuedProcessingTask (iOS 19+)
        if #available(iOS 19.0, *) {
            let request = BGContinuedProcessingTaskRequest(identifier: taskId)
            request.title = (call.arguments as? [String: Any])?["title"] as? String ?? "Sending Vibe"
            
            do {
                try BGTaskScheduler.shared.submit(request)
            } catch {
                print("AppDelegate: Failed to submit BGContinuedProcessingTask: \(error)")
            }
        }
        
        let backupID = UIApplication.shared.beginBackgroundTask(withName: taskId) {
            UIApplication.shared.endBackgroundTask(backupID)
        }
        result(taskId)
        
      case "updateTaskProgress":
        if #available(iOS 19.0, *),
           let args = call.arguments as? [String: Any],
           let fraction = args["fraction"] as? Double {
            self?.activeProcessingTask?.progress.completedUnitCount = Int64(fraction * 100)
        }
        result(true)
        
      case "stopBackgroundTask":
        if #available(iOS 19.0, *) {
            self?.activeProcessingTask?.setTaskCompleted(success: true)
            self?.activeProcessingTask = nil
        }
        result(true)
        
      default:
        result(FlutterMethodNotImplemented)
      }
    })

    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  // Reference to track the active task for progress updates
  private var activeProcessingTask: BGContinuedProcessingTask?

  @available(iOS 19.0, *)
  private func handleContinuedProcessingTask(_ task: BGContinuedProcessingTask) {
      self.activeProcessingTask = task
      task.progress.totalUnitCount = 100
      
      task.expirationHandler = {
          // ðŸ›¡ï¸ CRITICAL: Save state or cleanup before termination
          task.setTaskCompleted(success: false)
      }
  }
  
  // ==================== AUDIO SESSION MANAGEMENT ====================
  // CRITICAL: Handles the "Red Bar" anomaly by deactivating the session
  // with retries if the session is busy (e.g., during tearing down)
  
  private func deactivateAudioSession(result: @escaping FlutterResult, retryCount: Int = 0) {
      do {
          try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
          print("AppDelegate: Audio session deactivated successfully.")
          result(true)
      } catch let error as NSError {
          // Error Code 0x62757379 ('busy') or 560030580 (AVAudioSessionErrorCodeIsBusy)
          // Frequently happens if called too soon after stopping a player/recorder
          if (error.code == 560030580 || error.domain == NSOSStatusErrorDomain) && retryCount < 3 {
              print("AppDelegate: Audio session busy, retrying deactivation (#\(retryCount + 1))...")
              DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                  self.deactivateAudioSession(result: result, retryCount: retryCount + 1)
              }
          } else {
              print("AppDelegate: Failed to deactivate audio session: \(error.localizedDescription)")
              result(FlutterError(code: "AUDIO_ERROR", message: "Failed to deactivate", details: error.localizedDescription))
          }
      }
  }

  // ==================== SOCIAL SHARE (iOS) ====================
  // Uses UIDocumentInteractionController to share directly to apps
  // This opens the app's internal picker instead of system share sheet
  
  private func shareToApp(imagePath: String, urlScheme: String, result: @escaping FlutterResult) {
    guard let imageURL = URL(string: imagePath.hasPrefix("file://") ? imagePath : "file://\(imagePath)") else {
      result(false)
      return
    }
    
    // Check if app is installed
    guard UIApplication.shared.canOpenURL(URL(string: urlScheme)!) else {
      print("App not installed: \(urlScheme)")
      result(false)
      return
    }
    
    // Use UIDocumentInteractionController to share
    DispatchQueue.main.async { [weak self] in
      guard let self = self else { return }
      
      // Read image data
      guard let imageData = try? Data(contentsOf: imageURL) else {
        result(false)
        return
      }
      
      // Determine file extension and UTI based on app
      let fileExtension: String
      let uti: String
      
      if urlScheme.contains("instagram") {
        fileExtension = "instagram_share.igo"
        uti = "com.instagram.exclusivegram"
      } else if urlScheme.contains("tiktok") {
        // TikTok uses standard image types
        fileExtension = "tiktok_share.jpg"
        uti = "public.jpeg"
      } else {
        fileExtension = "share.jpg"
        uti = "public.jpeg"
      }
      
      // Save to temp file
      let tempPath = NSTemporaryDirectory().appending(fileExtension)
      let tempURL = URL(fileURLWithPath: tempPath)
      
      do {
        try imageData.write(to: tempURL)
      } catch {
        print("Failed to write temp file: \(error)")
        result(false)
        return
      }
      
      // Create document interaction controller
      let documentController = UIDocumentInteractionController(url: tempURL)
      documentController.uti = uti
      
      // Present from root view controller
      if let rootVC = self.window?.rootViewController {
        let success = documentController.presentOpenInMenu(from: CGRect.zero, in: rootVC.view, animated: true)
        result(success)
      } else {
        result(false)
      }
    }
  }
}



========================================

FILE #77: E:\Vive\ios\RunnerTests\RunnerTests.swift

========================================


import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}



========================================

FILE #78: E:\Vive\ios\VibeWidget\AudioManager.swift

========================================


import AVFoundation
import MediaPlayer

/// AudioManager - Robust audio engine for widget background playback
/// This is a standalone singleton that can be used across the widget extension
/// Provides proper background audio, now playing info, and remote control support
@available(iOS 14.0, *)
class AudioManager: NSObject, ObservableObject {
    static let shared = AudioManager()
    
    private var audioPlayer: AVPlayer?
    private var playerItem: AVPlayerItem?
    private var timeObserver: Any?
    
    @Published var isPlaying: Bool = false
    @Published var currentTime: Double = 0.0
    @Published var duration: Double = 0.0
    @Published var progress: Double = 0.0
    
    // Current audio info
    private var currentSenderName: String = ""
    private var currentVibeId: String = ""
    
    private override init() {
        super.init()
        setupAudioSession()
        setupRemoteCommandCenter()
    }
    
    deinit {
        removeTimeObserver()
        NotificationCenter.default.removeObserver(self)
    }
    
    // MARK: - Audio Session Setup
    
    /// Configure audio session for background playback
    /// CRITICAL: Must use .playback category to continue when screen locks
    private func setupAudioSession() {
        do {
            let session = AVAudioSession.sharedInstance()
            
            // .playback category: Audio continues when screen locks or app backgrounds
            // .spokenAudio mode: Optimized for voice messages, ducks other audio
            // This is REQUIRED for background audio - without it, iOS silences on lock
            try session.setCategory(
                .playback,
                mode: .spokenAudio,
                options: [.allowAirPlay, .allowBluetooth, .allowBluetoothA2DP]
            )
            
            // NOTE: Do NOT activate here. We only activate in play()
            // to minimize background resource usage and privacy indicators.
            
            // Listen for interruptions (phone calls, etc.)
            NotificationCenter.default.addObserver(
                self,
                selector: #selector(handleInterruption),
                name: AVAudioSession.interruptionNotification,
                object: session
            )
            
            // Listen for route changes (headphones plugged/unplugged)
            NotificationCenter.default.addObserver(
                self,
                selector: #selector(handleRouteChange),
                name: AVAudioSession.routeChangeNotification,
                object: session
            )
            
            print("AudioManager: Audio session configured for background playback (.playback category)")
        } catch {
            print("AudioManager: Failed to setup audio session: \(error.localizedDescription)")
        }
    }
    
    /// Re-activate audio session before playback (important for widgets)
    private func ensureAudioSessionActive() {
        do {
            let session = AVAudioSession.sharedInstance()
            try session.setActive(true, options: .notifyOthersOnDeactivation)
        } catch {
            print("AudioManager: Failed to activate session: \(error.localizedDescription)")
        }
    }
    
    /// Handle audio interruptions (phone calls, Siri, etc.)
    @objc private func handleInterruption(_ notification: Notification) {
        guard let userInfo = notification.userInfo,
              let typeValue = userInfo[AVAudioSessionInterruptionTypeKey] as? UInt,
              let type = AVAudioSession.InterruptionType(rawValue: typeValue) else {
            return
        }
        
        switch type {
        case .began:
            // Interruption began - pause playback
            pause()
            print("AudioManager: Playback interrupted")
            
        case .ended:
            // Interruption ended - resume if appropriate
            if let optionsValue = userInfo[AVAudioSessionInterruptionOptionKey] as? UInt {
                let options = AVAudioSession.InterruptionOptions(rawValue: optionsValue)
                if options.contains(.shouldResume) {
                    resume()
                    print("AudioManager: Resuming after interruption")
                }
            }
            
        @unknown default:
            break
        }
    }
    
    /// Handle route changes (headphones, Bluetooth, etc.)
    @objc private func handleRouteChange(_ notification: Notification) {
        guard let userInfo = notification.userInfo,
              let reasonValue = userInfo[AVAudioSessionRouteChangeReasonKey] as? UInt,
              let reason = AVAudioSession.RouteChangeReason(rawValue: reasonValue) else {
            return
        }
        
        // Pause when headphones are unplugged (standard iOS behavior)
        if reason == .oldDeviceUnavailable {
            pause()
            print("AudioManager: Audio route changed - paused")
        }
    }
    
    // MARK: - Remote Command Center (Lock Screen Controls)
    
    private func setupRemoteCommandCenter() {
        let commandCenter = MPRemoteCommandCenter.shared()
        
        commandCenter.playCommand.addTarget { [weak self] _ in
            self?.resume()
            return .success
        }
        
        commandCenter.pauseCommand.addTarget { [weak self] _ in
            self?.pause()
            return .success
        }
        
        commandCenter.togglePlayPauseCommand.addTarget { [weak self] _ in
            if self?.isPlaying == true {
                self?.pause()
            } else {
                self?.resume()
            }
            return .success
        }
    }
    
    // MARK: - Playback Methods
    
    func play(url: URL, senderName: String = "Vibe", vibeId: String = "") {
        // Store current info
        currentSenderName = senderName
        currentVibeId = vibeId
        
        // Stop any existing playback
        stop()
        
        // CRITICAL: Re-activate audio session before playback
        // This ensures background audio works from widget
        ensureAudioSessionActive()
        
        // Create new player item
        playerItem = AVPlayerItem(url: url)
        audioPlayer = AVPlayer(playerItem: playerItem)
        
        // Add completion observer
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(playerDidFinishPlaying),
            name: .AVPlayerItemDidPlayToEndTime,
            object: playerItem
        )
        
        // Add time observer
        addTimeObserver()
        
        // Start playback
        audioPlayer?.play()
        isPlaying = true
        
        // Update now playing info
        updateNowPlayingInfo()
    }
    
    func pause() {
        audioPlayer?.pause()
        isPlaying = false
        updateNowPlayingInfo()
    }
    
    func resume() {
        audioPlayer?.play()
        isPlaying = true
        updateNowPlayingInfo()
    }
    
    func stop() {
        removeTimeObserver()
        NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: playerItem)
        
        audioPlayer?.pause()
        audioPlayer = nil
        playerItem = nil
        isPlaying = false
        currentTime = 0.0
        progress = 0.0
        
        // Clear now playing info
        MPNowPlayingInfoCenter.default().nowPlayingInfo = nil
        
        // CRITICAL PRIVACY FIX: Deactivate session when stopping
        // This removes the "Orange Dot" or background audio entry immediately
        DispatchQueue.global(qos: .userInitiated).async {
            do {
                try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
                print("AudioManager: Audio session deactivated via stop()")
            } catch {
                print("AudioManager: Failed to deactivate: \(error)")
            }
        }
    }
    
    // MARK: - Time Observer
    
    private func addTimeObserver() {
        let interval = CMTime(seconds: 0.1, preferredTimescale: CMTimeScale(NSEC_PER_SEC))
        timeObserver = audioPlayer?.addPeriodicTimeObserver(forInterval: interval, queue: .main) { [weak self] time in
            guard let self = self, let item = self.playerItem else { return }
            
            self.currentTime = time.seconds
            self.duration = item.duration.seconds
            
            if self.duration > 0 && !self.duration.isNaN {
                self.progress = self.currentTime / self.duration
            }
        }
    }
    
    private func removeTimeObserver() {
        if let observer = timeObserver {
            audioPlayer?.removeTimeObserver(observer)
            timeObserver = nil
        }
    }
    
    // MARK: - Now Playing Info (Lock Screen)
    
    private func updateNowPlayingInfo() {
        var info = [String: Any]()
        
        info[MPMediaItemPropertyTitle] = "Voice Message"
        info[MPMediaItemPropertyArtist] = currentSenderName
        info[MPMediaItemPropertyAlbumTitle] = "Vibe"
        
        if let item = playerItem {
            let duration = item.duration.seconds
            if !duration.isNaN {
                info[MPMediaItemPropertyPlaybackDuration] = duration
            }
        }
        
        info[MPNowPlayingInfoPropertyElapsedPlaybackTime] = currentTime
        info[MPNowPlayingInfoPropertyPlaybackRate] = isPlaying ? 1.0 : 0.0
        
        MPNowPlayingInfoCenter.default().nowPlayingInfo = info
    }
    
    // MARK: - Callbacks
    
    @objc private func playerDidFinishPlaying(_ notification: Notification) {
        DispatchQueue.main.async { [weak self] in
            self?.isPlaying = false
            self?.progress = 0.0
            self?.currentTime = 0.0
            
            // Clear now playing info
            MPNowPlayingInfoCenter.default().nowPlayingInfo = nil
            
            // CRITICAL PRIVACY FIX: Deactivate session after playback finishes
            // This ensures the widget doesn't leave an active session entry
            do {
                try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
                print("AudioManager: Audio session deactivated after playback finished")
            } catch {
                print("AudioManager: Failed to deactivate after finish: \(error)")
            }
        }
    }
}

// MARK: - Async Play Method (For AppIntents)

@available(iOS 17.0, *)
extension AudioManager {
    /// Async play method for use with AppIntents
    func playAsync(url: URL, senderName: String = "Vibe", vibeId: String = "") async {
        await MainActor.run {
            play(url: url, senderName: senderName, vibeId: vibeId)
        }
    }
}



========================================

FILE #79: E:\Vive\ios\VibeWidget\AudioPlaybackIntent.swift

========================================


import AVFoundation
import AppIntents
import WidgetKit
import SwiftUI

// MARK: - Audio Playback Intent (iOS 17+)
/// Enables playing audio directly from the widget without opening the app
/// 
/// CRITICAL: Uses AudioPlaybackIntent (iOS 17+) NOT AudioStartingIntent (deprecated)
/// AudioPlaybackIntent grants the system background audio entitlement needed to
/// keep the process alive while audio plays from the widget.
/// 
/// Apple Docs: "Adopt this protocol to indicate to the system that your App Intent 
/// plays audio. The system can then avoid dialogue or other experiences that 
/// might interrupt that audio."

@available(iOS 17.0, *)
struct VibeAudioPlaybackIntent: AudioPlaybackIntent {
    static var title: LocalizedStringResource = "Play Vibe Audio"
    static var description = IntentDescription("Plays voice message audio from the home screen widget")
    
    @Parameter(title: "Audio URL")
    var audioUrl: String
    
    @Parameter(title: "Sender Name")
    var senderName: String
    
    @Parameter(title: "Vibe ID")
    var vibeId: String
    
    init() {
        self.audioUrl = ""
        self.senderName = ""
        self.vibeId = ""
    }
    
    init(audioUrl: String, senderName: String, vibeId: String) {
        self.audioUrl = audioUrl
        self.senderName = senderName
        self.vibeId = vibeId
    }
    
    func perform() async throws -> some IntentResult {
        // CRITICAL FIX #1: Activate AVAudioSession IMMEDIATELY on native side
        // This MUST happen before any async work (like waiting for Flutter)
        // It signals to iOS that audio is about to start, buying time for initialization
        do {
            let session = AVAudioSession.sharedInstance()
            try session.setCategory(.playback, mode: .spokenAudio)
            try session.setActive(true)
            print("VibeAudioPlaybackIntent: Audio session activated NATIVE side")
        } catch {
            print("VibeAudioPlaybackIntent: Failed to activate audio session: \(error)")
        }
        
        // Validate URL
        guard let url = URL(string: audioUrl), !audioUrl.isEmpty else {
            print("VibeAudioPlaybackIntent: Invalid audio URL")
            return .result()
        }
        
        // Get the audio manager and play
        // Now safe to do async work - iOS knows audio is coming
        let audioManager = AudioManager.shared
        await audioManager.playAsync(url: url, senderName: senderName, vibeId: vibeId)
        
        // Mark as played in shared UserDefaults
        let sharedDefaults = UserDefaults(suiteName: "group.com.nock.nock")
        sharedDefaults?.set(true, forKey: "isPlayed_\(vibeId)")
        sharedDefaults?.set(Date(), forKey: "playedAt_\(vibeId)")
        sharedDefaults?.synchronize()
        
        // Trigger widget refresh to update UI (remove "NEW" indicator)
        WidgetCenter.shared.reloadTimelines(ofKind: "VibeWidget")
        
        return .result()
    }
}

// MARK: - Stop Audio Intent

@available(iOS 17.0, *)
struct StopVibeAudioIntent: AppIntent {
    static var title: LocalizedStringResource = "Stop Vibe Audio"
    static var description = IntentDescription("Stops the currently playing voice message")
    
    init() {}
    
    func perform() async throws -> some IntentResult {
        await MainActor.run {
            AudioManager.shared.stop()
        }
        return .result()
    }
}

// MARK: - Widget Audio Playback Button

@available(iOS 17.0, *)
struct AudioPlaybackButton: View {
    let audioUrl: String
    let senderName: String
    let vibeId: String
    
    var body: some View {
        Button(intent: VibeAudioPlaybackIntent(
            audioUrl: audioUrl,
            senderName: senderName,
            vibeId: vibeId
        )) {
            ZStack {
                // Outer glow
                Circle()
                    .fill(Color(hex: "#00F0FF").opacity(0.2))
                    .frame(width: 48, height: 48)
                
                // Border
                Circle()
                    .stroke(
                        LinearGradient(
                            colors: [Color(hex: "#00F0FF"), Color(hex: "#00F0FF").opacity(0.5)],
                            startPoint: .topLeading,
                            endPoint: .bottomTrailing
                        ),
                        lineWidth: 2
                    )
                    .frame(width: 44, height: 44)
                
                // Play icon
                Image(systemName: "play.fill")
                    .font(.system(size: 16, weight: .bold))
                    .foregroundColor(Color(hex: "#00F0FF"))
            }
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Stop Button

@available(iOS 17.0, *)
struct StopAudioButton: View {
    var body: some View {
        Button(intent: StopVibeAudioIntent()) {
            ZStack {
                Circle()
                    .fill(Color(hex: "#FF0099").opacity(0.2))
                    .frame(width: 48, height: 48)
                
                Circle()
                    .stroke(Color(hex: "#FF0099"), lineWidth: 2)
                    .frame(width: 44, height: 44)
                
                Image(systemName: "stop.fill")
                    .font(.system(size: 14, weight: .bold))
                    .foregroundColor(Color(hex: "#FF0099"))
            }
        }
        .buttonStyle(.plain)
    }
}



========================================

FILE #80: E:\Vive\ios\VibeWidget\BFFWidget.swift

========================================


import WidgetKit
import SwiftUI
import AppIntents

// MARK: - BFF Widget Entry
struct BFFEntry: TimelineEntry {
    let date: Date
    let friendId: String
    let friendName: String
    let avatarURL: URL?
    let streak: Int
    let lastVibeTime: Date?
}

// MARK: - BFF Timeline Provider
struct BFFTimelineProvider: AppIntentTimelineProvider {
    typealias Entry = BFFEntry
    typealias Intent = SelectFriendIntent
    
    func placeholder(in context: Context) -> BFFEntry {
        BFFEntry(
            date: Date(),
            friendId: "placeholder",
            friendName: "BFF",
            avatarURL: nil,
            streak: 0,
            lastVibeTime: nil
        )
    }
    
    func snapshot(for configuration: SelectFriendIntent, in context: Context) async -> BFFEntry {
        let friend = configuration.friend
        return BFFEntry(
            date: Date(),
            friendId: friend?.id ?? "demo",
            friendName: friend?.name ?? "Best Friend",
            avatarURL: nil,
            streak: 7,
            lastVibeTime: Date()
        )
    }
    
    func timeline(for configuration: SelectFriendIntent, in context: Context) async -> Timeline<BFFEntry> {
        let friend = configuration.friend
        
        // App group container URL for direct file access (Prevents Jetsam 30MB crash)
        let containerURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.nock.nock")
        
        var avatarURL: URL? = nil
        var streak = 0
        
        if let friendId = friend?.id,
           let defaults = UserDefaults(suiteName: "group.com.nock.nock") {
            // Read metadata
            streak = defaults.integer(forKey: "streak_\(friendId)")
            
            // Construct file URL for the cached avatar (saved by WidgetUpdateService.dart)
            if let container = containerURL {
                let fileURL = container.appendingPathComponent("avatar_\(friendId)")
                if FileManager.default.fileExists(atPath: fileURL.path) {
                    avatarURL = fileURL
                }
            }
        }
        
        let entry = BFFEntry(
            date: Date(),
            friendId: friend?.id ?? "",
            friendName: friend?.name ?? "Select Friend",
            avatarURL: avatarURL,
            streak: streak,
            lastVibeTime: nil
        )
        
        // Refresh every hour
        let nextUpdate = Calendar.current.date(byAdding: .hour, value: 1, to: Date())!
        return Timeline(entries: [entry], policy: .after(nextUpdate))
    }
}

// MARK: - BFF Widget View
struct BFFWidgetView: View {
    let entry: BFFEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        switch family {
        case .accessoryCircular:
            accessoryCircularView
        default:
            homeScreenView
        }
    }
    
    // MARK: - Lock Screen Circular View
    private var accessoryCircularView: some View {
        Button(intent: RecordVibeIntent(friendId: entry.friendId)) {
            ZStack {
                AccessoryWidgetBackground()
                
                VStack(spacing: 2) {
                    Image(systemName: "mic.fill")
                        .font(.system(size: 20))
                        .widgetAccentable()
                    
                    Text(String(entry.friendName.prefix(3)))
                        .font(.system(size: 8, weight: .medium))
                        .lineLimit(1)
                }
            }
        }
        .buttonStyle(.plain)
    }
    
    // MARK: - Home Screen Small View
    private var homeScreenView: some View {
        Button(intent: RecordVibeIntent(friendId: entry.friendId)) {
            GeometryReader { geometry in
                ZStack {
                    // Background gradient
                    LinearGradient(
                        colors: [
                            Color(hex: "121226"),
                            Color(hex: "0A0A1A")
                        ],
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                    
                    VStack(spacing: 8) {
                        // Avatar
                        ZStack {
                            let avatarSize = geometry.size.width * 0.45
                            let imageSize = avatarSize * 0.9
                            
                            Circle()
                                .fill(
                                    LinearGradient(
                                        colors: [Color(hex: "D4F49C"), Color(hex: "E5D1FA")],
                                        startPoint: .topLeading,
                                        endPoint: .bottomTrailing
                                    )
                                )
                                .frame(width: avatarSize, height: avatarSize)
                            
                            if let imageURL = entry.avatarURL,
                               let uiImage = downsample(at: imageURL, to: CGSize(width: imageSize, height: imageSize)) {
                                Image(uiImage: uiImage)
                                    .resizable()
                                    .aspectRatio(contentMode: .fill)
                                    .frame(width: imageSize, height: imageSize)
                                    .clipShape(Circle())
                            } else {
                                Text(String(entry.friendName.prefix(1)).uppercased())
                                    .font(.system(size: avatarSize * 0.4, weight: .bold))
                                    .foregroundColor(.white)
                            }
                            
                            // Mic indicator
                            Circle()
                                .fill(Color(hex: "D4F49C"))
                                .frame(width: avatarSize * 0.3, height: avatarSize * 0.3)
                                .overlay(
                                    Image(systemName: "mic.fill")
                                        .font(.system(size: avatarSize * 0.15))
                                        .foregroundColor(.black)
                                )
                                .offset(x: avatarSize * 0.35, y: avatarSize * 0.35)
                        }
                        
                        // Name
                        Text(entry.friendName)
                            .font(.system(size: 14, weight: .semibold))
                            .foregroundColor(.white)
                            .lineLimit(1)
                        
                        // Streak (if any)
                        if entry.streak > 0 {
                            HStack(spacing: 4) {
                                Image(systemName: "flame.fill")
                                    .foregroundColor(.orange)
                                Text("\(entry.streak)")
                                    .foregroundColor(.white)
                            }
                            .font(.system(size: 12, weight: .medium))
                        } else {
                            Text("Tap to record")
                                .font(.system(size: 11))
                                .foregroundColor(.gray)
                        }
                    }
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                }
            }
            .containerBackground(.clear, for: .widget)
        }
        .buttonStyle(.plain)
    }
    
    // MARK: - Memory Efficient Downsampling (DISK BASED)
    private func downsample(at imageURL: URL, to pointSize: CGSize) -> UIImage? {
        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
        guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions) else {
            return nil
        }
        
        let scale = UIScreen.main.scale
        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
        
        let downsampleOptions = [
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceShouldCacheImmediately: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels
        ] as CFDictionary
        
        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {
            return nil
        }
        
        return UIImage(cgImage: downsampledImage)
    }
}

// MARK: - BFF Widget
struct BFFWidget: Widget {
    let kind = "BFFWidget"
    
    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: kind,
            intent: SelectFriendIntent.self,
            provider: BFFTimelineProvider()
        ) { entry in
            BFFWidgetView(entry: entry)
        }
        .configurationDisplayName("BFF")
        .description("Quick access to your closest friend")
        .supportedFamilies([.systemSmall, .accessoryCircular])
    }
}

// MARK: - Preview
#Preview(as: .systemSmall) {
    BFFWidget()
} timeline: {
    BFFEntry(
        date: .now,
        friendId: "123",
        friendName: "Sarah",
        avatarURL: nil,
        streak: 32,
        lastVibeTime: Date()
    )
}



========================================

FILE #81: E:\Vive\ios\VibeWidget\RecordVibeIntent.swift

========================================


import AppIntents
import Foundation

// MARK: - Record Vibe Intent
/// App Intent triggered when user taps the BFF widget
/// Opens the app directly into recording mode for the specified friend
struct RecordVibeIntent: AppIntent {
    static var title: LocalizedStringResource = "Record Vibe"
    static var description = IntentDescription("Start recording a vibe to a friend")
    static var openAppWhenRun: Bool = true
    
    @Parameter(title: "Friend ID")
    var friendId: String
    
    init() {
        self.friendId = ""
    }
    
    init(friendId: String) {
        self.friendId = friendId
    }
    
    func perform() async throws -> some IntentResult {
        // The app will handle the deep link via URL scheme
        // nock://record?to=friendId
        // This is handled in AppDelegate/SceneDelegate
        
        // Store the target friend ID for the app to read on launch
        if let defaults = UserDefaults(suiteName: "group.com.nock.nock") {
            defaults.set(friendId, forKey: "pending_record_to")
            defaults.set(Date().timeIntervalSince1970, forKey: "pending_record_timestamp")
        }
        
        return .result()
    }
}

// MARK: - Send Nudge Intent  
/// Quick nudge action from BFF widget (iOS 17+ interactive widget)
struct SendNudgeIntent: AppIntent {
    static var title: LocalizedStringResource = "Send Nudge"
    static var description = IntentDescription("Send a quick nudge to your friend")
    
    @Parameter(title: "Friend ID")
    var friendId: String
    
    @Parameter(title: "Nudge Type")
    var nudgeType: String
    
    init() {
        self.friendId = ""
        self.nudgeType = "heart"
    }
    
    init(friendId: String, nudgeType: String = "heart") {
        self.friendId = friendId
        self.nudgeType = nudgeType
    }
    
    func perform() async throws -> some IntentResult {
        // Store nudge request for app to process
        if let defaults = UserDefaults(suiteName: "group.com.nock.nock") {
            defaults.set(friendId, forKey: "pending_nudge_to")
            defaults.set(nudgeType, forKey: "pending_nudge_type")
            defaults.set(Date().timeIntervalSince1970, forKey: "pending_nudge_timestamp")
        }
        
        // Trigger haptic feedback would happen in the main app
        return .result()
    }
}



========================================

FILE #82: E:\Vive\ios\VibeWidget\SelectFriendIntent.swift

========================================


import AppIntents
import WidgetKit

// MARK: - Friend Entity for Widget Configuration
/// Represents a friend that can be selected for the BFF widget
struct FriendEntity: AppEntity {
    let id: String
    let name: String
    let avatarUrl: String?
    
    static var typeDisplayRepresentation: TypeDisplayRepresentation = "Friend"
    static var defaultQuery = FriendQuery()
    
    var displayRepresentation: DisplayRepresentation {
        DisplayRepresentation(title: "\(name)")
    }
}

// MARK: - Friend Query
/// Fetches friends from the shared App Group container
struct FriendQuery: EntityQuery {
    func entities(for identifiers: [String]) async throws -> [FriendEntity] {
        return loadFriendsFromAppGroup().filter { identifiers.contains($0.id) }
    }
    
    func suggestedEntities() async throws -> [FriendEntity] {
        return loadFriendsFromAppGroup()
    }
    
    /// Load friends from App Group shared data
    private func loadFriendsFromAppGroup() -> [FriendEntity] {
        guard let defaults = UserDefaults(suiteName: "group.com.nock.nock"),
              let data = defaults.data(forKey: "friends_list"),
              let friends = try? JSONDecoder().decode([FriendData].self, from: data) else {
            // Return placeholder if no friends cached
            return [
                FriendEntity(id: "demo1", name: "Best Friend", avatarUrl: nil),
                FriendEntity(id: "demo2", name: "Partner", avatarUrl: nil)
            ]
        }
        
        return friends.map { FriendEntity(id: $0.id, name: $0.name, avatarUrl: $0.avatarUrl) }
    }
}

// MARK: - Friend Data (Codable)
struct FriendData: Codable {
    let id: String
    let name: String
    let avatarUrl: String?
}

// MARK: - Select Friend Intent
/// Configuration intent for the BFF widget - allows user to pick which friend
struct SelectFriendIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "Select Friend"
    static var description = IntentDescription("Choose which friend this widget connects to")
    
    @Parameter(title: "Friend")
    var friend: FriendEntity?
}



========================================

FILE #83: E:\Vive\ios\VibeWidget\SquadWidget.swift

========================================


import WidgetKit
import SwiftUI

// MARK: - Squad Widget Entry
struct SquadEntry: TimelineEntry {
    let date: Date
    let recentVibes: [SquadVibeData]
}

// MARK: - Squad Vibe Data
struct SquadVibeData: Identifiable {
    let id: String
    let vibeId: String
    let senderName: String
    let senderId: String
    let imageURL: URL?
    let isPlayed: Bool
    let timestamp: Date
    let transcription: String?
}

// MARK: - Squad Timeline Provider
struct SquadTimelineProvider: TimelineProvider {
    typealias Entry = SquadEntry
    
    func placeholder(in context: Context) -> SquadEntry {
        SquadEntry(
            date: Date(),
            recentVibes: [
                SquadVibeData(id: "1", vibeId: "1", senderName: "Sarah", senderId: "s1", imageURL: nil, isPlayed: false, timestamp: Date(), transcription: nil),
                SquadVibeData(id: "2", vibeId: "2", senderName: "Alex", senderId: "s2", imageURL: nil, isPlayed: true, timestamp: Date(), transcription: nil),
                SquadVibeData(id: "3", vibeId: "3", senderName: "Mom", senderId: "s3", imageURL: nil, isPlayed: true, timestamp: Date(), transcription: nil)
            ]
        )
    }
    
    func getSnapshot(in context: Context, completion: @escaping (SquadEntry) -> Void) {
        let entry = placeholder(in: context)
        completion(entry)
    }
    
    func getTimeline(in context: Context, completion: @escaping (Timeline<SquadEntry>) -> Void) {
        // Load vibes from App Group
        let vibes = loadVibesFromAppGroup()
        
        let entry = SquadEntry(
            date: Date(),
            recentVibes: vibes
        )
        
        // Refresh every 15 minutes
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: Date())!
        let timeline = Timeline(entries: [entry], policy: .after(nextUpdate))
        completion(timeline)
    }
    
    /// Load recent vibes from App Group shared data
    private func loadVibesFromAppGroup() -> [SquadVibeData] {
        guard let defaults = UserDefaults(suiteName: "group.com.nock.nock"),
              let data = defaults.data(forKey: "recent_vibes"),
              let vibesJson = try? JSONDecoder().decode([VibeJson].self, from: data) else {
            return []
        }
        
        // App group container URL for direct file access
        let containerURL = FileManager.default.containerURL(forSecurityApplicationGroupIdentifier: "group.com.nock.nock")
        
        return vibesJson.prefix(3).enumerated().map { index, vibe in
            // Use file-based access if possible to stay under 30MB Jetsam limit
            var imageURL: URL? = nil
            
            // The Flutter side (WidgetUpdateService.dart) saves images to the App Group container
            // using keys like "vibe_image_$vibeId"
            if let container = containerURL {
                 let fileURL = container.appendingPathComponent("vibe_image_\(vibe.vibeId)")
                 if FileManager.default.fileExists(atPath: fileURL.path) {
                     imageURL = fileURL
                 }
            }
            
            return SquadVibeData(
                id: "\(index)",
                vibeId: vibe.vibeId,
                senderName: vibe.senderName,
                senderId: vibe.senderId,
                imageURL: imageURL,
                isPlayed: vibe.isPlayed,
                timestamp: Date(timeIntervalSince1970: vibe.timestamp / 1000),
                transcription: vibe.transcription
            )
        }
    }
}

// MARK: - Vibe JSON (Codable)
struct VibeJson: Codable {
    let vibeId: String
    let senderName: String
    let senderId: String
    let imageUrl: String?
    let isPlayed: Bool
    let timestamp: Double
    let transcription: String?
}

// MARK: - Squad Widget View
struct SquadWidgetView: View {
    let entry: SquadEntry
    @Environment(\.widgetFamily) var family
    
    var body: some View {
        GeometryReader { geometry in
            ZStack {
                // Background
                LinearGradient(
                    colors: [
                        Color(hex: "121226"),
                        Color(hex: "0A0A1A")
                    ],
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                )
                
                if entry.recentVibes.isEmpty {
                    emptyStateView
                } else {
                    vibeGridView
                }
            }
        }
        .containerBackground(.clear, for: .widget)
    }
    
    // MARK: - Empty State
    private var emptyStateView: some View {
        VStack(spacing: 8) {
            Image(systemName: "waveform.circle")
                .font(.system(size: 32))
                .foregroundColor(.gray)
            
            Text("No vibes yet")
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(.gray)
            
            Text("Waiting for friends...")
                .font(.system(size: 11))
                .foregroundColor(.gray.opacity(0.7))
        }
    }
    
    // MARK: - Vibe Grid
    private var vibeGridView: some View {
        HStack(spacing: 12) {
            ForEach(entry.recentVibes) { vibe in
                vibeCard(vibe)
            }
        }
        .padding(.horizontal, 0)
        .padding(.vertical, 0)
    }
    
    // MARK: - Individual Vibe Card
    private func vibeCard(_ vibe: SquadVibeData) -> some View {
        Link(destination: URL(string: "nock://player/\(vibe.vibeId)")!) {
                // Image or Avatar
                ZStack {
                    let cardSize: CGFloat = 70
                    
                    if let imageURL = vibe.imageURL,
                       let uiImage = downsample(at: imageURL, to: CGSize(width: cardSize, height: cardSize)) {
                        Image(uiImage: uiImage)
                            .resizable()
                            .aspectRatio(contentMode: .fill)
                            .frame(width: cardSize, height: cardSize)
                            .clipShape(RoundedRectangle(cornerRadius: 28))
                    } else {
                        RoundedRectangle(cornerRadius: 28)
                            .fill(
                                LinearGradient(
                                    colors: [Color(hex: "D4F49C").opacity(0.3), Color(hex: "E5D1FA").opacity(0.3)],
                                    startPoint: .topLeading,
                                    endPoint: .bottomTrailing
                                )
                            )
                            .frame(width: cardSize, height: cardSize)
                            .overlay(
                                Text(String(vibe.senderName.prefix(1)).uppercased())
                                    .font(.system(size: 24, weight: .bold))
                                    .foregroundColor(.white)
                            )
                    }
                    
                    // Unread indicator
                    if !vibe.isPlayed {
                        Circle()
                            .fill(Color(hex: "D4F49C"))
                            .frame(width: 12, height: 12)
                            .overlay(
                                Circle()
                                    .stroke(Color(hex: "121226"), lineWidth: 2)
                            )
                            .offset(x: cardSize/2 - 2, y: -cardSize/2 + 2)
                    }
                    
                    // Play button overlay
                    Circle()
                        .fill(Color.black.opacity(0.4))
                        .frame(width: 24, height: 24)
                        .overlay(
                            Image(systemName: "play.fill")
                                .font(.system(size: 10))
                                .foregroundColor(.white)
                        )
                }
                
                // Sender name
                Text(vibe.senderName)
                    .font(.system(size: 11, weight: .medium))
                    .foregroundColor(.white)
                    .lineLimit(1)
                
                // Time ago
                Text(timeAgo(vibe.timestamp))
                    .font(.system(size: 9))
                    .foregroundColor(.gray)
            }
        }
    }
    
    // MARK: - Time Formatting
    private func timeAgo(_ date: Date) -> String {
        let interval = Date().timeIntervalSince(date)
        
        if interval < 60 {
            return "now"
        } else if interval < 3600 {
            let minutes = Int(interval / 60)
            return "\(minutes)m"
        } else if interval < 86400 {
            let hours = Int(interval / 3600)
            return "\(hours)h"
        } else {
            let days = Int(interval / 86400)
            return "\(days)d"
        }
    }
    
    // MARK: - Memory Efficient Downsampling (DISK BASED)
    private func downsample(at imageURL: URL, to pointSize: CGSize) -> UIImage? {
        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
        guard let imageSource = CGImageSourceCreateWithURL(imageURL as CFURL, imageSourceOptions) else {
            return nil
        }
        
        // Calculate max dimension (scale factor * point size)
        let scale = UIScreen.main.scale
        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
        
        let downsampleOptions = [
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceShouldCacheImmediately: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels
        ] as CFDictionary
        
        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {
            return nil
        }
        
        return UIImage(cgImage: downsampledImage)
    }
}

// MARK: - Squad Widget
struct SquadWidget: Widget {
    let kind = "SquadWidget"
    
    var body: some WidgetConfiguration {
        StaticConfiguration(
            kind: kind,
            provider: SquadTimelineProvider()
        ) { entry in
            SquadWidgetView(entry: entry)
        }
        .configurationDisplayName("Squad")
        .description("See your latest vibes at a glance")
        .supportedFamilies([.systemMedium])
    }
}

// MARK: - Preview
#Preview(as: .systemMedium) {
    SquadWidget()
} timeline: {
    SquadEntry(
        date: .now,
        recentVibes: [
            SquadVibeData(id: "1", vibeId: "abc", senderName: "Sarah", senderId: "s1", imageURL: nil, isPlayed: false, timestamp: Date(), transcription: nil),
            SquadVibeData(id: "2", vibeId: "def", senderName: "Alex", senderId: "s2", imageURL: nil, isPlayed: true, timestamp: Date().addingTimeInterval(-3600), transcription: nil),
            SquadVibeData(id: "3", vibeId: "ghi", senderName: "Mom", senderId: "s3", imageURL: nil, isPlayed: true, timestamp: Date().addingTimeInterval(-86400), transcription: nil)
        ]
    )
}



========================================

FILE #84: E:\Vive\ios\VibeWidget\VibeWidget.swift

========================================


import WidgetKit
import SwiftUI
import AppIntents

// MARK: - Widget Data Model
struct VibeData: Codable {
    let senderName: String
    let senderId: String  // For nudge feature
    let audioUrl: String
    let imageUrl: String
    let videoUrl: String?  // ðŸŽ¬ 4-State Protocol: Video URL for deep linking
    let vibeId: String
    let timestamp: Date
    let isPlayed: Bool
    let audioDuration: Int
    let distance: String?  // Distance badge (73 requests)
    
    // ðŸŽ¬ 4-State Widget Protocol: Content type flags
    let isVideo: Bool       // True = Video vibe (show play overlay)
    let isAudioOnly: Bool   // True = Voice note only (show mic icon)
    
    /// ðŸ“ Transcription-First: First 50 chars of voice message for glanceability
    /// Lets users read vibes in meetings/class without playing audio
    let transcription: String?
    
    // Non-codable: Local URL to downsampled image for reliability and 0-RAM timeline caching
    var localImageURL: URL?
    
    enum CodingKeys: String, CodingKey {
        case senderName, senderId, audioUrl, imageUrl, videoUrl, vibeId, timestamp, isPlayed, audioDuration, distance, isVideo, isAudioOnly, transcription, localImageURL
    }
    
    // CRITICAL FIX: Custom decoder to handle FCM timestamp as String
    // FCM data payloads ALWAYS send values as Strings, even numbers.
    // The default JSONDecoder with .millisecondsSince1970 expects a Number, 
    // causing silent decode failures that left the widget stale.
    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        
        senderName = try container.decode(String.self, forKey: .senderName)
        senderId = try container.decodeIfPresent(String.self, forKey: .senderId) ?? ""
        audioUrl = try container.decode(String.self, forKey: .audioUrl)
        imageUrl = try container.decode(String.self, forKey: .imageUrl)
        videoUrl = try container.decodeIfPresent(String.self, forKey: .videoUrl)
        vibeId = try container.decode(String.self, forKey: .vibeId)
        isPlayed = try container.decodeIfPresent(Bool.self, forKey: .isPlayed) ?? false
        audioDuration = try container.decodeIfPresent(Int.self, forKey: .audioDuration) ?? 0
        
        // ðŸŽ¬ 4-State Widget Protocol: Decode content type flags
        isVideo = try container.decodeIfPresent(Bool.self, forKey: .isVideo) ?? false
        isAudioOnly = try container.decodeIfPresent(Bool.self, forKey: .isAudioOnly) ?? false
        distance = try container.decodeIfPresent(String.self, forKey: .distance)
        transcription = try container.decodeIfPresent(String.self, forKey: .transcription)
        
        // Handle timestamp as String (FCM always sends strings)
        // Convert "1702382400000" -> Date
        if let timestampString = try container.decodeIfPresent(String.self, forKey: .timestamp),
           let timestampMillis = Double(timestampString) {
            timestamp = Date(timeIntervalSince1970: timestampMillis / 1000)
        } else if let timestampMillis = try container.decodeIfPresent(Double.self, forKey: .timestamp) {
            // Fallback: Handle if already a number (e.g., from UserDefaults)
            timestamp = Date(timeIntervalSince1970: timestampMillis / 1000)
        } else {
            timestamp = Date()
        }
        
        // Decode localImageURL if present (persisted after timeline generation)
        self.localImageURL = try container.decodeIfPresent(URL.self, forKey: .localImageURL)
    }
    
    // Custom encoder to ensure localImageURL is persisted
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        
        try container.encode(senderName, forKey: .senderName)
        try container.encode(senderId, forKey: .senderId)
        try container.encode(audioUrl, forKey: .audioUrl)
        try container.encode(imageUrl, forKey: .imageUrl)
        try container.encode(videoUrl, forKey: .videoUrl)
        try container.encode(vibeId, forKey: .vibeId)
        try container.encode(isPlayed, forKey: .isPlayed)
        try container.encode(audioDuration, forKey: .audioDuration)
        try container.encode(isVideo, forKey: .isVideo)
        try container.encode(isAudioOnly, forKey: .isAudioOnly)
        try container.encode(distance, forKey: .distance)
        try container.encode(transcription, forKey: .transcription)
        
        // Encode Date as Double for compatibility with Flutter-to-Native bridge expectations
        try container.encode(timestamp.timeIntervalSince1970 * 1000, forKey: .timestamp)
        
        try container.encode(localImageURL, forKey: .localImageURL)
    }
    
    // Standard memberwise init for creating placeholder/manual instances
    init(senderName: String, senderId: String, audioUrl: String, imageUrl: String, 
         videoUrl: String? = nil, vibeId: String, timestamp: Date, isPlayed: Bool, 
         audioDuration: Int, distance: String?, isVideo: Bool = false, 
         isAudioOnly: Bool = false, transcription: String?, localImageURL: URL?) {
        self.senderName = senderName
        self.senderId = senderId
        self.audioUrl = audioUrl
        self.imageUrl = imageUrl
        self.videoUrl = videoUrl
        self.vibeId = vibeId
        self.timestamp = timestamp
        self.isPlayed = isPlayed
        self.audioDuration = audioDuration
        self.distance = distance
        self.isVideo = isVideo
        self.isAudioOnly = isAudioOnly
        self.transcription = transcription
        self.localImageURL = localImageURL
    }
    
    static let placeholder = VibeData(
        senderName: "Vibe",
        senderId: "",
        audioUrl: "",
        imageUrl: "",
        videoUrl: nil,
        vibeId: "",
        timestamp: Date(),
        isPlayed: true,
        audioDuration: 0,
        distance: nil,
        isVideo: false,
        isAudioOnly: false,
        transcription: nil,
        localImageURL: nil
    )
}

// MARK: - Widget Entry
struct VibeEntry: TimelineEntry {
    let date: Date
    let vibeData: VibeData?
    let configuration: ConfigurationAppIntent
}

// MARK: - Configuration Intent
struct ConfigurationAppIntent: WidgetConfigurationIntent {
    static var title: LocalizedStringResource = "Vibe Widget"
    static var description = IntentDescription("Shows your latest Vibe")
}

// MARK: - Timeline Provider
struct VibeTimelineProvider: AppIntentTimelineProvider {
    typealias Entry = VibeEntry
    typealias Intent = ConfigurationAppIntent

    func placeholder(in context: Context) -> VibeEntry {
        VibeEntry(date: Date(), vibeData: VibeData.placeholder, configuration: ConfigurationAppIntent())
    }

    func snapshot(for configuration: ConfigurationAppIntent, in context: Context) async -> VibeEntry {
        var vibeData = await loadVibeData()
        // CRITICAL FIX: Pre-download image for snapshot reliability
        if let data = vibeData, !data.imageUrl.isEmpty {
            vibeData = await downloadImageData(for: data)
        }
        return VibeEntry(date: Date(), vibeData: vibeData, configuration: configuration)
    }

    func timeline(for configuration: ConfigurationAppIntent, in context: Context) async -> Timeline<VibeEntry> {
        var vibeData = await loadVibeData()
        // CRITICAL FIX: Pre-download image in timeline provider
        // This prevents blank widgets when AsyncImage times out
        if let data = vibeData, !data.imageUrl.isEmpty {
            vibeData = await downloadImageData(for: data)
        }
        
        let entry = VibeEntry(date: Date(), vibeData: vibeData, configuration: configuration)
        
        // Refresh every 15 minutes
        let nextUpdate = Calendar.current.date(byAdding: .minute, value: 15, to: Date())!
        return Timeline(entries: [entry], policy: .after(nextUpdate))
    }
    
    private func loadVibeData() async -> VibeData? {
        // Load from shared UserDefaults with App Group
        let sharedDefaults = UserDefaults(suiteName: "group.com.nock.nock")
        
        guard let jsonString = sharedDefaults?.string(forKey: "vibeData"),
              let data = jsonString.data(using: .utf8) else {
            return nil
        }
        
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .millisecondsSince1970
        return try? decoder.decode(VibeData.self, from: data)
    }
    
    /// CRITICAL FIX: Memory-safe image download for widgets
    /// 
    /// iOS Widget extensions have strict limits:
    /// - ~30MB memory limit
    /// - Few seconds execution time
    /// 
    /// This implementation:
    /// 1. Uses ephemeral session with strict 5-second timeout
    /// 2. Downloads directly to disk (URLSession.download) to avoid RAM spikes
    /// 3. Downsamples large images using CGImageSource (memory-safe streaming)
    /// 4. Always returns gracefully (never hangs)
    private func downloadImageData(for vibeData: VibeData) async -> VibeData {
        guard let url = URL(string: vibeData.imageUrl) else { return vibeData }
        
        let config = URLSessionConfiguration.ephemeral
        config.timeoutIntervalForRequest = 5.0
        config.timeoutIntervalForResource = 5.0
        let session = URLSession(configuration: config)
        
        do {
            // STEP 1: Download directly to a temporary file on disk. 
            let (tempURL, _) = try await session.download(from: url)
            
            // STEP 2: Downsample and save to App Group container for persistence across reloads
            let localURL = try saveDownsampledImage(at: tempURL, for: vibeData.vibeId)
            
            var updatedData = vibeData
            updatedData.localImageURL = localURL
            return updatedData
        } catch {
            print("VibeWidget: Failed to download image: \(error.localizedDescription)")
            return vibeData
        }
    }
    
    /// Downsamples image from a temp URL and saves it to the App Group container
    private func saveDownsampledImage(at url: URL, for vibeId: String) throws -> URL? {
        let options: [CFString: Any] = [
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceShouldCache: false,
            kCGImageSourceThumbnailMaxPixelSize: 500
        ]
        
        guard let source = CGImageSourceCreateWithURL(url as CFURL, nil),
              let cgImage = CGImageSourceCreateThumbnailAtIndex(source, 0, options as CFDictionary) else {
            return nil
        }
        
        // Save to App Group container so the widget view can access it even after provider finishes
        let fileManager = FileManager.default
        guard let containerURL = fileManager.containerURL(forSecurityApplicationGroupIdentifier: "group.com.nock.nock") else {
            return nil
        }
        
        let destinationURL = containerURL.appendingPathComponent("vibe_thumb_\(vibeId).jpg")
        
        // Convert to JPEG and save
        let uiImage = UIImage(cgImage: cgImage)
        if let data = uiImage.jpegData(compressionQuality: 0.8) {
            try data.write(to: destinationURL)
            return destinationURL
        }
        
        return nil
    }
}

// MARK: - Play Audio Intent (Interactive Widget - iOS 17+)
@available(iOS 17.0, *)
struct PlayVibeIntent: AppIntent {
    static var title: LocalizedStringResource = "Play Vibe"
    static var description = IntentDescription("Plays the audio message from the widget")
    
    @Parameter(title: "Audio URL")
    var audioUrl: String
    
    @Parameter(title: "Vibe ID")
    var vibeId: String
    
    init() {
        self.audioUrl = ""
        self.vibeId = ""
    }
    
    init(audioUrl: String, vibeId: String) {
        self.audioUrl = audioUrl
        self.vibeId = vibeId
    }
    
    func perform() async throws -> some IntentResult {
        // In iOS 17+, we can use AudioPlaybackIntent for background audio
        // For now, open the app with deep link
        
        // Update UserDefaults to mark as played
        let sharedDefaults = UserDefaults(suiteName: "group.com.nock.nock")
        sharedDefaults?.set(true, forKey: "isPlayed")
        
        // CRITICAL FIX: Store pending read receipt for sync to Firestore
        // The main app will read this on launch and sync to Firestore
        // NOTE: Store as JSON string for HomeWidget compatibility
        // Flutter's HomeWidget.getWidgetData() reads String, not StringArray
        var pendingReceipts = sharedDefaults?.stringArray(forKey: "pending_read_receipts") ?? []
        if !pendingReceipts.contains(vibeId) {
            pendingReceipts.append(vibeId)
            sharedDefaults?.set(pendingReceipts, forKey: "pending_read_receipts")
            
            // ALSO store as JSON string for Flutter HomeWidget compatibility
            if let jsonData = try? JSONSerialization.data(withJSONObject: pendingReceipts),
               let jsonString = String(data: jsonData, encoding: .utf8) {
                sharedDefaults?.set(jsonString, forKey: "pending_read_receipts_json")
            }
        }
        
        // Trigger widget refresh
        WidgetCenter.shared.reloadTimelines(ofKind: "VibeWidget")
        
        // In production, use AudioPlaybackIntent to play audio in background
        // For MVP, open the app
        return .result()
    }
}

// MARK: - Widget View
struct VibeWidgetEntryView: View {
    var entry: VibeTimelineProvider.Entry
    @Environment(\.widgetFamily) var family

    var body: some View {
        // LOCK SCREEN WIDGET: Compact circular/rectangular view for iOS 16+ Lock Screen
        switch family {
        case .accessoryCircular:
            accessoryCircularView
        case .accessoryRectangular:
            accessoryRectangularView
        case .accessoryInline:
            accessoryInlineView
        default:
            // Home Screen widgets (.systemSmall, .systemMedium)
            homeScreenView
        }
    }
    
    // MARK: - Lock Screen: Circular Widget (iOS 16+)
    private var accessoryCircularView: some View {
        ZStack {
            // Show "NEW" indicator or sender initial
            if let vibeData = entry.vibeData {
                if !vibeData.isPlayed {
                    // New vibe - show pulsing indicator
                    AccessoryWidgetBackground()
                    VStack(spacing: 2) {
                        Image(systemName: "waveform")
                            .font(.system(size: 16, weight: .bold))
                        Text("NEW")
                            .font(.system(size: 8, weight: .bold))
                    }
                } else {
                    // Played - show sender initial
                    AccessoryWidgetBackground()
                    Text(String(vibeData.senderName.prefix(1)).uppercased())
                        .font(.system(size: 24, weight: .bold))
                }
            } else {
                // No vibe - show app icon
                AccessoryWidgetBackground()
                Image(systemName: "hand.wave.fill")
                    .font(.system(size: 20))
            }
        }
    }
    
    // MARK: - Lock Screen: Rectangular Widget (iOS 16+)
    private var accessoryRectangularView: some View {
        HStack(spacing: 8) {
            // Left: Sender initial in circle
            ZStack {
                Circle()
                    .fill(.white.opacity(0.2))
                    .frame(width: 36, height: 36)
                Text(String((entry.vibeData?.senderName ?? "N").prefix(1)).uppercased())
                    .font(.system(size: 16, weight: .bold))
            }
            
            // Right: Sender name + status
            VStack(alignment: .leading, spacing: 2) {
                HStack(spacing: 4) {
                    if let vibeData = entry.vibeData, !vibeData.isPlayed {
                        Circle()
                            .fill(Color(hex: "D4F49C"))
                            .frame(width: 6, height: 6)
                    }
                    Text(entry.vibeData?.senderName ?? "Nock")
                        .font(.system(size: 14, weight: .semibold))
                        .lineLimit(1)
                }
                
                if let transcription = entry.vibeData?.transcription, !transcription.isEmpty {
                    Text(transcription)
                        .font(.system(size: 11))
                        .foregroundStyle(.secondary)
                        .lineLimit(1)
                        .privacySensitive()
                } else if let duration = entry.vibeData?.audioDuration, duration > 0 {
                    Text("\(duration)s voice note")
                        .font(.system(size: 11))
                        .foregroundStyle(.secondary)
                }
            }
            
            Spacer()
        }
    }
    
    // MARK: - Lock Screen: Inline Widget (iOS 16+)
    private var accessoryInlineView: some View {
        HStack(spacing: 4) {
            if let vibeData = entry.vibeData {
                if !vibeData.isPlayed {
                    Image(systemName: "waveform")
                }
                Text(vibeData.senderName)
                if let duration = vibeData.audioDuration, duration > 0 {
                    Text("â€¢ \(duration)s")
                        .foregroundStyle(.secondary)
                }
            } else {
                Image(systemName: "hand.wave.fill")
                Text("Nock")
            }
        }
    }
    
    // MARK: - Home Screen Widget View (Original)
    private var homeScreenView: some View {
        ZStack {
            // Background - CRITICAL: Use localImageURL for 0-RAM timeline caching
            if let vibeData = entry.vibeData {
                if let localURL = vibeData.localImageURL,
                   let uiImage = UIImage(contentsOfFile: localURL.path) {
                    Image(uiImage: uiImage)
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                } else {
                    gradientBackground
                }
            } else {
                gradientBackground
            }
            
            // Overlay gradient for text readability
            LinearGradient(
                gradient: Gradient(colors: [
                    Color.clear,
                    Color(hex: "121226").opacity(0.8)
                ]),
                startPoint: .top,
                endPoint: .bottom
            )
            
            // ðŸŽ¬ 4-State Widget Protocol: Content Type Overlays
            if let vibeData = entry.vibeData {
                if vibeData.isVideo {
                    // VIDEO: Large centered play button with dark overlay
                    Color.black.opacity(0.3)
                    VStack {
                        Spacer()
                        Image(systemName: "play.circle.fill")
                            .font(.system(size: 50))
                            .foregroundColor(.white.opacity(0.9))
                            .shadow(radius: 8)
                        Text("Video")
                            .font(.system(size: 12, weight: .medium))
                            .foregroundColor(.white.opacity(0.8))
                            .padding(.top, 4)
                        Spacer()
                    }
                } else if vibeData.isAudioOnly {
                    // AUDIO ONLY: Mic icon in center (avatar is background)
                    VStack {
                        Spacer()
                        ZStack {
                            Circle()
                                .fill(Color.white.opacity(0.15))
                                .frame(width: 60, height: 60)
                            Image(systemName: "mic.fill")
                                .font(.system(size: 24))
                                .foregroundColor(.white)
                        }
                        Text("\(vibeData.audioDuration)s voice note")
                            .font(.system(size: 11, weight: .medium))
                            .foregroundColor(.white.opacity(0.8))
                            .padding(.top, 8)
                        Spacer()
                    }
                }
                // IMAGE + AUDIO / IMAGE ONLY: No center overlay (showing the photo)
            }
            
            // Distance Badge - Top left corner
            if let vibeData = entry.vibeData,
               let distance = vibeData.distance,
               !distance.isEmpty {
                VStack {
                    HStack {
                        Text("ðŸ“ \(distance)")
                            .font(.system(size: 10, weight: .medium, design: .monospaced))
                            .foregroundColor(.white)
                            .padding(.horizontal, 8)
                            .padding(.vertical, 4)
                            .background(Color(hex: "121226").opacity(0.6))
                            .cornerRadius(8)
                        Spacer()
                    }
                    Spacer()
                }
                .padding(8)
            }
            
            // Content
            VStack(alignment: .leading, spacing: 8) {
                Spacer()
                
                HStack {
                    VStack(alignment: .leading, spacing: 4) {
                        // New indicator
                        if let vibeData = entry.vibeData, !vibeData.isPlayed {
                            HStack(spacing: 4) {
                                Circle()
                                    .fill(Color(hex: "D4F49C"))
                                    .frame(width: 8, height: 8)
                                Text("NEW")
                                    .font(.system(size: 10, weight: .bold, design: .monospaced))
                                    .foregroundColor(Color(hex: "D4F49C"))
                            }
                        }
                        
                        // Sender name
                        Text(entry.vibeData?.senderName ?? "Vibe")
                            .font(.system(size: 16, weight: .bold, design: .monospaced))
                            .foregroundColor(.white)
                        
                        // Transcription or duration info
                        // ðŸŽ¬ 4-State Protocol: Different labels per content type
                        if let vibeData = entry.vibeData {
                            if let transcription = vibeData.transcription, !transcription.isEmpty {
                                Text("\"\(transcription)\"")
                                    .font(.system(size: 11, design: .rounded))
                                    .foregroundColor(.white.opacity(0.9))
                                    .lineLimit(2)
                                    .italic()
                                    .privacySensitive()
                            } else if vibeData.isVideo {
                                Text("ðŸ“¹ Video â€¢ \(vibeData.audioDuration)s")
                                    .font(.system(size: 12, design: .monospaced))
                                    .foregroundColor(.white.opacity(0.8))
                            } else if vibeData.isAudioOnly {
                                Text("ðŸŽ¤ Voice note â€¢ \(vibeData.audioDuration)s")
                                    .font(.system(size: 12, design: .monospaced))
                                    .foregroundColor(.white.opacity(0.8))
                            } else if vibeData.audioDuration > 0 {
                                Text("ðŸ“· Photo â€¢ \(vibeData.audioDuration)s audio")
                                    .font(.system(size: 12, design: .monospaced))
                                    .foregroundColor(.white.opacity(0.8))
                            } else {
                                Text("ðŸ“· Photo")
                                    .font(.system(size: 12, design: .monospaced))
                                    .foregroundColor(.white.opacity(0.8))
                            }
                        }
                    }
                    
                    Spacer()
                    
                    HStack(spacing: 12) {
                        // Play button
                        if entry.vibeData != nil {
                            playButton
                        }
                        
                        // Reply button (Walkie-Talkie)
                        // CRITICAL: Aligned with Research Recommendation 10.1
                        // Opens app directly into Recording Mode for this friend
                        if entry.vibeData != nil {
                            replyButton
                        }
                    }
                }
            }
            .padding(0)
        }
        .containerBackground(for: .widget) {
            gradientBackground
        }
    }
    
    private var gradientBackground: some View {
        LinearGradient(
            gradient: Gradient(colors: [
                Color(hex: "121226"),
                Color(hex: "0A0A1A")
            ]),
            startPoint: .topLeading,
            endPoint: .bottomTrailing
        )
    }
    
    @ViewBuilder
    private var playButton: some View {
        if #available(iOS 17.0, *) {
            // CRITICAL FIX: Use VibeAudioPlaybackIntent (AudioPlaybackIntent protocol)
            // NOT PlayVibeIntent which only updates UserDefaults without playing audio.
            // AudioPlaybackIntent grants iOS background audio entitlement needed to
            // keep the process alive while audio plays.
            Button(intent: VibeAudioPlaybackIntent(
                audioUrl: entry.vibeData?.audioUrl ?? "",
                senderName: entry.vibeData?.senderName ?? "Vibe",
                vibeId: entry.vibeData?.vibeId ?? ""
            )) {
                playButtonContent
            }
            .buttonStyle(.plain)
        } else {
            // Pre-iOS 17: Link opens the app
            Link(destination: URL(string: "nock://player/\(entry.vibeData?.vibeId ?? "")")!) {
                playButtonContent
            }
        }
    }
    
    private var playButtonContent: some View {
        ZStack {
            Circle()
                .fill(Color(hex: "D4F49C").opacity(0.15))
                .frame(width: 44, height: 44)
            
            Circle()
                .stroke(Color(hex: "D4F49C").opacity(0.8), lineWidth: 1.5)
                .frame(width: 44, height: 44)
            
            Image(systemName: "play.fill")
                .font(.system(size: 16))
                .foregroundColor(Color(hex: "D4F49C"))
        }
    }
    
    @ViewBuilder
    private var replyButton: some View {
        // Use RecordVibeIntent which deep links to nock://record?to=friendId
        Button(intent: RecordVibeIntent(friendId: entry.vibeData?.senderId ?? "")) {
            ZStack {
                Circle()
                    .fill(Color(hex: "E5D1FA").opacity(0.15))
                    .frame(width: 44, height: 44)
                
                Circle()
                    .stroke(Color(hex: "E5D1FA").opacity(0.8), lineWidth: 1.5)
                    .frame(width: 44, height: 44)
                
                Image(systemName: "mic.fill")
                    .font(.system(size: 18))
                    .foregroundColor(Color(hex: "E5D1FA"))
            }
        }
        .buttonStyle(.plain)
    }
}

// MARK: - Widget Definition
struct VibeWidget: Widget {
    let kind: String = "VibeWidget"

    var body: some WidgetConfiguration {
        AppIntentConfiguration(
            kind: kind,
            intent: ConfigurationAppIntent.self,
            provider: VibeTimelineProvider()
        ) { entry in
            VibeWidgetEntryView(entry: entry)
        }
        .configurationDisplayName("Vibe")
        .description("See your latest voice messages")
        .supportedFamilies([.systemSmall, .systemMedium, .accessoryCircular, .accessoryRectangular, .accessoryInline])
    }
}

// MARK: - Color Extension
extension Color {
    init(hex: String) {
        let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)
        var int: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&int)
        let a, r, g, b: UInt64
        switch hex.count {
        case 3: // RGB (12-bit)
            (a, r, g, b) = (255, (int >> 8) * 17, (int >> 4 & 0xF) * 17, (int & 0xF) * 17)
        case 6: // RGB (24-bit)
            (a, r, g, b) = (255, int >> 16, int >> 8 & 0xFF, int & 0xFF)
        case 8: // ARGB (32-bit)
            (a, r, g, b) = (int >> 24, int >> 16 & 0xFF, int >> 8 & 0xFF, int & 0xFF)
        default:
            (a, r, g, b) = (1, 1, 1, 0)
        }
        self.init(
            .sRGB,
            red: Double(r) / 255,
            green: Double(g) / 255,
            blue:  Double(b) / 255,
            opacity: Double(a) / 255
        )
    }
}

// MARK: - Memory Efficient Downsampling
extension View {
    func downsample(imageData: Data, to pointSize: CGSize) -> UIImage? {
        let imageSourceOptions = [kCGImageSourceShouldCache: false] as CFDictionary
        guard let imageSource = CGImageSourceCreateWithData(imageData as CFData, imageSourceOptions) else {
            return nil
        }
        
        let scale = UIScreen.main.scale
        let maxDimensionInPixels = max(pointSize.width, pointSize.height) * scale
        
        let downsampleOptions = [
            kCGImageSourceCreateThumbnailFromImageAlways: true,
            kCGImageSourceShouldCacheImmediately: true,
            kCGImageSourceCreateThumbnailWithTransform: true,
            kCGImageSourceThumbnailMaxPixelSize: maxDimensionInPixels
        ] as CFDictionary
        
        guard let downsampledImage = CGImageSourceCreateThumbnailAtIndex(imageSource, 0, downsampleOptions) else {
            return nil
        }
        
        return UIImage(cgImage: downsampledImage)
    }
}

// MARK: - Preview
#Preview(as: .systemSmall) {
    VibeWidget()
} timeline: {
    VibeEntry(
        date: .now,
        vibeData: VibeData(
            senderName: "Sarah",
            audioUrl: "https://example.com/audio.m4a",
            imageUrl: "",
            vibeId: "123",
            timestamp: Date(),
            isPlayed: false,
            audioDuration: 5
        ),
        configuration: ConfigurationAppIntent()
    )
    VibeEntry(
        date: .now,
        vibeData: nil,
        configuration: ConfigurationAppIntent()
    )
}



========================================

FILE #85: E:\Vive\ios\VibeWidget\VibeWidgetBundle.swift

========================================


import WidgetKit
import SwiftUI

@main
struct VibeWidgetBundle: WidgetBundle {
    var body: some Widget {
        VibeWidget()    // Shows latest vibe (existing)
        BFFWidget()     // Direct contact widget
        SquadWidget()   // NEW: Vibe feed widget
    }
}

